{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spatial Polars","text":"<p>A package that extends polars for working with geospatial data in polars at blazing speed.</p> <p>Spatial polars relies on polars, shapely, pyogrio, geoarrow-python, and pyproj for I/O and processing.</p> <p>Spatial polars uses lonboard for displaying geospatial data on an interactive map</p> <p>Spatial polars is mostly just glue code connecting the work of others to bring spatial funcitonality to polars.</p>"},{"location":"#installation","title":"Installation","text":"<p>Spatial polars can be installed from pypi <pre><code>pip install spatial-polars\n</code></pre></p>"},{"location":"#lazily-access-geospatial-data","title":"Lazily access geospatial data","text":"<p>Spatial polars scan_spatial function will scan geoparquet files and any other data source supported by pyogrio and return a polars LazyFrame. A read_spatial function is also provided which simply wraps scan_spatial with a .collect(streaming=True) at the end to return a polars dataframe. The scan_spatial function was the reason this package was created, it is much preferred over the read_spatial function for the same reasons that polars recommends using the lazy API over the eager API.</p>"},{"location":"#geometry-column","title":"Geometry column","text":"<p>When spatial polars reads data from a spatial data source, the geometries are stored in a polars struct named \"geometry\" with two fields.  </p> <ul> <li>wkb_geometry field: A polars binary series for the geometry of each feature as WKB </li> <li>crs field: A polars categorical series for the coordinate reference system as WKT (1)</li> </ul> <ol> <li>Using a categorical makes the series' RAM consumption very small.</li> </ol> <p>Storing the geometries in this manner has an advantage over using a polars binary field holding EWKB, because this allows spatial polars to work with custom projections which do not have a SRID, without a need to store custom SRID codes/CRS definition elsewhere.</p> <p>Warning about CRS</p> <p>All geometries in a single column are expected to have the same CRS.  Currently there is nothing enforcing or validating all the geometries use the same CRS.</p> <p>Mixed geometry types in a single series</p> <p>Spatial polars allows you to intermix geometry types (eg. points and lines) in the same geometry column.  Attempting to write a dataframe with a geometry column that has mixed geometry types may produce an error if the format is not capable of handling more than one geometry type.</p>"},{"location":"#spatial-expressions","title":"Spatial Expressions","text":"<p>Many expressions are included which work with the geometry struct.  The expressions all work in a similar manner</p> <ol> <li>Converts the polars series to a numpy array of WKB</li> <li>Converts the array of WKB to shapely geometry objects</li> <li>Uses shapely to do the spatial operation</li> <li>Depending on the result of the shapely function:<ul> <li>Result is an array of geometries: the result will be converted back to WKB and stored in a struct with the same CRS as the input.  </li> <li>Result is not an array of geometries: the result will be an appropriately typed polars series.</li> </ul> </li> </ol> <p>Spatial polars expressions can be accesssed in two ways:  </p> Using the .spatial namespace<pre><code>df.with_columns(\n    pl.col(\"geometry\").spatial.buffer(10) # (1)!\n)\n</code></pre> <ol> <li>This feels natural to polars users, and is totally usable, but typehints will not be avaliable in your IDE.</li> </ol> <p>Or directly from the <code>SpatialExpr</code> class: Using the SpatialExpr class<pre><code>df.with_columns(\n    SpatialExpr(pl.col(\"geometry\")).buffer(10) # (1)!\n)\n</code></pre></p> <ol> <li>This feels less natural to polars users, but typehints will be avaliable in your IDE.</li> </ol>"},{"location":"#spatial-expressions-which-use-more-than-geometry","title":"Spatial expressions which use more than geometry","text":"<p>Expressions in polars require a single column as the input. For computations involving two geometries, if the computation should be applied to the geometries in the column and a single other geometry, that geometry can be supplied to the expression as a scalar. See geometry column and scalar geometry input expressions for more details.</p> Spatial Expression with column of geometries and a scalar geometry<pre><code>my_point = shapely.Point(0,0)\ndf.with_columns(\n    pl.col(\"geometry\").spatial.distance(my_point).alias(\"dist_to_my_point\") # (1)!\n)\n</code></pre> <ol> <li>This will compute the distance of all the geometries in the <code>geometry</code> column of the dataframe to <code>my_point</code></li> </ol> <p>However if the computation needs to be run between two geometries each coming from different column in the dataframe, the two geometry struct columns must be placed into a single struct which is then supplied to the spatial polars expression. See two geometry column input expressions for more details.</p> Spatial Expression with two columns of geometries<pre><code>df.with_columns( # (1)!\n    pl.struct(\n        c.geometry, \n        c.geometry_other\n    ).spatial.distance().alias(\"dist_to_other\") # (2)!\n)\n</code></pre> <ol> <li>This dataframe has two geomtry columns, one named <code>geometry</code> and another named <code>geometry_other</code>. </li> <li>wrapping the two geomtry columns in a struct and calling the <code>.spatial.distance</code> expression from the struct will compute the distance between each pair of geometries in the dataframe row-wise.</li> </ol>"},{"location":"#motivation","title":"Motivation","text":"<p>Spatial polars was motivated by interest in polars IO plugins, and wanting to be able to easily read data from geopackages and GPX files (1) into a polars dataframe.</p> <ol> <li>GPX files are not offically supported by pyogrio, but seems to work on my end.</li> </ol>"},{"location":"#thank-you","title":"Thank you!","text":"<p>This project would not be possible without all the work from the maintainers/contributors of of all the packages it's built on listed above, along with all the code they're built on, and inspired by.</p>"},{"location":"SpatialExpr/","title":"Spatial Expressions","text":"<p>All expressions listed are avaliable under the <code>.spatial</code> namespace.</p>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties","title":"<code>GeometryProperties</code>","text":"<p>Expressions derived from shapely's geometry properties</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class GeometryProperties:\n    \"\"\"Expressions derived from shapely's [geometry properties](https://shapely.readthedocs.io/en/stable/properties.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def force_2d(self):\n        \"\"\"\n        Force the dimensionality of a geometry to 2D.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.force_2d(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def force_3d(self):\n        \"\"\"\n        Force the dimensionality of a geometry to 3D.\n\n        2D geometries will get the provided Z coordinate; Z coordinates of 3D geometries are unchanged (unless they are nan).\n\n        Note that for empty geometries, 3D is only supported since GEOS 3.9 and then still only for simple geometries (non-collections).\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.force_3d(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def get_coordinate_dimension(self):\n        \"\"\"\n        Return the dimensionality of the coordinates in a geometry (2, 3 or 4).\n\n        The return value can be one of the following:\n\n        Return 2 for geometries with XY coordinate types,\n\n        Return 3 for XYZ or XYM coordinate types (distinguished by has_z() or has_m()),\n\n        Return 4 for XYZM coordinate types,\n\n        Return -1 for missing geometries (None values).\n\n        Note that with GEOS &lt; 3.12, if the first Z coordinate equals nan, this function will return 2. Geometries with M coordinates are supported with GEOS &gt;= 3.12.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_coordinate_dimension(),\n            return_dtype=pl.Int8,\n            is_elementwise=True,\n        )\n\n    def get_dimensions(self):\n        \"\"\"\n        Return the inherent dimensionality of a geometry.\n\n        The inherent dimension is 0 for points, 1 for linestrings and linearrings, and 2 for polygons. For geometrycollections it is the max of the containing elements. Empty collections and None values return -1.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_dimensions(),\n            return_dtype=pl.Int8,\n            is_elementwise=True,\n        )\n\n    def get_exterior_ring(self):\n        \"\"\"\n        Return the exterior ring of a polygon.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_exterior_ring(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def get_geometry(self, index: int):\n        \"\"\"\n        Return the nth geometry from a collection of geometries.\n\n        Parameters\n        ----------\n        index\n            Negative values count from the end of the collection backwards.\n        \"\"\"\n        if index is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.get_geometry(index),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.get_geometry(\n                    combined.struct[1],\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def get_interior_ring(self, index: int):\n        \"\"\"\n        Return the nth interior ring of a polygon.\n\n        The number of interior rings in non-polygons equals zero.\n        \"\"\"\n        if index is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.get_interior_ring(index),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.get_interior_ring(\n                    combined.struct[1],\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def get_num_coordinates(self):\n        \"\"\"\n        Return the total number of coordinates in a geometry.\n\n        Returns 0 for not-a-geometry values.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_num_coordinates(),\n            return_dtype=pl.Int32,\n            is_elementwise=True,\n        )\n\n    def get_num_interior_rings(self):\n        \"\"\"\n        Return number of internal rings in a polygon.\n\n        Returns 0 for not-a-geometry values.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_num_interior_rings(),\n            return_dtype=pl.Int32,\n            is_elementwise=True,\n        )\n\n    def get_num_points(self):\n        \"\"\"\n        Return the number of points in a linestring or linearring.\n\n        Returns 0 for not-a-geometry values. The number of points in geometries other than linestring or linearring equals zero.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_num_points(),\n            return_dtype=pl.Int32,\n            is_elementwise=True,\n        )\n\n    def get_point(self, index: int):\n        \"\"\"\n        Return the nth point of a linestring or linearring.\n        \"\"\"\n        if index is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.get_point(index),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.get_point(\n                    combined.struct[1],\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def get_type_id(self):\n        \"\"\"\n        Return the type ID of a geometry.\n\n        Possible values are:\n\n        None (missing) is -1\n\n        POINT is 0\n\n        LINESTRING is 1\n\n        LINEARRING is 2\n\n        POLYGON is 3\n\n        MULTIPOINT is 4\n\n        MULTILINESTRING is 5\n\n        MULTIPOLYGON is 6\n\n        GEOMETRYCOLLECTION is 7\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_type_id(),\n            return_dtype=pl.Int8,\n            is_elementwise=True,\n        )\n\n    def get_x(self):\n        \"\"\"\n        Return the x-coordinate of a point.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_x(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def get_y(self):\n        \"\"\"\n        Return the y-coordinate of a point.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_y(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def get_z(self):\n        \"\"\"\n        Return the z-coordinate of a point.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_z(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def get_m(self):\n        \"\"\"\n        Return the m-coordinate of a point.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_m(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.force_2d","title":"<code>force_2d()</code>","text":"<p>Force the dimensionality of a geometry to 2D.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def force_2d(self):\n    \"\"\"\n    Force the dimensionality of a geometry to 2D.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.force_2d(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.force_3d","title":"<code>force_3d()</code>","text":"<p>Force the dimensionality of a geometry to 3D.</p> <p>2D geometries will get the provided Z coordinate; Z coordinates of 3D geometries are unchanged (unless they are nan).</p> <p>Note that for empty geometries, 3D is only supported since GEOS 3.9 and then still only for simple geometries (non-collections).</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def force_3d(self):\n    \"\"\"\n    Force the dimensionality of a geometry to 3D.\n\n    2D geometries will get the provided Z coordinate; Z coordinates of 3D geometries are unchanged (unless they are nan).\n\n    Note that for empty geometries, 3D is only supported since GEOS 3.9 and then still only for simple geometries (non-collections).\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.force_3d(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_coordinate_dimension","title":"<code>get_coordinate_dimension()</code>","text":"<p>Return the dimensionality of the coordinates in a geometry (2, 3 or 4).</p> <p>The return value can be one of the following:</p> <p>Return 2 for geometries with XY coordinate types,</p> <p>Return 3 for XYZ or XYM coordinate types (distinguished by has_z() or has_m()),</p> <p>Return 4 for XYZM coordinate types,</p> <p>Return -1 for missing geometries (None values).</p> <p>Note that with GEOS &lt; 3.12, if the first Z coordinate equals nan, this function will return 2. Geometries with M coordinates are supported with GEOS &gt;= 3.12.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_coordinate_dimension(self):\n    \"\"\"\n    Return the dimensionality of the coordinates in a geometry (2, 3 or 4).\n\n    The return value can be one of the following:\n\n    Return 2 for geometries with XY coordinate types,\n\n    Return 3 for XYZ or XYM coordinate types (distinguished by has_z() or has_m()),\n\n    Return 4 for XYZM coordinate types,\n\n    Return -1 for missing geometries (None values).\n\n    Note that with GEOS &lt; 3.12, if the first Z coordinate equals nan, this function will return 2. Geometries with M coordinates are supported with GEOS &gt;= 3.12.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_coordinate_dimension(),\n        return_dtype=pl.Int8,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_dimensions","title":"<code>get_dimensions()</code>","text":"<p>Return the inherent dimensionality of a geometry.</p> <p>The inherent dimension is 0 for points, 1 for linestrings and linearrings, and 2 for polygons. For geometrycollections it is the max of the containing elements. Empty collections and None values return -1.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_dimensions(self):\n    \"\"\"\n    Return the inherent dimensionality of a geometry.\n\n    The inherent dimension is 0 for points, 1 for linestrings and linearrings, and 2 for polygons. For geometrycollections it is the max of the containing elements. Empty collections and None values return -1.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_dimensions(),\n        return_dtype=pl.Int8,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_exterior_ring","title":"<code>get_exterior_ring()</code>","text":"<p>Return the exterior ring of a polygon.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_exterior_ring(self):\n    \"\"\"\n    Return the exterior ring of a polygon.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_exterior_ring(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_geometry","title":"<code>get_geometry(index)</code>","text":"<p>Return the nth geometry from a collection of geometries.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Negative values count from the end of the collection backwards.</p> required Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_geometry(self, index: int):\n    \"\"\"\n    Return the nth geometry from a collection of geometries.\n\n    Parameters\n    ----------\n    index\n        Negative values count from the end of the collection backwards.\n    \"\"\"\n    if index is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_geometry(index),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.get_geometry(\n                combined.struct[1],\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_interior_ring","title":"<code>get_interior_ring(index)</code>","text":"<p>Return the nth interior ring of a polygon.</p> <p>The number of interior rings in non-polygons equals zero.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_interior_ring(self, index: int):\n    \"\"\"\n    Return the nth interior ring of a polygon.\n\n    The number of interior rings in non-polygons equals zero.\n    \"\"\"\n    if index is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_interior_ring(index),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.get_interior_ring(\n                combined.struct[1],\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_num_coordinates","title":"<code>get_num_coordinates()</code>","text":"<p>Return the total number of coordinates in a geometry.</p> <p>Returns 0 for not-a-geometry values.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_num_coordinates(self):\n    \"\"\"\n    Return the total number of coordinates in a geometry.\n\n    Returns 0 for not-a-geometry values.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_num_coordinates(),\n        return_dtype=pl.Int32,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_num_interior_rings","title":"<code>get_num_interior_rings()</code>","text":"<p>Return number of internal rings in a polygon.</p> <p>Returns 0 for not-a-geometry values.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_num_interior_rings(self):\n    \"\"\"\n    Return number of internal rings in a polygon.\n\n    Returns 0 for not-a-geometry values.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_num_interior_rings(),\n        return_dtype=pl.Int32,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_num_points","title":"<code>get_num_points()</code>","text":"<p>Return the number of points in a linestring or linearring.</p> <p>Returns 0 for not-a-geometry values. The number of points in geometries other than linestring or linearring equals zero.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_num_points(self):\n    \"\"\"\n    Return the number of points in a linestring or linearring.\n\n    Returns 0 for not-a-geometry values. The number of points in geometries other than linestring or linearring equals zero.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_num_points(),\n        return_dtype=pl.Int32,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_point","title":"<code>get_point(index)</code>","text":"<p>Return the nth point of a linestring or linearring.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_point(self, index: int):\n    \"\"\"\n    Return the nth point of a linestring or linearring.\n    \"\"\"\n    if index is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.get_point(index),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.get_point(\n                combined.struct[1],\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_type_id","title":"<code>get_type_id()</code>","text":"<p>Return the type ID of a geometry.</p> <p>Possible values are:</p> <p>None (missing) is -1</p> <p>POINT is 0</p> <p>LINESTRING is 1</p> <p>LINEARRING is 2</p> <p>POLYGON is 3</p> <p>MULTIPOINT is 4</p> <p>MULTILINESTRING is 5</p> <p>MULTIPOLYGON is 6</p> <p>GEOMETRYCOLLECTION is 7</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_type_id(self):\n    \"\"\"\n    Return the type ID of a geometry.\n\n    Possible values are:\n\n    None (missing) is -1\n\n    POINT is 0\n\n    LINESTRING is 1\n\n    LINEARRING is 2\n\n    POLYGON is 3\n\n    MULTIPOINT is 4\n\n    MULTILINESTRING is 5\n\n    MULTIPOLYGON is 6\n\n    GEOMETRYCOLLECTION is 7\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_type_id(),\n        return_dtype=pl.Int8,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_x","title":"<code>get_x()</code>","text":"<p>Return the x-coordinate of a point.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_x(self):\n    \"\"\"\n    Return the x-coordinate of a point.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_x(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_y","title":"<code>get_y()</code>","text":"<p>Return the y-coordinate of a point.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_y(self):\n    \"\"\"\n    Return the y-coordinate of a point.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_y(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_z","title":"<code>get_z()</code>","text":"<p>Return the z-coordinate of a point.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_z(self):\n    \"\"\"\n    Return the z-coordinate of a point.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_z(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.GeometryProperties.get_m","title":"<code>get_m()</code>","text":"<p>Return the m-coordinate of a point.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def get_m(self):\n    \"\"\"\n    Return the m-coordinate of a point.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.get_m(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement","title":"<code>Measurement</code>","text":"<p>Expressions derived from shapely's Measurements</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class Measurement:\n    \"\"\"Expressions derived from shapely's [Measurements](https://shapely.readthedocs.io/en/stable/measurement.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def area(self):\n        \"\"\"\n        Compute the area of a (multi)polygon.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.area(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def distance(self, other=None):\n        \"\"\"\n        Compute the Cartesian distance between two geometries.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.distance(other),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.distance(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n\n    def bounds(self):\n        \"\"\"\n        Compute the bounds (extent) of a geometry.\n\n        For each geometry these 4 numbers are returned as a struct: min x, min y, max x, max y.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.bounds(),\n            return_dtype=pl.Array(pl.Float64, 4),\n            is_elementwise=True,\n        )\n\n    def length(self):\n        \"\"\"\n        Compute the length of a (multi)linestring or polygon perimeter.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.length(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def hausdorff_distance(self, other=None, densify=None):\n        \"\"\"\n        Compute the discrete Hausdorff distance between two geometries.\n\n        The Hausdorff distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter `densify` makes this approximation less coarse by splitting the line segments between vertices before computing the distance.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        densify\n            The value of densify is required to be between 0 and 1.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.hausdorff_distance(other, densify),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.hausdorff_distance(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                    densify=densify,\n                ),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n\n    def frechet_distance(self, other=None, densify=None):\n        \"\"\"\n        Compute the discrete Fr\u00e9chet distance between two geometries.\n\n        The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter `densify` makes this approximation less coarse by splitting the line segments between vertices before computing the distance.\n\n        Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        densify\n            The value of densify is required to be between 0 and 1.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.frechet_distance(other, densify),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.frechet_distance(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                    densify=densify,\n                ),\n                return_dtype=pl.Float64,\n                is_elementwise=True,\n            )\n\n    def minimum_clearance(self):\n        \"\"\"\n        Compute the Minimum Clearance distance.\n\n        A geometry's \"minimum clearance\" is the smallest distance by which a vertex of the geometry could be moved to produce an invalid geometry.\n\n        If no minimum clearance exists for a geometry (for example, a single point, or an empty geometry), infinity is returned.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.minimum_clearance(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n\n    def minimum_bounding_radius(self):\n        \"\"\"\n        Compute the radius of the minimum bounding circle of an input geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.minimum_bounding_radius(),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.area","title":"<code>area()</code>","text":"<p>Compute the area of a (multi)polygon.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of a (multi)polygon.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.area(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.distance","title":"<code>distance(other=None)</code>","text":"<p>Compute the Cartesian distance between two geometries.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry for details.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def distance(self, other=None):\n    \"\"\"\n    Compute the Cartesian distance between two geometries.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.distance(other),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.distance(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.bounds","title":"<code>bounds()</code>","text":"<p>Compute the bounds (extent) of a geometry.</p> <p>For each geometry these 4 numbers are returned as a struct: min x, min y, max x, max y.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def bounds(self):\n    \"\"\"\n    Compute the bounds (extent) of a geometry.\n\n    For each geometry these 4 numbers are returned as a struct: min x, min y, max x, max y.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.bounds(),\n        return_dtype=pl.Array(pl.Float64, 4),\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.length","title":"<code>length()</code>","text":"<p>Compute the length of a (multi)linestring or polygon perimeter.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def length(self):\n    \"\"\"\n    Compute the length of a (multi)linestring or polygon perimeter.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.length(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.hausdorff_distance","title":"<code>hausdorff_distance(other=None, densify=None)</code>","text":"<p>Compute the discrete Hausdorff distance between two geometries.</p> <p>The Hausdorff distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter <code>densify</code> makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>densify</code> <p>The value of densify is required to be between 0 and 1.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry for details.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def hausdorff_distance(self, other=None, densify=None):\n    \"\"\"\n    Compute the discrete Hausdorff distance between two geometries.\n\n    The Hausdorff distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter `densify` makes this approximation less coarse by splitting the line segments between vertices before computing the distance.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    densify\n        The value of densify is required to be between 0 and 1.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.hausdorff_distance(other, densify),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.hausdorff_distance(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n                densify=densify,\n            ),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.frechet_distance","title":"<code>frechet_distance(other=None, densify=None)</code>","text":"<p>Compute the discrete Fr\u00e9chet distance between two geometries.</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter <code>densify</code> makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>densify</code> <p>The value of densify is required to be between 0 and 1.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry for details.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def frechet_distance(self, other=None, densify=None):\n    \"\"\"\n    Compute the discrete Fr\u00e9chet distance between two geometries.\n\n    The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter `densify` makes this approximation less coarse by splitting the line segments between vertices before computing the distance.\n\n    Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    densify\n        The value of densify is required to be between 0 and 1.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry) for details.\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.frechet_distance(other, densify),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.frechet_distance(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n                densify=densify,\n            ),\n            return_dtype=pl.Float64,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.minimum_clearance","title":"<code>minimum_clearance()</code>","text":"<p>Compute the Minimum Clearance distance.</p> <p>A geometry's \"minimum clearance\" is the smallest distance by which a vertex of the geometry could be moved to produce an invalid geometry.</p> <p>If no minimum clearance exists for a geometry (for example, a single point, or an empty geometry), infinity is returned.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def minimum_clearance(self):\n    \"\"\"\n    Compute the Minimum Clearance distance.\n\n    A geometry's \"minimum clearance\" is the smallest distance by which a vertex of the geometry could be moved to produce an invalid geometry.\n\n    If no minimum clearance exists for a geometry (for example, a single point, or an empty geometry), infinity is returned.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.minimum_clearance(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Measurement.minimum_bounding_radius","title":"<code>minimum_bounding_radius()</code>","text":"<p>Compute the radius of the minimum bounding circle of an input geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def minimum_bounding_radius(self):\n    \"\"\"\n    Compute the radius of the minimum bounding circle of an input geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.minimum_bounding_radius(),\n        return_dtype=pl.Float64,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates","title":"<code>Predicates</code>","text":"<p>Expressions derived from shapely's Predicates</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class Predicates:\n    \"\"\"Expressions derived from shapely's [Predicates](https://shapely.readthedocs.io/en/stable/predicates.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def has_z(self):\n        \"\"\"\n        Return True if a geometry has Z coordinates.\n\n        Note that for GEOS &lt; 3.12 this function returns False if the (first) Z coordinate equals NaN.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.has_z(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_ccw(self):\n        \"\"\"\n        Return True if a linestring or linearring is counterclockwise.\n\n        Note that there are no checks on whether lines are actually closed and not self-intersecting, while this is a requirement for is_ccw. The recommended usage of this function for linestrings is is_ccw(g) &amp; is_simple(g) and for linearrings is_ccw(g) &amp; is_valid(g).\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_ccw(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_closed(self):\n        \"\"\"\n        Return True if a linestring's first and last points are equal.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_closed(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_empty(self):\n        \"\"\"\n        Return True if a geometry is an empty point, polygon, etc.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_empty(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_geometry(self):\n        \"\"\"\n        Return True if the object is a geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_geometry(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_missing(self):\n        \"\"\"\n        Return True if the object is not a geometry (None).\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_missing(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_ring(self):\n        \"\"\"\n        Return True if a linestring is closed and simple.\n\n        This function will return False for non-linestrings.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_ring(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_simple(self):\n        \"\"\"\n        Return True if the geometry is simple.\n\n        A simple geometry has no anomalous geometric points, such as self-intersections or self tangency.\n\n        Note that polygons and linearrings are assumed to be simple. Use is_valid to check these kind of geometries for self-intersections.\n\n        This function will return False for geometrycollections.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_simple(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_valid(self):\n        \"\"\"\n        Return True if a geometry is well formed.\n\n        Returns False for missing values.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_valid(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_valid_input(self):\n        \"\"\"\n        Return True if the object is a geometry or None.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_valid_input(),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n\n    def is_valid_reason(self):\n        \"\"\"\n        Return a string stating if a geometry is valid and if not, why.\n\n        Returns None for missing values.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.is_valid_reason(),\n            return_dtype=pl.String,\n            is_elementwise=True,\n        )\n\n    def crosses(self, other=None):\n        \"\"\"\n        Return True if A and B spatially cross.\n\n        A crosses B if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension of A or B, and the intersection is not equal to either A or B.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.crosses(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.crosses(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def contains(self, other=None):\n        \"\"\"\n        Return True if geometry B is completely inside geometry A.\n\n        A contains B if no points of B lie in the exterior of A and at least one point of the interior of B lies in the interior of A.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Note\n        ----\n        Following this definition, a geometry does not contain its boundary, but it does contain itself. See contains_properly for a version where a geometry does not contain itself.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.contains(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.contains(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def contains_properly(self, other=None):\n        \"\"\"\n        Return True if geometry B is completely inside geometry A, with no common boundary points.\n\n        A contains B properly if B intersects the interior of A but not the boundary (or exterior). This means that a geometry A does not \"contain properly\" itself, which contrasts with the contains function, where common points on the boundary are allowed.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.contains_properly(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.contains_properly(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def covered_by(self, other=None):\n        \"\"\"\n        Return True if no point in geometry A is outside geometry B.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.covered_by(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.covered_by(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def covers(self, other=None):\n        \"\"\"\n        Return True if no point in geometry B is outside geometry A.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.covers(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.covers(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def disjoint(self, other=None):\n        \"\"\"\n        Return True if A and B do not share any point in space.\n\n        Disjoint implies that overlaps, touches, within, and intersects are False. Note missing (None) values are never disjoint.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.disjoint(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.disjoint(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def equals(self, other=None):\n        \"\"\"\n        Return True if A and B are spatially equal.\n\n        If A is within B and B is within A, A and B are considered equal. The ordering of points can be different.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.equals(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.equals(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def intersects(self, other=None):\n        \"\"\"\n        Return True if A and B share any portion of space.\n\n        Intersects implies that overlaps, touches, covers, or within are True.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.intersects(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.intersects(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def overlaps(self, other=None):\n        \"\"\"\n        Return True if A and B spatially overlap.\n\n        A and B overlap if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves. That is, only polyons can overlap other polygons and only lines can overlap other lines. If A covers or is within B, overlaps won't be True.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.overlaps(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.overlaps(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def touches(self, other=None):\n        \"\"\"\n        Return True if the only points shared between A and B are on their boundaries.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.touches(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.touches(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def within(self, other=None):\n        \"\"\"\n        Return True if geometry A is completely inside geometry B.\n\n        A is within B if no points of A lie in the exterior of B and at least one point of the interior of A lies in the interior of B.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.within(other),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.within(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def relate(self, other=None):\n        \"\"\"\n        Return a string representation of the DE-9IM intersection matrix.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.relate(other),\n                return_dtype=pl.String,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: shapely.relate(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=pl.String,\n                is_elementwise=True,\n            )\n\n    def contains_xy(self, x=None, y=None):\n        \"\"\"\n        Return True if the Point (x, y) is completely inside geom.\n\n        This is a special-case (and faster) variant of the contains function which avoids having to create a Point object if you start from x/y coordinates.\n\n        Note that in the case of points, the contains_properly predicate is equivalent to contains.\n\n        See the docstring of contains for more details about the predicate.\n\n        Parameters\n        ----------\n        x\n            The X coordinate to check\n\n        y\n            The Y coordinate to check\n\n        One geometry different x/y coordinate input\n        -------------------------------------------\n        **To compute between the values in the series and a single x,y pair** provide the `x` and `y` parameters.\n\n        **To compute between two geometries in a column and columns of x/y coordinates of the frame** wrap all columns into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n        \"\"\"\n        if x is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.contains_xy(x, y),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with a geometry and x/y fields.\n            return self._expr.map_batches(\n                lambda combined: shapely.contains_xy(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1],\n                    combined.struct[2],\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def dwithin(self, other=None, distance=None):\n        \"\"\"\n        Return True if the geometries are within a given distance.\n\n        Using this function is more efficient than computing the distance and comparing the result.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        distance\n            The distance to check if the geometries are within\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.dwithin(other, distance),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with a two geometry and distance fields.\n            return self._expr.map_batches(\n                lambda combined: shapely.dwithin(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                    combined.struct[2],\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def intersects_xy(self, x, y):\n        \"\"\"\n        Return True if geom and the Point (x, y) share any portion of space.\n\n        This is a special-case (and faster) variant of the intersects function which avoids having to create a Point object if you start from x/y coordinates.\n\n        See the docstring of intersects for more details about the predicate.\n\n        Parameters\n        ----------\n        x\n            The X coordinate to check\n\n        y\n            The Y coordinate to check\n\n        One geometry different x/y coordinate input\n        -------------------------------------------\n        **To compute between the values in the series and a single x,y pair** provide the `x` and `y` parameters.\n\n        **To compute between two geometries in a column and columns of x/y coordinates of the frame** wrap all columns into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if x is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.intersects_xy(x, y),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with a geometry and x/y fields.\n            return self._expr.map_batches(\n                lambda combined: shapely.intersects_xy(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1],\n                    combined.struct[2],\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def equals_exact(self, other, tolerance):\n        \"\"\"\n        Return True if the geometries are structurally equivalent within a given tolerance.\n\n        This method uses exact coordinate equality, which requires coordinates to be equal (within specified tolerance) and in the same order for all components (vertices, rings, or parts) of a geometry. This is in contrast with the equals function which uses spatial (topological) equality and does not require all components to be in the same order. Because of this, it is possible for equals to be True while equals_exact is False.\n\n        The order of the coordinates can be normalized (by setting the normalize keyword to True) so that this function will return True when geometries are structurally equivalent but differ only in the ordering of vertices. However, this function will still return False if the order of interior rings within a Polygon or the order of geometries within a multi geometry are different.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        tolerance\n            The tolerance to use in the comparison.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.equals_exact(other, tolerance),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometry and tolerance fields.\n            return self._expr.map_batches(\n                lambda combined: shapely.equals_exact(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                    combined.struct[2],\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n\n    def relate_pattern(self, other, pattern):\n        \"\"\"\n        Return True if the DE-9IM relationship code satisfies the pattern.\n\n        This function compares the DE-9IM code string for two geometries against a specified pattern. If the string matches the pattern then True is returned, otherwise False. The pattern specified can be an exact match (0, 1 or 2), a boolean match (uppercase T or F), or a wildcard (*). For example, the pattern for the within predicate is 'T*F**F***'.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        pattern\n            The pattern to match the DE-9IM relationship code against.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.relate_pattern(other, pattern),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometry and pattern fields.\n            return self._expr.map_batches(\n                lambda combined: shapely.relate_pattern(\n                    combined.struct[0].spatial.to_shapely_array(),\n                    combined.struct[1].spatial.to_shapely_array(),\n                    combined.struct[2],\n                ),\n                return_dtype=pl.Boolean,\n                is_elementwise=True,\n            )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.has_z","title":"<code>has_z()</code>","text":"<p>Return True if a geometry has Z coordinates.</p> <p>Note that for GEOS &lt; 3.12 this function returns False if the (first) Z coordinate equals NaN.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def has_z(self):\n    \"\"\"\n    Return True if a geometry has Z coordinates.\n\n    Note that for GEOS &lt; 3.12 this function returns False if the (first) Z coordinate equals NaN.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.has_z(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_ccw","title":"<code>is_ccw()</code>","text":"<p>Return True if a linestring or linearring is counterclockwise.</p> <p>Note that there are no checks on whether lines are actually closed and not self-intersecting, while this is a requirement for is_ccw. The recommended usage of this function for linestrings is is_ccw(g) &amp; is_simple(g) and for linearrings is_ccw(g) &amp; is_valid(g).</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_ccw(self):\n    \"\"\"\n    Return True if a linestring or linearring is counterclockwise.\n\n    Note that there are no checks on whether lines are actually closed and not self-intersecting, while this is a requirement for is_ccw. The recommended usage of this function for linestrings is is_ccw(g) &amp; is_simple(g) and for linearrings is_ccw(g) &amp; is_valid(g).\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_ccw(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_closed","title":"<code>is_closed()</code>","text":"<p>Return True if a linestring's first and last points are equal.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_closed(self):\n    \"\"\"\n    Return True if a linestring's first and last points are equal.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_closed(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_empty","title":"<code>is_empty()</code>","text":"<p>Return True if a geometry is an empty point, polygon, etc.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_empty(self):\n    \"\"\"\n    Return True if a geometry is an empty point, polygon, etc.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_empty(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_geometry","title":"<code>is_geometry()</code>","text":"<p>Return True if the object is a geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_geometry(self):\n    \"\"\"\n    Return True if the object is a geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_geometry(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_missing","title":"<code>is_missing()</code>","text":"<p>Return True if the object is not a geometry (None).</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_missing(self):\n    \"\"\"\n    Return True if the object is not a geometry (None).\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_missing(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_ring","title":"<code>is_ring()</code>","text":"<p>Return True if a linestring is closed and simple.</p> <p>This function will return False for non-linestrings.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_ring(self):\n    \"\"\"\n    Return True if a linestring is closed and simple.\n\n    This function will return False for non-linestrings.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_ring(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_simple","title":"<code>is_simple()</code>","text":"<p>Return True if the geometry is simple.</p> <p>A simple geometry has no anomalous geometric points, such as self-intersections or self tangency.</p> <p>Note that polygons and linearrings are assumed to be simple. Use is_valid to check these kind of geometries for self-intersections.</p> <p>This function will return False for geometrycollections.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_simple(self):\n    \"\"\"\n    Return True if the geometry is simple.\n\n    A simple geometry has no anomalous geometric points, such as self-intersections or self tangency.\n\n    Note that polygons and linearrings are assumed to be simple. Use is_valid to check these kind of geometries for self-intersections.\n\n    This function will return False for geometrycollections.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_simple(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_valid","title":"<code>is_valid()</code>","text":"<p>Return True if a geometry is well formed.</p> <p>Returns False for missing values.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_valid(self):\n    \"\"\"\n    Return True if a geometry is well formed.\n\n    Returns False for missing values.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_valid(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_valid_input","title":"<code>is_valid_input()</code>","text":"<p>Return True if the object is a geometry or None.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_valid_input(self):\n    \"\"\"\n    Return True if the object is a geometry or None.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_valid_input(),\n        return_dtype=pl.Boolean,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.is_valid_reason","title":"<code>is_valid_reason()</code>","text":"<p>Return a string stating if a geometry is valid and if not, why.</p> <p>Returns None for missing values.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def is_valid_reason(self):\n    \"\"\"\n    Return a string stating if a geometry is valid and if not, why.\n\n    Returns None for missing values.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.is_valid_reason(),\n        return_dtype=pl.String,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.crosses","title":"<code>crosses(other=None)</code>","text":"<p>Return True if A and B spatially cross.</p> <p>A crosses B if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension of A or B, and the intersection is not equal to either A or B.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def crosses(self, other=None):\n    \"\"\"\n    Return True if A and B spatially cross.\n\n    A crosses B if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension of A or B, and the intersection is not equal to either A or B.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.crosses(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.crosses(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.contains","title":"<code>contains(other=None)</code>","text":"<p>Return True if geometry B is completely inside geometry A.</p> <p>A contains B if no points of B lie in the exterior of A and at least one point of the interior of B lies in the interior of A.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Note <p>Following this definition, a geometry does not contain its boundary, but it does contain itself. See contains_properly for a version where a geometry does not contain itself.</p> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def contains(self, other=None):\n    \"\"\"\n    Return True if geometry B is completely inside geometry A.\n\n    A contains B if no points of B lie in the exterior of A and at least one point of the interior of B lies in the interior of A.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Note\n    ----\n    Following this definition, a geometry does not contain its boundary, but it does contain itself. See contains_properly for a version where a geometry does not contain itself.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.contains(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.contains(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.contains_properly","title":"<code>contains_properly(other=None)</code>","text":"<p>Return True if geometry B is completely inside geometry A, with no common boundary points.</p> <p>A contains B properly if B intersects the interior of A but not the boundary (or exterior). This means that a geometry A does not \"contain properly\" itself, which contrasts with the contains function, where common points on the boundary are allowed.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def contains_properly(self, other=None):\n    \"\"\"\n    Return True if geometry B is completely inside geometry A, with no common boundary points.\n\n    A contains B properly if B intersects the interior of A but not the boundary (or exterior). This means that a geometry A does not \"contain properly\" itself, which contrasts with the contains function, where common points on the boundary are allowed.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.contains_properly(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.contains_properly(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.covered_by","title":"<code>covered_by(other=None)</code>","text":"<p>Return True if no point in geometry A is outside geometry B.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def covered_by(self, other=None):\n    \"\"\"\n    Return True if no point in geometry A is outside geometry B.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.covered_by(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.covered_by(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.covers","title":"<code>covers(other=None)</code>","text":"<p>Return True if no point in geometry B is outside geometry A.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def covers(self, other=None):\n    \"\"\"\n    Return True if no point in geometry B is outside geometry A.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.covers(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.covers(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.disjoint","title":"<code>disjoint(other=None)</code>","text":"<p>Return True if A and B do not share any point in space.</p> <p>Disjoint implies that overlaps, touches, within, and intersects are False. Note missing (None) values are never disjoint.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def disjoint(self, other=None):\n    \"\"\"\n    Return True if A and B do not share any point in space.\n\n    Disjoint implies that overlaps, touches, within, and intersects are False. Note missing (None) values are never disjoint.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.disjoint(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.disjoint(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.equals","title":"<code>equals(other=None)</code>","text":"<p>Return True if A and B are spatially equal.</p> <p>If A is within B and B is within A, A and B are considered equal. The ordering of points can be different.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def equals(self, other=None):\n    \"\"\"\n    Return True if A and B are spatially equal.\n\n    If A is within B and B is within A, A and B are considered equal. The ordering of points can be different.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.equals(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.equals(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.intersects","title":"<code>intersects(other=None)</code>","text":"<p>Return True if A and B share any portion of space.</p> <p>Intersects implies that overlaps, touches, covers, or within are True.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def intersects(self, other=None):\n    \"\"\"\n    Return True if A and B share any portion of space.\n\n    Intersects implies that overlaps, touches, covers, or within are True.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.intersects(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.intersects(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.overlaps","title":"<code>overlaps(other=None)</code>","text":"<p>Return True if A and B spatially overlap.</p> <p>A and B overlap if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves. That is, only polyons can overlap other polygons and only lines can overlap other lines. If A covers or is within B, overlaps won't be True.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def overlaps(self, other=None):\n    \"\"\"\n    Return True if A and B spatially overlap.\n\n    A and B overlap if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves. That is, only polyons can overlap other polygons and only lines can overlap other lines. If A covers or is within B, overlaps won't be True.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.overlaps(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.overlaps(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.touches","title":"<code>touches(other=None)</code>","text":"<p>Return True if the only points shared between A and B are on their boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def touches(self, other=None):\n    \"\"\"\n    Return True if the only points shared between A and B are on their boundaries.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.touches(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.touches(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.within","title":"<code>within(other=None)</code>","text":"<p>Return True if geometry A is completely inside geometry B.</p> <p>A is within B if no points of A lie in the exterior of B and at least one point of the interior of A lies in the interior of B.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def within(self, other=None):\n    \"\"\"\n    Return True if geometry A is completely inside geometry B.\n\n    A is within B if no points of A lie in the exterior of B and at least one point of the interior of A lies in the interior of B.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.within(other),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.within(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.relate","title":"<code>relate(other=None)</code>","text":"<p>Return a string representation of the DE-9IM intersection matrix.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def relate(self, other=None):\n    \"\"\"\n    Return a string representation of the DE-9IM intersection matrix.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.relate(other),\n            return_dtype=pl.String,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: shapely.relate(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=pl.String,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.contains_xy","title":"<code>contains_xy(x=None, y=None)</code>","text":"<p>Return True if the Point (x, y) is completely inside geom.</p> <p>This is a special-case (and faster) variant of the contains function which avoids having to create a Point object if you start from x/y coordinates.</p> <p>Note that in the case of points, the contains_properly predicate is equivalent to contains.</p> <p>See the docstring of contains for more details about the predicate.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>The X coordinate to check</p> <code>None</code> <code>y</code> <p>The Y coordinate to check</p> <code>None</code> One geometry different x/y coordinate input <p>To compute between the values in the series and a single x,y pair provide the <code>x</code> and <code>y</code> parameters.</p> <p>To compute between two geometries in a column and columns of x/y coordinates of the frame wrap all columns into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def contains_xy(self, x=None, y=None):\n    \"\"\"\n    Return True if the Point (x, y) is completely inside geom.\n\n    This is a special-case (and faster) variant of the contains function which avoids having to create a Point object if you start from x/y coordinates.\n\n    Note that in the case of points, the contains_properly predicate is equivalent to contains.\n\n    See the docstring of contains for more details about the predicate.\n\n    Parameters\n    ----------\n    x\n        The X coordinate to check\n\n    y\n        The Y coordinate to check\n\n    One geometry different x/y coordinate input\n    -------------------------------------------\n    **To compute between the values in the series and a single x,y pair** provide the `x` and `y` parameters.\n\n    **To compute between two geometries in a column and columns of x/y coordinates of the frame** wrap all columns into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n    \"\"\"\n    if x is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.contains_xy(x, y),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with a geometry and x/y fields.\n        return self._expr.map_batches(\n            lambda combined: shapely.contains_xy(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1],\n                combined.struct[2],\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.dwithin","title":"<code>dwithin(other=None, distance=None)</code>","text":"<p>Return True if the geometries are within a given distance.</p> <p>Using this function is more efficient than computing the distance and comparing the result.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>distance</code> <p>The distance to check if the geometries are within</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def dwithin(self, other=None, distance=None):\n    \"\"\"\n    Return True if the geometries are within a given distance.\n\n    Using this function is more efficient than computing the distance and comparing the result.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    distance\n        The distance to check if the geometries are within\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.dwithin(other, distance),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with a two geometry and distance fields.\n        return self._expr.map_batches(\n            lambda combined: shapely.dwithin(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n                combined.struct[2],\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.intersects_xy","title":"<code>intersects_xy(x, y)</code>","text":"<p>Return True if geom and the Point (x, y) share any portion of space.</p> <p>This is a special-case (and faster) variant of the intersects function which avoids having to create a Point object if you start from x/y coordinates.</p> <p>See the docstring of intersects for more details about the predicate.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>The X coordinate to check</p> required <code>y</code> <p>The Y coordinate to check</p> required One geometry different x/y coordinate input <p>To compute between the values in the series and a single x,y pair provide the <code>x</code> and <code>y</code> parameters.</p> <p>To compute between two geometries in a column and columns of x/y coordinates of the frame wrap all columns into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def intersects_xy(self, x, y):\n    \"\"\"\n    Return True if geom and the Point (x, y) share any portion of space.\n\n    This is a special-case (and faster) variant of the intersects function which avoids having to create a Point object if you start from x/y coordinates.\n\n    See the docstring of intersects for more details about the predicate.\n\n    Parameters\n    ----------\n    x\n        The X coordinate to check\n\n    y\n        The Y coordinate to check\n\n    One geometry different x/y coordinate input\n    -------------------------------------------\n    **To compute between the values in the series and a single x,y pair** provide the `x` and `y` parameters.\n\n    **To compute between two geometries in a column and columns of x/y coordinates of the frame** wrap all columns into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if x is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.intersects_xy(x, y),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with a geometry and x/y fields.\n        return self._expr.map_batches(\n            lambda combined: shapely.intersects_xy(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1],\n                combined.struct[2],\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.equals_exact","title":"<code>equals_exact(other, tolerance)</code>","text":"<p>Return True if the geometries are structurally equivalent within a given tolerance.</p> <p>This method uses exact coordinate equality, which requires coordinates to be equal (within specified tolerance) and in the same order for all components (vertices, rings, or parts) of a geometry. This is in contrast with the equals function which uses spatial (topological) equality and does not require all components to be in the same order. Because of this, it is possible for equals to be True while equals_exact is False.</p> <p>The order of the coordinates can be normalized (by setting the normalize keyword to True) so that this function will return True when geometries are structurally equivalent but differ only in the ordering of vertices. However, this function will still return False if the order of interior rings within a Polygon or the order of geometries within a multi geometry are different.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> required <code>tolerance</code> <p>The tolerance to use in the comparison.</p> required Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def equals_exact(self, other, tolerance):\n    \"\"\"\n    Return True if the geometries are structurally equivalent within a given tolerance.\n\n    This method uses exact coordinate equality, which requires coordinates to be equal (within specified tolerance) and in the same order for all components (vertices, rings, or parts) of a geometry. This is in contrast with the equals function which uses spatial (topological) equality and does not require all components to be in the same order. Because of this, it is possible for equals to be True while equals_exact is False.\n\n    The order of the coordinates can be normalized (by setting the normalize keyword to True) so that this function will return True when geometries are structurally equivalent but differ only in the ordering of vertices. However, this function will still return False if the order of interior rings within a Polygon or the order of geometries within a multi geometry are different.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    tolerance\n        The tolerance to use in the comparison.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.equals_exact(other, tolerance),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometry and tolerance fields.\n        return self._expr.map_batches(\n            lambda combined: shapely.equals_exact(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n                combined.struct[2],\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.Predicates.relate_pattern","title":"<code>relate_pattern(other, pattern)</code>","text":"<p>Return True if the DE-9IM relationship code satisfies the pattern.</p> <p>This function compares the DE-9IM code string for two geometries against a specified pattern. If the string matches the pattern then True is returned, otherwise False. The pattern specified can be an exact match (0, 1 or 2), a boolean match (uppercase T or F), or a wildcard (). For example, the pattern for the within predicate is 'TFF*'.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> required <code>pattern</code> <p>The pattern to match the DE-9IM relationship code against.</p> required Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def relate_pattern(self, other, pattern):\n    \"\"\"\n    Return True if the DE-9IM relationship code satisfies the pattern.\n\n    This function compares the DE-9IM code string for two geometries against a specified pattern. If the string matches the pattern then True is returned, otherwise False. The pattern specified can be an exact match (0, 1 or 2), a boolean match (uppercase T or F), or a wildcard (*). For example, the pattern for the within predicate is 'T*F**F***'.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    pattern\n        The pattern to match the DE-9IM relationship code against.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.relate_pattern(other, pattern),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometry and pattern fields.\n        return self._expr.map_batches(\n            lambda combined: shapely.relate_pattern(\n                combined.struct[0].spatial.to_shapely_array(),\n                combined.struct[1].spatial.to_shapely_array(),\n                combined.struct[2],\n            ),\n            return_dtype=pl.Boolean,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations","title":"<code>SetOperations</code>","text":"<p>Expressions derived from shapely's Set Operations</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class SetOperations:\n    \"\"\"Expressions derived from shapely's [Set Operations](https://shapely.readthedocs.io/en/stable/set_operations.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def difference(self, other=None, grid_size=None):\n        \"\"\"\n        Return the part of geometry A that does not intersect with geometry B.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.difference(other, grid_size),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.difference(\n                    combined.struct[1].spatial.to_shapely_array(),\n                    grid_size,\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def intersection(self, other=None, grid_size=None):\n        \"\"\"\n        Return the geometry that is shared between input geometries.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.intersection(other, grid_size),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.intersection(\n                    combined.struct[1].spatial.to_shapely_array(),\n                    grid_size,\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def intersection_all(self, grid_size=None):\n        \"\"\"\n        Return the intersection of multiple geometries.\n\n        This function ignores None values when other Geometry elements are present. If all elements of the given axis are None, an empty GeometryCollection is returned.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.intersection_all(grid_size),\n            return_dtype=spatial_series_dtype,\n            returns_scalar=True,\n        )\n\n    def symmetric_difference(self, other=None, grid_size=None):\n        \"\"\"\n        Return the geometry with the portions of input geometries that do not intersect.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.symmetric_difference(other, grid_size),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.symmetric_difference(\n                    combined.struct[1].spatial.to_shapely_array(), grid_size\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def union(self, other=None, grid_size=None):\n        \"\"\"\n        Merge geometries into one.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.union(other, grid_size),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.union(\n                    combined.struct[1].spatial.to_shapely_array(), grid_size\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def union_all(self, grid_size=None):\n        \"\"\"\n        Return the union of multiple geometries.\n\n        This function ignores None values when other Geometry elements are present. If all elements of the given axis are None an empty GeometryCollection is returned.\n\n        If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n        Parameters\n        ----------\n        grid_size\n            Precision grid size; will use the highest precision of the inputs by default.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.union_all(grid_size),\n            return_dtype=spatial_series_dtype,\n            returns_scalar=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.difference","title":"<code>difference(other=None, grid_size=None)</code>","text":"<p>Return the part of geometry A that does not intersect with geometry B.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def difference(self, other=None, grid_size=None):\n    \"\"\"\n    Return the part of geometry A that does not intersect with geometry B.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.difference(other, grid_size),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.difference(\n                combined.struct[1].spatial.to_shapely_array(),\n                grid_size,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.intersection","title":"<code>intersection(other=None, grid_size=None)</code>","text":"<p>Return the geometry that is shared between input geometries.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def intersection(self, other=None, grid_size=None):\n    \"\"\"\n    Return the geometry that is shared between input geometries.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.intersection(other, grid_size),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.intersection(\n                combined.struct[1].spatial.to_shapely_array(),\n                grid_size,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.intersection_all","title":"<code>intersection_all(grid_size=None)</code>","text":"<p>Return the intersection of multiple geometries.</p> <p>This function ignores None values when other Geometry elements are present. If all elements of the given axis are None, an empty GeometryCollection is returned.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def intersection_all(self, grid_size=None):\n    \"\"\"\n    Return the intersection of multiple geometries.\n\n    This function ignores None values when other Geometry elements are present. If all elements of the given axis are None, an empty GeometryCollection is returned.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.intersection_all(grid_size),\n        return_dtype=spatial_series_dtype,\n        returns_scalar=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.symmetric_difference","title":"<code>symmetric_difference(other=None, grid_size=None)</code>","text":"<p>Return the geometry with the portions of input geometries that do not intersect.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def symmetric_difference(self, other=None, grid_size=None):\n    \"\"\"\n    Return the geometry with the portions of input geometries that do not intersect.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.symmetric_difference(other, grid_size),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.symmetric_difference(\n                combined.struct[1].spatial.to_shapely_array(), grid_size\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.union","title":"<code>union(other=None, grid_size=None)</code>","text":"<p>Merge geometries into one.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> <code>None</code> <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def union(self, other=None, grid_size=None):\n    \"\"\"\n    Merge geometries into one.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.union(other, grid_size),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.union(\n                combined.struct[1].spatial.to_shapely_array(), grid_size\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SetOperations.union_all","title":"<code>union_all(grid_size=None)</code>","text":"<p>Return the union of multiple geometries.</p> <p>This function ignores None values when other Geometry elements are present. If all elements of the given axis are None an empty GeometryCollection is returned.</p> <p>If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.</p> <p>Parameters:</p> Name Type Description Default <code>grid_size</code> <p>Precision grid size; will use the highest precision of the inputs by default.</p> <code>None</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def union_all(self, grid_size=None):\n    \"\"\"\n    Return the union of multiple geometries.\n\n    This function ignores None values when other Geometry elements are present. If all elements of the given axis are None an empty GeometryCollection is returned.\n\n    If grid_size is nonzero, input coordinates will be snapped to a precision grid of that size and resulting coordinates will be snapped to that same grid. If 0, this operation will use double precision coordinates. If None, the highest precision of the inputs will be used, which may be previously set using set_precision. Note: returned geometry does not have precision set unless specified previously by set_precision.\n\n    Parameters\n    ----------\n    grid_size\n        Precision grid size; will use the highest precision of the inputs by default.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.union_all(grid_size),\n        return_dtype=spatial_series_dtype,\n        returns_scalar=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations","title":"<code>ConstructiveOperations</code>","text":"<p>Expressions derived from shapely's Constructive Operations</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class ConstructiveOperations:\n    \"\"\"Expressions derived from shapely's [Constructive Operations](https://shapely.readthedocs.io/en/stable/constructive.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def boundary(self):\n        \"\"\"\n        Return the topological boundary of a geometry.\n\n        This function will return None for geometrycollections.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.boundary(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def buffer(\n        self,\n        distance,\n        quad_segs=8,\n        cap_style=\"round\",\n        join_style=\"round\",\n        mitre_limit=5.0,\n        single_sided=False,\n    ):\n        \"\"\"\n        Compute the buffer of a geometry for positive and negative buffer distance.\n\n        The buffer of a geometry is defined as the Minkowski sum (or difference, for negative distance) of the geometry with a circle with radius equal to the absolute value of the buffer distance.\n\n        The buffer operation always returns a polygonal result. The negative or zero-distance buffer of lines and points is always empty.\n\n        Parameters\n        ----------\n        distance\n            Specifies the circle radius in the Minkowski sum (or difference).\n\n        quad_segs\n            Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.\n\n        cap_style\n            Specifies the shape of buffered line endings. BufferCapStyle.round (`round`) results in circular line endings (see quad_segs). Both BufferCapStyle.square (`square`) and BufferCapStyle.flat (`flat`) result in rectangular line endings, only BufferCapStyle.flat (`flat`) will end at the original vertex, while BufferCapStyle.square (`square`) involves adding the buffer width.\n\n        join_style\n            Specifies the shape of buffered line midpoints. BufferJoinStyle.round (`round`) results in rounded shapes. BufferJoinStyle.bevel (`bevel`) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (`mitre`) results in a single vertex that is beveled depending on the mitre_limit parameter.\n\n        mitre_limit\n            Crops of `mitre`-style joins if the point is displaced from the buffered vertex by more than this limit.\n\n        single_sided\n            Only buffer at one side of the geometry.\n\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.buffer(\n                distance,\n                quad_segs=quad_segs,\n                cap_style=cap_style,\n                join_style=join_style,\n                mitre_limit=mitre_limit,\n                single_sided=single_sided,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def offset_curve(self, distance, quad_segs=8, join_style=\"round\", mitre_limit=5.0):\n        \"\"\"\n        Return a (Multi)LineString at a distance from the object.\n\n        For positive distance the offset will be at the left side of the input line. For a negative distance it will be at the right side. In general, this function tries to preserve the direction of the input.\n\n        Note: the behaviour regarding orientation of the resulting line depends on the GEOS version. With GEOS &lt; 3.11, the line retains the same direction for a left offset (positive distance) or has opposite direction for a right offset (negative distance), and this behaviour was documented as such in previous Shapely versions. Starting with GEOS 3.11, the function tries to preserve the orientation of the original line.\n\n        Parameters\n        ----------\n        distance\n            Specifies the circle radius in the Minkowski sum (or difference).\n\n        quad_segs\n            Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.\n\n        join_style\n            Specifies the shape of buffered line midpoints. BufferJoinStyle.round (`round`) results in rounded shapes. BufferJoinStyle.bevel (`bevel`) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (`mitre`) results in a single vertex that is beveled depending on the mitre_limit parameter.\n\n        mitre_limit\n            Crops of `mitre`-style joins if the point is displaced from the buffered vertex by more than this limit.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.offset_curve(\n                distance,\n                quad_segs=quad_segs,\n                join_style=join_style,\n                mitre_limit=mitre_limit,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def centroid(self):\n        \"\"\"\n        Compute the geometric center (center-of-mass) of a geometry.\n\n        For multipoints this is computed as the mean of the input coordinates. For multilinestrings the centroid is weighted by the length of each line segment. For multipolygons the centroid is weighted by the area of each polygon.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.centroid(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def clip_by_rect(self, xmin: float, ymin: float, xmax: float, ymax: float):\n        \"\"\"\n        Return the portion of a geometry within a rectangle.\n\n        The geometry is clipped in a fast but possibly dirty way. The output is not guaranteed to be valid. No exceptions will be raised for topological errors.\n\n        Note: empty geometries or geometries that do not overlap with the specified bounds will result in GEOMETRYCOLLECTION EMPTY.\n\n        Parameters\n        ----------\n        xmin\n            Minimum x value of the rectangle.\n\n        ymin\n            Minimum y value of the rectangle.\n\n        xmax\n            Maximum x value of the rectangle.\n\n        ymax\n            Maximum y value of the rectangle.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.clip_by_rect(\n                xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def concave_hull(self, ratio=0.0, allow_holes=False):\n        \"\"\"\n        Compute a concave geometry that encloses an input geometry.\n\n        Parameters\n        ----------\n        ratio\n            Number in the range [0, 1]. Higher numbers will include fewer vertices in the hull.\n\n        allow_holes\n            If set to True, the concave hull may have holes.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.concave_hull(ratio=ratio, allow_holes=allow_holes),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def convex_hull(self):\n        \"\"\"\n        Compute the minimum convex geometry that encloses an input geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.convex_hull(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def delaunay_triangles(self, tolerance=0.0, only_edges=False):\n        \"\"\"\n        Compute a Delaunay triangulation around the vertices of an input geometry.\n\n        The output is a geometrycollection containing polygons (default) or linestrings (see only_edges). Returns an empty geometry for input geometries that contain less than 3 vertices.\n\n        Parameters\n        ----------\n        tolerance\n            Snap input vertices together if their distance is less than this value.\n\n        only_edges\n            If set to True, the triangulation will return a collection of linestrings instead of polygons.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.delaunay_triangles(\n                tolerance=tolerance,\n                only_edges=only_edges,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def segmentize(self, max_segment_length: float):\n        \"\"\"\n        Add vertices to line segments based on maximum segment length.\n\n        Additional vertices will be added to every line segment in an input geometry so that segments are no longer than the provided maximum segment length. New vertices will evenly subdivide each segment.\n\n        Only linear components of input geometries are densified; other geometries are returned unmodified.\n\n        Parameters\n        ----------\n        max_segment_length\n            Additional vertices will be added so that all line segments are no longer than this value. Must be greater than 0.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.segmentize(max_segment_length=max_segment_length),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def envelope(self):\n        \"\"\"\n        Compute the minimum bounding box that encloses an input geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.envelope(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def extract_unique_points(self):\n        \"\"\"\n        Return all distinct vertices of an input geometry as a multipoint.\n\n        Note that only 2 dimensions of the vertices are considered when testing for equality.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.extract_unique_points(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def build_area(self):\n        \"\"\"\n        Create an areal geometry formed by the constituent linework of given geometry.\n\n        Equivalent of the PostGIS ST_BuildArea() function.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.build_area(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def make_valid(self):\n        \"\"\"\n        Repair invalid geometries.\n\n        Two methods are available:\n\n        the 'linework' algorithm tries to preserve every edge and vertex in the input. It combines all rings into a set of noded lines and then extracts valid polygons from that linework. An alternating even-odd strategy is used to assign areas as interior or exterior. A disadvantage is that for some relatively simple invalid geometries this produces rather complex results.\n        the 'structure' algorithm tries to reason from the structure of the input to find the 'correct' repair: exterior rings bound area, interior holes exclude area. It first makes all rings valid, then shells are merged and holes are subtracted from the shells to generate valid result. It assumes that holes and shells are correctly categorized in the input geometry.\n        TODO check input parameters for this function\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.make_valid(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def normalize(self):\n        \"\"\"\n        Convert Geometry to strict normal form (or canonical form).\n\n        In strict canonical form &lt;canonical-form&gt;, the coordinates, rings of a polygon and parts of multi geometries are ordered consistently. Typically useful for testing purposes (for example in combination with equals_exact).\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.normalize(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def node(self):\n        \"\"\"\n        Return the fully noded version of the linear input as MultiLineString.\n\n        Given a linear input geometry, this function returns a new MultiLineString in which no lines cross each other but only touch at and points. To obtain this, all intersections between segments are computed and added to the segments, and duplicate segments are removed.\n\n        Non-linear input (points) will result in an empty MultiLineString.\n\n        This function can for example be used to create a fully-noded linework suitable to passed as input to polygonize.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.node(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def point_on_surface(self):\n        \"\"\"\n        Return a point that intersects an input geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.point_on_surface(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def polygonize(self):\n        \"\"\"\n        Create polygons formed from the linework of a set of Geometries.\n\n        Polygonizes an array of Geometries that contain linework which represents the edges of a planar graph. Any type of Geometry may be provided as input; only the constituent lines and rings will be used to create the output polygons.\n\n        Lines or rings that when combined do not completely close a polygon will result in an empty GeometryCollection. Duplicate segments are ignored.\n\n        This function returns the polygons within a GeometryCollection. Individual Polygons can be obtained using get_geometry to get a single polygon or get_parts to get an array of polygons. MultiPolygons can be constructed from the output using shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries))).\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.polygonize(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def remove_repeated_points(self, tolerance=0.0):\n        \"\"\"\n        Return a copy of a Geometry with repeated points removed.\n\n        From the start of the coordinate sequence, each next point within the tolerance is removed.\n\n        Removing repeated points with a non-zero tolerance may result in an invalid geometry being returned.\n\n        Parameters\n        ----------\n        tolerance\n            Use 0.0 to remove only exactly repeated points.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.remove_repeated_points(tolerance=tolerance),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def reverse(self):\n        \"\"\"\n        Return a copy of a Geometry with the order of coordinates reversed.\n\n        If a Geometry is a polygon with interior rings, the interior rings are also reversed.\n\n        Points are unchanged. None is returned where Geometry is None.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.reverse(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def simplify(self, tolerance=0.0, preserve_topology=True):\n        \"\"\"\n        Return a simplified version of an input geometry.\n\n        The Douglas-Peucker algorithm is used to simplify the geometry.\n\n        Parameters\n        ----------\n        tolerance\n            The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.\n\n        preserve_topology\n            By default (True), the operation will avoid creating invalid geometries (checking for collapses, ring-intersections, etc), but this is computationally more expensive.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.simplify(\n                tolerance=tolerance, preserve_topology=preserve_topology\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def snap(self, reference=None, tolerance: float = None):\n        \"\"\"\n        Snap the vertices and segments of the geometry to vertices of the reference.\n\n        Vertices and segments of the input geometry are snapped to vertices of the reference geometry, returning a new geometry; the input geometries are not modified. The result geometry is the input geometry with the vertices and segments snapped. If no snapping occurs then the input geometry is returned unchanged. The tolerance is used to control where snapping is performed.\n\n        Where possible, this operation tries to avoid creating invalid geometries; however, it does not guarantee that output geometries will be valid. It is the responsibility of the caller to check for and handle invalid geometries.\n\n        Because too much snapping can result in invalid geometries being created, heuristics are used to determine the number and location of snapped vertices that are likely safe to snap. These heuristics may omit some potential snaps that are otherwise within the tolerance.\n\n        Parameters\n        ----------\n        reference\n            Geometry or geometries to snap to.\n\n        tolerance\n            The maximum distance between the input and reference geometries for snapping to occur. A value of 0 will snap only identical points.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `reference` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n        \"\"\"\n        if reference is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.difference(reference, tolerance),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.difference(\n                    combined.struct[1].spatial.to_shapely_array(),\n                    tolerance,\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def oriented_envelope(self):\n        \"\"\"\n        Compute the oriented envelope (minimum rotated rectangle) of the input geometry.\n\n        The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.\n\n        Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.\n\n        The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form &lt;canonical-form&gt; so the starting point is always the lower left point.\n\n        minimum_rotated_rectangle is an alias for oriented_envelope.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.oriented_envelope(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def minimum_rotated_rectangle(self):\n        \"\"\"\n        Compute the oriented envelope (minimum rotated rectangle) of the input geometry.\n\n        The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.\n\n        Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.\n\n        The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form &lt;canonical-form&gt; so the starting point is always the lower left point.\n\n        minimum_rotated_rectangle is an alias for oriented_envelope.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.minimum_rotated_rectangle(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def minimum_bounding_circle(self):\n        \"\"\"\n        Compute the minimum bounding circle that encloses an input geometry.\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.minimum_bounding_circle(),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.boundary","title":"<code>boundary()</code>","text":"<p>Return the topological boundary of a geometry.</p> <p>This function will return None for geometrycollections.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def boundary(self):\n    \"\"\"\n    Return the topological boundary of a geometry.\n\n    This function will return None for geometrycollections.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.boundary(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.buffer","title":"<code>buffer(distance, quad_segs=8, cap_style='round', join_style='round', mitre_limit=5.0, single_sided=False)</code>","text":"<p>Compute the buffer of a geometry for positive and negative buffer distance.</p> <p>The buffer of a geometry is defined as the Minkowski sum (or difference, for negative distance) of the geometry with a circle with radius equal to the absolute value of the buffer distance.</p> <p>The buffer operation always returns a polygonal result. The negative or zero-distance buffer of lines and points is always empty.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <p>Specifies the circle radius in the Minkowski sum (or difference).</p> required <code>quad_segs</code> <p>Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.</p> <code>8</code> <code>cap_style</code> <p>Specifies the shape of buffered line endings. BufferCapStyle.round (<code>round</code>) results in circular line endings (see quad_segs). Both BufferCapStyle.square (<code>square</code>) and BufferCapStyle.flat (<code>flat</code>) result in rectangular line endings, only BufferCapStyle.flat (<code>flat</code>) will end at the original vertex, while BufferCapStyle.square (<code>square</code>) involves adding the buffer width.</p> <code>'round'</code> <code>join_style</code> <p>Specifies the shape of buffered line midpoints. BufferJoinStyle.round (<code>round</code>) results in rounded shapes. BufferJoinStyle.bevel (<code>bevel</code>) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (<code>mitre</code>) results in a single vertex that is beveled depending on the mitre_limit parameter.</p> <code>'round'</code> <code>mitre_limit</code> <p>Crops of <code>mitre</code>-style joins if the point is displaced from the buffered vertex by more than this limit.</p> <code>5.0</code> <code>single_sided</code> <p>Only buffer at one side of the geometry.</p> <code>False</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def buffer(\n    self,\n    distance,\n    quad_segs=8,\n    cap_style=\"round\",\n    join_style=\"round\",\n    mitre_limit=5.0,\n    single_sided=False,\n):\n    \"\"\"\n    Compute the buffer of a geometry for positive and negative buffer distance.\n\n    The buffer of a geometry is defined as the Minkowski sum (or difference, for negative distance) of the geometry with a circle with radius equal to the absolute value of the buffer distance.\n\n    The buffer operation always returns a polygonal result. The negative or zero-distance buffer of lines and points is always empty.\n\n    Parameters\n    ----------\n    distance\n        Specifies the circle radius in the Minkowski sum (or difference).\n\n    quad_segs\n        Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.\n\n    cap_style\n        Specifies the shape of buffered line endings. BufferCapStyle.round (`round`) results in circular line endings (see quad_segs). Both BufferCapStyle.square (`square`) and BufferCapStyle.flat (`flat`) result in rectangular line endings, only BufferCapStyle.flat (`flat`) will end at the original vertex, while BufferCapStyle.square (`square`) involves adding the buffer width.\n\n    join_style\n        Specifies the shape of buffered line midpoints. BufferJoinStyle.round (`round`) results in rounded shapes. BufferJoinStyle.bevel (`bevel`) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (`mitre`) results in a single vertex that is beveled depending on the mitre_limit parameter.\n\n    mitre_limit\n        Crops of `mitre`-style joins if the point is displaced from the buffered vertex by more than this limit.\n\n    single_sided\n        Only buffer at one side of the geometry.\n\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.buffer(\n            distance,\n            quad_segs=quad_segs,\n            cap_style=cap_style,\n            join_style=join_style,\n            mitre_limit=mitre_limit,\n            single_sided=single_sided,\n        ),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.offset_curve","title":"<code>offset_curve(distance, quad_segs=8, join_style='round', mitre_limit=5.0)</code>","text":"<p>Return a (Multi)LineString at a distance from the object.</p> <p>For positive distance the offset will be at the left side of the input line. For a negative distance it will be at the right side. In general, this function tries to preserve the direction of the input.</p> <p>Note: the behaviour regarding orientation of the resulting line depends on the GEOS version. With GEOS &lt; 3.11, the line retains the same direction for a left offset (positive distance) or has opposite direction for a right offset (negative distance), and this behaviour was documented as such in previous Shapely versions. Starting with GEOS 3.11, the function tries to preserve the orientation of the original line.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <p>Specifies the circle radius in the Minkowski sum (or difference).</p> required <code>quad_segs</code> <p>Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.</p> <code>8</code> <code>join_style</code> <p>Specifies the shape of buffered line midpoints. BufferJoinStyle.round (<code>round</code>) results in rounded shapes. BufferJoinStyle.bevel (<code>bevel</code>) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (<code>mitre</code>) results in a single vertex that is beveled depending on the mitre_limit parameter.</p> <code>'round'</code> <code>mitre_limit</code> <p>Crops of <code>mitre</code>-style joins if the point is displaced from the buffered vertex by more than this limit.</p> <code>5.0</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def offset_curve(self, distance, quad_segs=8, join_style=\"round\", mitre_limit=5.0):\n    \"\"\"\n    Return a (Multi)LineString at a distance from the object.\n\n    For positive distance the offset will be at the left side of the input line. For a negative distance it will be at the right side. In general, this function tries to preserve the direction of the input.\n\n    Note: the behaviour regarding orientation of the resulting line depends on the GEOS version. With GEOS &lt; 3.11, the line retains the same direction for a left offset (positive distance) or has opposite direction for a right offset (negative distance), and this behaviour was documented as such in previous Shapely versions. Starting with GEOS 3.11, the function tries to preserve the orientation of the original line.\n\n    Parameters\n    ----------\n    distance\n        Specifies the circle radius in the Minkowski sum (or difference).\n\n    quad_segs\n        Specifies the number of linear segments in a quarter circle in the approximation of circular arcs.\n\n    join_style\n        Specifies the shape of buffered line midpoints. BufferJoinStyle.round (`round`) results in rounded shapes. BufferJoinStyle.bevel (`bevel`) results in a beveled edge that touches the original vertex. BufferJoinStyle.mitre (`mitre`) results in a single vertex that is beveled depending on the mitre_limit parameter.\n\n    mitre_limit\n        Crops of `mitre`-style joins if the point is displaced from the buffered vertex by more than this limit.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.offset_curve(\n            distance,\n            quad_segs=quad_segs,\n            join_style=join_style,\n            mitre_limit=mitre_limit,\n        ),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.centroid","title":"<code>centroid()</code>","text":"<p>Compute the geometric center (center-of-mass) of a geometry.</p> <p>For multipoints this is computed as the mean of the input coordinates. For multilinestrings the centroid is weighted by the length of each line segment. For multipolygons the centroid is weighted by the area of each polygon.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def centroid(self):\n    \"\"\"\n    Compute the geometric center (center-of-mass) of a geometry.\n\n    For multipoints this is computed as the mean of the input coordinates. For multilinestrings the centroid is weighted by the length of each line segment. For multipolygons the centroid is weighted by the area of each polygon.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.centroid(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.clip_by_rect","title":"<code>clip_by_rect(xmin, ymin, xmax, ymax)</code>","text":"<p>Return the portion of a geometry within a rectangle.</p> <p>The geometry is clipped in a fast but possibly dirty way. The output is not guaranteed to be valid. No exceptions will be raised for topological errors.</p> <p>Note: empty geometries or geometries that do not overlap with the specified bounds will result in GEOMETRYCOLLECTION EMPTY.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x value of the rectangle.</p> required <code>ymin</code> <code>float</code> <p>Minimum y value of the rectangle.</p> required <code>xmax</code> <code>float</code> <p>Maximum x value of the rectangle.</p> required <code>ymax</code> <code>float</code> <p>Maximum y value of the rectangle.</p> required Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def clip_by_rect(self, xmin: float, ymin: float, xmax: float, ymax: float):\n    \"\"\"\n    Return the portion of a geometry within a rectangle.\n\n    The geometry is clipped in a fast but possibly dirty way. The output is not guaranteed to be valid. No exceptions will be raised for topological errors.\n\n    Note: empty geometries or geometries that do not overlap with the specified bounds will result in GEOMETRYCOLLECTION EMPTY.\n\n    Parameters\n    ----------\n    xmin\n        Minimum x value of the rectangle.\n\n    ymin\n        Minimum y value of the rectangle.\n\n    xmax\n        Maximum x value of the rectangle.\n\n    ymax\n        Maximum y value of the rectangle.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.clip_by_rect(\n            xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax\n        ),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.concave_hull","title":"<code>concave_hull(ratio=0.0, allow_holes=False)</code>","text":"<p>Compute a concave geometry that encloses an input geometry.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <p>Number in the range [0, 1]. Higher numbers will include fewer vertices in the hull.</p> <code>0.0</code> <code>allow_holes</code> <p>If set to True, the concave hull may have holes.</p> <code>False</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def concave_hull(self, ratio=0.0, allow_holes=False):\n    \"\"\"\n    Compute a concave geometry that encloses an input geometry.\n\n    Parameters\n    ----------\n    ratio\n        Number in the range [0, 1]. Higher numbers will include fewer vertices in the hull.\n\n    allow_holes\n        If set to True, the concave hull may have holes.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.concave_hull(ratio=ratio, allow_holes=allow_holes),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.convex_hull","title":"<code>convex_hull()</code>","text":"<p>Compute the minimum convex geometry that encloses an input geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def convex_hull(self):\n    \"\"\"\n    Compute the minimum convex geometry that encloses an input geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.convex_hull(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.delaunay_triangles","title":"<code>delaunay_triangles(tolerance=0.0, only_edges=False)</code>","text":"<p>Compute a Delaunay triangulation around the vertices of an input geometry.</p> <p>The output is a geometrycollection containing polygons (default) or linestrings (see only_edges). Returns an empty geometry for input geometries that contain less than 3 vertices.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <p>Snap input vertices together if their distance is less than this value.</p> <code>0.0</code> <code>only_edges</code> <p>If set to True, the triangulation will return a collection of linestrings instead of polygons.</p> <code>False</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def delaunay_triangles(self, tolerance=0.0, only_edges=False):\n    \"\"\"\n    Compute a Delaunay triangulation around the vertices of an input geometry.\n\n    The output is a geometrycollection containing polygons (default) or linestrings (see only_edges). Returns an empty geometry for input geometries that contain less than 3 vertices.\n\n    Parameters\n    ----------\n    tolerance\n        Snap input vertices together if their distance is less than this value.\n\n    only_edges\n        If set to True, the triangulation will return a collection of linestrings instead of polygons.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.delaunay_triangles(\n            tolerance=tolerance,\n            only_edges=only_edges,\n        ),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.segmentize","title":"<code>segmentize(max_segment_length)</code>","text":"<p>Add vertices to line segments based on maximum segment length.</p> <p>Additional vertices will be added to every line segment in an input geometry so that segments are no longer than the provided maximum segment length. New vertices will evenly subdivide each segment.</p> <p>Only linear components of input geometries are densified; other geometries are returned unmodified.</p> <p>Parameters:</p> Name Type Description Default <code>max_segment_length</code> <code>float</code> <p>Additional vertices will be added so that all line segments are no longer than this value. Must be greater than 0.</p> required Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def segmentize(self, max_segment_length: float):\n    \"\"\"\n    Add vertices to line segments based on maximum segment length.\n\n    Additional vertices will be added to every line segment in an input geometry so that segments are no longer than the provided maximum segment length. New vertices will evenly subdivide each segment.\n\n    Only linear components of input geometries are densified; other geometries are returned unmodified.\n\n    Parameters\n    ----------\n    max_segment_length\n        Additional vertices will be added so that all line segments are no longer than this value. Must be greater than 0.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.segmentize(max_segment_length=max_segment_length),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.envelope","title":"<code>envelope()</code>","text":"<p>Compute the minimum bounding box that encloses an input geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def envelope(self):\n    \"\"\"\n    Compute the minimum bounding box that encloses an input geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.envelope(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.extract_unique_points","title":"<code>extract_unique_points()</code>","text":"<p>Return all distinct vertices of an input geometry as a multipoint.</p> <p>Note that only 2 dimensions of the vertices are considered when testing for equality.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def extract_unique_points(self):\n    \"\"\"\n    Return all distinct vertices of an input geometry as a multipoint.\n\n    Note that only 2 dimensions of the vertices are considered when testing for equality.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.extract_unique_points(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.build_area","title":"<code>build_area()</code>","text":"<p>Create an areal geometry formed by the constituent linework of given geometry.</p> <p>Equivalent of the PostGIS ST_BuildArea() function.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def build_area(self):\n    \"\"\"\n    Create an areal geometry formed by the constituent linework of given geometry.\n\n    Equivalent of the PostGIS ST_BuildArea() function.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.build_area(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.make_valid","title":"<code>make_valid()</code>","text":"<p>Repair invalid geometries.</p> <p>Two methods are available:</p> <p>the 'linework' algorithm tries to preserve every edge and vertex in the input. It combines all rings into a set of noded lines and then extracts valid polygons from that linework. An alternating even-odd strategy is used to assign areas as interior or exterior. A disadvantage is that for some relatively simple invalid geometries this produces rather complex results. the 'structure' algorithm tries to reason from the structure of the input to find the 'correct' repair: exterior rings bound area, interior holes exclude area. It first makes all rings valid, then shells are merged and holes are subtracted from the shells to generate valid result. It assumes that holes and shells are correctly categorized in the input geometry. TODO check input parameters for this function</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def make_valid(self):\n    \"\"\"\n    Repair invalid geometries.\n\n    Two methods are available:\n\n    the 'linework' algorithm tries to preserve every edge and vertex in the input. It combines all rings into a set of noded lines and then extracts valid polygons from that linework. An alternating even-odd strategy is used to assign areas as interior or exterior. A disadvantage is that for some relatively simple invalid geometries this produces rather complex results.\n    the 'structure' algorithm tries to reason from the structure of the input to find the 'correct' repair: exterior rings bound area, interior holes exclude area. It first makes all rings valid, then shells are merged and holes are subtracted from the shells to generate valid result. It assumes that holes and shells are correctly categorized in the input geometry.\n    TODO check input parameters for this function\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.make_valid(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.normalize","title":"<code>normalize()</code>","text":"<p>Convert Geometry to strict normal form (or canonical form).</p> <p>In strict canonical form , the coordinates, rings of a polygon and parts of multi geometries are ordered consistently. Typically useful for testing purposes (for example in combination with equals_exact). Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Convert Geometry to strict normal form (or canonical form).\n\n    In strict canonical form &lt;canonical-form&gt;, the coordinates, rings of a polygon and parts of multi geometries are ordered consistently. Typically useful for testing purposes (for example in combination with equals_exact).\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.normalize(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.node","title":"<code>node()</code>","text":"<p>Return the fully noded version of the linear input as MultiLineString.</p> <p>Given a linear input geometry, this function returns a new MultiLineString in which no lines cross each other but only touch at and points. To obtain this, all intersections between segments are computed and added to the segments, and duplicate segments are removed.</p> <p>Non-linear input (points) will result in an empty MultiLineString.</p> <p>This function can for example be used to create a fully-noded linework suitable to passed as input to polygonize.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def node(self):\n    \"\"\"\n    Return the fully noded version of the linear input as MultiLineString.\n\n    Given a linear input geometry, this function returns a new MultiLineString in which no lines cross each other but only touch at and points. To obtain this, all intersections between segments are computed and added to the segments, and duplicate segments are removed.\n\n    Non-linear input (points) will result in an empty MultiLineString.\n\n    This function can for example be used to create a fully-noded linework suitable to passed as input to polygonize.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.node(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.point_on_surface","title":"<code>point_on_surface()</code>","text":"<p>Return a point that intersects an input geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def point_on_surface(self):\n    \"\"\"\n    Return a point that intersects an input geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.point_on_surface(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.polygonize","title":"<code>polygonize()</code>","text":"<p>Create polygons formed from the linework of a set of Geometries.</p> <p>Polygonizes an array of Geometries that contain linework which represents the edges of a planar graph. Any type of Geometry may be provided as input; only the constituent lines and rings will be used to create the output polygons.</p> <p>Lines or rings that when combined do not completely close a polygon will result in an empty GeometryCollection. Duplicate segments are ignored.</p> <p>This function returns the polygons within a GeometryCollection. Individual Polygons can be obtained using get_geometry to get a single polygon or get_parts to get an array of polygons. MultiPolygons can be constructed from the output using shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries))).</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def polygonize(self):\n    \"\"\"\n    Create polygons formed from the linework of a set of Geometries.\n\n    Polygonizes an array of Geometries that contain linework which represents the edges of a planar graph. Any type of Geometry may be provided as input; only the constituent lines and rings will be used to create the output polygons.\n\n    Lines or rings that when combined do not completely close a polygon will result in an empty GeometryCollection. Duplicate segments are ignored.\n\n    This function returns the polygons within a GeometryCollection. Individual Polygons can be obtained using get_geometry to get a single polygon or get_parts to get an array of polygons. MultiPolygons can be constructed from the output using shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries))).\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.polygonize(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.remove_repeated_points","title":"<code>remove_repeated_points(tolerance=0.0)</code>","text":"<p>Return a copy of a Geometry with repeated points removed.</p> <p>From the start of the coordinate sequence, each next point within the tolerance is removed.</p> <p>Removing repeated points with a non-zero tolerance may result in an invalid geometry being returned.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <p>Use 0.0 to remove only exactly repeated points.</p> <code>0.0</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def remove_repeated_points(self, tolerance=0.0):\n    \"\"\"\n    Return a copy of a Geometry with repeated points removed.\n\n    From the start of the coordinate sequence, each next point within the tolerance is removed.\n\n    Removing repeated points with a non-zero tolerance may result in an invalid geometry being returned.\n\n    Parameters\n    ----------\n    tolerance\n        Use 0.0 to remove only exactly repeated points.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.remove_repeated_points(tolerance=tolerance),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.reverse","title":"<code>reverse()</code>","text":"<p>Return a copy of a Geometry with the order of coordinates reversed.</p> <p>If a Geometry is a polygon with interior rings, the interior rings are also reversed.</p> <p>Points are unchanged. None is returned where Geometry is None.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def reverse(self):\n    \"\"\"\n    Return a copy of a Geometry with the order of coordinates reversed.\n\n    If a Geometry is a polygon with interior rings, the interior rings are also reversed.\n\n    Points are unchanged. None is returned where Geometry is None.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.reverse(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.simplify","title":"<code>simplify(tolerance=0.0, preserve_topology=True)</code>","text":"<p>Return a simplified version of an input geometry.</p> <p>The Douglas-Peucker algorithm is used to simplify the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>0.0</code> <code>preserve_topology</code> <p>By default (True), the operation will avoid creating invalid geometries (checking for collapses, ring-intersections, etc), but this is computationally more expensive.</p> <code>True</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def simplify(self, tolerance=0.0, preserve_topology=True):\n    \"\"\"\n    Return a simplified version of an input geometry.\n\n    The Douglas-Peucker algorithm is used to simplify the geometry.\n\n    Parameters\n    ----------\n    tolerance\n        The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.\n\n    preserve_topology\n        By default (True), the operation will avoid creating invalid geometries (checking for collapses, ring-intersections, etc), but this is computationally more expensive.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.simplify(\n            tolerance=tolerance, preserve_topology=preserve_topology\n        ),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.snap","title":"<code>snap(reference=None, tolerance=None)</code>","text":"<p>Snap the vertices and segments of the geometry to vertices of the reference.</p> <p>Vertices and segments of the input geometry are snapped to vertices of the reference geometry, returning a new geometry; the input geometries are not modified. The result geometry is the input geometry with the vertices and segments snapped. If no snapping occurs then the input geometry is returned unchanged. The tolerance is used to control where snapping is performed.</p> <p>Where possible, this operation tries to avoid creating invalid geometries; however, it does not guarantee that output geometries will be valid. It is the responsibility of the caller to check for and handle invalid geometries.</p> <p>Because too much snapping can result in invalid geometries being created, heuristics are used to determine the number and location of snapped vertices that are likely safe to snap. These heuristics may omit some potential snaps that are otherwise within the tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <p>Geometry or geometries to snap to.</p> <code>None</code> <code>tolerance</code> <code>float</code> <p>The maximum distance between the input and reference geometries for snapping to occur. A value of 0 will snap only identical points.</p> <code>None</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>reference</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def snap(self, reference=None, tolerance: float = None):\n    \"\"\"\n    Snap the vertices and segments of the geometry to vertices of the reference.\n\n    Vertices and segments of the input geometry are snapped to vertices of the reference geometry, returning a new geometry; the input geometries are not modified. The result geometry is the input geometry with the vertices and segments snapped. If no snapping occurs then the input geometry is returned unchanged. The tolerance is used to control where snapping is performed.\n\n    Where possible, this operation tries to avoid creating invalid geometries; however, it does not guarantee that output geometries will be valid. It is the responsibility of the caller to check for and handle invalid geometries.\n\n    Because too much snapping can result in invalid geometries being created, heuristics are used to determine the number and location of snapped vertices that are likely safe to snap. These heuristics may omit some potential snaps that are otherwise within the tolerance.\n\n    Parameters\n    ----------\n    reference\n        Geometry or geometries to snap to.\n\n    tolerance\n        The maximum distance between the input and reference geometries for snapping to occur. A value of 0 will snap only identical points.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `reference` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n    \"\"\"\n    if reference is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.difference(reference, tolerance),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.difference(\n                combined.struct[1].spatial.to_shapely_array(),\n                tolerance,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.oriented_envelope","title":"<code>oriented_envelope()</code>","text":"<p>Compute the oriented envelope (minimum rotated rectangle) of the input geometry.</p> <p>The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.</p> <p>Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.</p> <p>The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form  so the starting point is always the lower left point. <p>minimum_rotated_rectangle is an alias for oriented_envelope.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def oriented_envelope(self):\n    \"\"\"\n    Compute the oriented envelope (minimum rotated rectangle) of the input geometry.\n\n    The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.\n\n    Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.\n\n    The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form &lt;canonical-form&gt; so the starting point is always the lower left point.\n\n    minimum_rotated_rectangle is an alias for oriented_envelope.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.oriented_envelope(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.minimum_rotated_rectangle","title":"<code>minimum_rotated_rectangle()</code>","text":"<p>Compute the oriented envelope (minimum rotated rectangle) of the input geometry.</p> <p>The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.</p> <p>Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.</p> <p>The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form  so the starting point is always the lower left point. <p>minimum_rotated_rectangle is an alias for oriented_envelope.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def minimum_rotated_rectangle(self):\n    \"\"\"\n    Compute the oriented envelope (minimum rotated rectangle) of the input geometry.\n\n    The oriented envelope encloses an input geometry, such that the resulting rectangle has minimum area.\n\n    Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.\n\n    The starting point of the rectangle is not fixed. You can use ~shapely.normalize to reorganize the rectangle to strict canonical form &lt;canonical-form&gt; so the starting point is always the lower left point.\n\n    minimum_rotated_rectangle is an alias for oriented_envelope.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.minimum_rotated_rectangle(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.ConstructiveOperations.minimum_bounding_circle","title":"<code>minimum_bounding_circle()</code>","text":"<p>Compute the minimum bounding circle that encloses an input geometry.</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def minimum_bounding_circle(self):\n    \"\"\"\n    Compute the minimum bounding circle that encloses an input geometry.\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.minimum_bounding_circle(),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.LinestringOperations","title":"<code>LinestringOperations</code>","text":"<p>Expressions derived from shapely's Constructive Operations</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>class LinestringOperations:\n    \"\"\"Expressions derived from shapely's [Constructive Operations](https://shapely.readthedocs.io/en/stable/linear.html)\"\"\"\n\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def line_interpolate_point(self, distance=None, normalized=False):\n        \"\"\"\n        Return a point interpolated at given distance on a line.\n\n        Parameters\n        ----------\n        distance\n            Negative values measure distance from the end of the line. Out-of-range values will be clipped to the line endings.\n\n        normalized\n            If True, the distance is a fraction of the total line length instead of the absolute distance.\n\n        Note\n        ----\n        **To compute between the values in the series and a scalar distance** provide the distance to the `distance` parameter.\n\n        **To compute between the geometries and a column in the frame for the distance** wrap the geometry and other column of distances into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n        \"\"\"\n        if distance is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.line_interpolate_point(\n                    distance=distance, normalized=normalized\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct geometry and number.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.line_interpolate_point(\n                    combined.struct[1],\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def line_locate_point(self, other, normalized=False):\n        \"\"\"\n        Return the distance to the line origin of given point.\n\n        If given point does not intersect with the line, the point will first be projected onto the line after which the distance is taken.\n\n        Parameters\n        ----------\n        other\n            Point or points to calculate the distance from.\n\n        normalized\n             If True, the distance is a fraction of the total line length instead of the absolute distance.\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.line_locate_point(other, normalized=normalized),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.line_locate_point(\n                    combined.struct[1].spatial.to_shapely_array(),\n                    normalized=normalized,\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n\n    def line_merge(self, directed=False):\n        \"\"\"\n        Return (Multi)LineStrings formed by combining the lines in a MultiLineString.\n\n        Lines are joined together at their endpoints in case two lines are intersecting. Lines are not joined when 3 or more lines are intersecting at the endpoints. Line elements that cannot be joined are kept as is in the resulting MultiLineString.\n\n        The direction of each merged LineString will be that of the majority of the LineStrings from which it was derived. Except if directed=True is specified, then the operation will not change the order of points within lines and so only lines which can be joined with no change in direction are merged.\n\n        Parameters\n        ----------\n        directed\n            Only combine lines if possible without changing point order. Requires GEOS &gt;= 3.11.0\n        \"\"\"\n        return self._expr.map_batches(\n            lambda s: s.spatial.line_merge(directed=directed),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n\n    def shortest_line(self, other):\n        \"\"\"\n        Return the shortest line between two geometries.\n\n        The resulting line consists of two points, representing the nearest points between the geometry pair. The line always starts in the first geometry a and ends in the second geometry b. The endpoints of the line will not necessarily be existing vertices of the input geometries a and b, but can also be a point along a line segment.\n\n        Parameters\n        ----------\n        other\n            A shapely geometry object\n\n        Two geometry input\n        ------------------\n        **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n        **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n        See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n        \"\"\"\n        if other is not None:\n            return self._expr.map_batches(\n                lambda s: s.spatial.shortest_line(other),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n        else:\n            # expect struct with two geometries.\n            return self._expr.map_batches(\n                lambda combined: combined.struct[0].spatial.shortest_line(\n                    combined.struct[1].spatial.to_shapely_array(),\n                ),\n                return_dtype=spatial_series_dtype,\n                is_elementwise=True,\n            )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.LinestringOperations.line_interpolate_point","title":"<code>line_interpolate_point(distance=None, normalized=False)</code>","text":"<p>Return a point interpolated at given distance on a line.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <p>Negative values measure distance from the end of the line. Out-of-range values will be clipped to the line endings.</p> <code>None</code> <code>normalized</code> <p>If True, the distance is a fraction of the total line length instead of the absolute distance.</p> <code>False</code> Note <p>To compute between the values in the series and a scalar distance provide the distance to the <code>distance</code> parameter.</p> <p>To compute between the geometries and a column in the frame for the distance wrap the geometry and other column of distances into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def line_interpolate_point(self, distance=None, normalized=False):\n    \"\"\"\n    Return a point interpolated at given distance on a line.\n\n    Parameters\n    ----------\n    distance\n        Negative values measure distance from the end of the line. Out-of-range values will be clipped to the line endings.\n\n    normalized\n        If True, the distance is a fraction of the total line length instead of the absolute distance.\n\n    Note\n    ----\n    **To compute between the values in the series and a scalar distance** provide the distance to the `distance` parameter.\n\n    **To compute between the geometries and a column in the frame for the distance** wrap the geometry and other column of distances into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n    \"\"\"\n    if distance is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.line_interpolate_point(\n                distance=distance, normalized=normalized\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct geometry and number.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.line_interpolate_point(\n                combined.struct[1],\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.LinestringOperations.line_locate_point","title":"<code>line_locate_point(other, normalized=False)</code>","text":"<p>Return the distance to the line origin of given point.</p> <p>If given point does not intersect with the line, the point will first be projected onto the line after which the distance is taken.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Point or points to calculate the distance from.</p> required <code>normalized</code> <p>If True, the distance is a fraction of the total line length instead of the absolute distance.</p> <code>False</code> Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def line_locate_point(self, other, normalized=False):\n    \"\"\"\n    Return the distance to the line origin of given point.\n\n    If given point does not intersect with the line, the point will first be projected onto the line after which the distance is taken.\n\n    Parameters\n    ----------\n    other\n        Point or points to calculate the distance from.\n\n    normalized\n         If True, the distance is a fraction of the total line length instead of the absolute distance.\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.line_locate_point(other, normalized=normalized),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.line_locate_point(\n                combined.struct[1].spatial.to_shapely_array(),\n                normalized=normalized,\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.LinestringOperations.line_merge","title":"<code>line_merge(directed=False)</code>","text":"<p>Return (Multi)LineStrings formed by combining the lines in a MultiLineString.</p> <p>Lines are joined together at their endpoints in case two lines are intersecting. Lines are not joined when 3 or more lines are intersecting at the endpoints. Line elements that cannot be joined are kept as is in the resulting MultiLineString.</p> <p>The direction of each merged LineString will be that of the majority of the LineStrings from which it was derived. Except if directed=True is specified, then the operation will not change the order of points within lines and so only lines which can be joined with no change in direction are merged.</p> <p>Parameters:</p> Name Type Description Default <code>directed</code> <p>Only combine lines if possible without changing point order. Requires GEOS &gt;= 3.11.0</p> <code>False</code> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def line_merge(self, directed=False):\n    \"\"\"\n    Return (Multi)LineStrings formed by combining the lines in a MultiLineString.\n\n    Lines are joined together at their endpoints in case two lines are intersecting. Lines are not joined when 3 or more lines are intersecting at the endpoints. Line elements that cannot be joined are kept as is in the resulting MultiLineString.\n\n    The direction of each merged LineString will be that of the majority of the LineStrings from which it was derived. Except if directed=True is specified, then the operation will not change the order of points within lines and so only lines which can be joined with no change in direction are merged.\n\n    Parameters\n    ----------\n    directed\n        Only combine lines if possible without changing point order. Requires GEOS &gt;= 3.11.0\n    \"\"\"\n    return self._expr.map_batches(\n        lambda s: s.spatial.line_merge(directed=directed),\n        return_dtype=spatial_series_dtype,\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.LinestringOperations.shortest_line","title":"<code>shortest_line(other)</code>","text":"<p>Return the shortest line between two geometries.</p> <p>The resulting line consists of two points, representing the nearest points between the geometry pair. The line always starts in the first geometry a and ends in the second geometry b. The endpoints of the line will not necessarily be existing vertices of the input geometries a and b, but can also be a point along a line segment.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>A shapely geometry object</p> required Two geometry input <p>To compute between the values in the series and a scalar geometry provide the other geometry to the <code>other</code> parameter.</p> <p>To compute between two geometries in different columns of the frame wrap both geometries into a struct before using the expression. See Spatial expressions which use more than geometry</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def shortest_line(self, other):\n    \"\"\"\n    Return the shortest line between two geometries.\n\n    The resulting line consists of two points, representing the nearest points between the geometry pair. The line always starts in the first geometry a and ends in the second geometry b. The endpoints of the line will not necessarily be existing vertices of the input geometries a and b, but can also be a point along a line segment.\n\n    Parameters\n    ----------\n    other\n        A shapely geometry object\n\n    Two geometry input\n    ------------------\n    **To compute between the values in the series and a scalar geometry** provide the other geometry to the `other` parameter.\n\n    **To compute between two geometries in different columns of the frame** wrap both geometries into a struct before using the expression.\n    See [Spatial expressions which use more than geometry](index.md#spatial-expressions-which-use-more-than-geometry)\n\n    \"\"\"\n    if other is not None:\n        return self._expr.map_batches(\n            lambda s: s.spatial.shortest_line(other),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n    else:\n        # expect struct with two geometries.\n        return self._expr.map_batches(\n            lambda combined: combined.struct[0].spatial.shortest_line(\n                combined.struct[1].spatial.to_shapely_array(),\n            ),\n            return_dtype=spatial_series_dtype,\n            is_elementwise=True,\n        )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SpatialExpr","title":"<code>SpatialExpr</code>","text":"<p>               Bases: <code>GeometryProperties</code>, <code>Measurement</code>, <code>Predicates</code>, <code>SetOperations</code>, <code>ConstructiveOperations</code>, <code>LinestringOperations</code></p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>@pl.api.register_expr_namespace(\"spatial\")\nclass SpatialExpr(\n    GeometryProperties,\n    Measurement,\n    Predicates,\n    SetOperations,\n    ConstructiveOperations,\n    LinestringOperations,\n):\n    def __init__(self, expr: pl.Expr) -&gt; None:\n        self._expr = expr\n\n    def to_shapely_array(self) -&gt; pl.Expr:\n        return self._expr.map_batches(\n            lambda s: s.spatial.to_shapely_array(),\n            return_dtype=pl.Object,\n            is_elementwise=True,\n        )\n\n    def reproject(self, crs_to):\n        \"\"\"\n        Reproject data to a different CRS.\n\n        Parameters\n        ----------\n        crs_to\n            The coordinate reference system to reproject the data into.\n        \"\"\"\n        # using is_elementwise=True causes issues,\n        # assuming something with the LRU caching or something like that.\n        return self._expr.map_batches(\n            lambda s: s.spatial.reproject(crs_to),\n            return_dtype=spatial_series_dtype,\n        )\n\n    def min_max(self):\n        \"\"\"\n        Normalizes a value in a column to be 0-1\n        \"\"\"\n        return (self._expr - self._expr.min()) / (self._expr.max() - self._expr.min())\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SpatialExpr.reproject","title":"<code>reproject(crs_to)</code>","text":"<p>Reproject data to a different CRS.</p> <p>Parameters:</p> Name Type Description Default <code>crs_to</code> <p>The coordinate reference system to reproject the data into.</p> required Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def reproject(self, crs_to):\n    \"\"\"\n    Reproject data to a different CRS.\n\n    Parameters\n    ----------\n    crs_to\n        The coordinate reference system to reproject the data into.\n    \"\"\"\n    # using is_elementwise=True causes issues,\n    # assuming something with the LRU caching or something like that.\n    return self._expr.map_batches(\n        lambda s: s.spatial.reproject(crs_to),\n        return_dtype=spatial_series_dtype,\n    )\n</code></pre>"},{"location":"SpatialExpr/#spatial_polars.spatialexpr.SpatialExpr.min_max","title":"<code>min_max()</code>","text":"<p>Normalizes a value in a column to be 0-1</p> Source code in <code>src\\spatial_polars\\spatialexpr.py</code> <pre><code>def min_max(self):\n    \"\"\"\n    Normalizes a value in a column to be 0-1\n    \"\"\"\n    return (self._expr - self._expr.min()) / (self._expr.max() - self._expr.min())\n</code></pre>"},{"location":"SpatialFrame/","title":"SpatialFrame","text":""},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame","title":"<code>SpatialFrame</code>","text":"Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>@pl.api.register_dataframe_namespace(\"spatial\")\nclass SpatialFrame:\n    def __init__(self, df: pl.DataFrame) -&gt; None:\n        self._df = df\n\n    def write_spatial(\n        self,\n        path: str | BytesIO,\n        layer: Optional[str] = None,\n        driver: Optional[str] = None,\n        geometry_name: str = \"geometry\",\n        geometry_type: Optional[str] = None,\n        crs: Optional[str] = None,\n        encoding: Optional[str] = None,\n        append: bool = False,\n        dataset_metadata: Optional[dict] = None,\n        layer_metadata: Optional[dict] = None,\n        metadata: Optional[dict] = None,\n        dataset_options: Optional[dict] = None,\n        layer_options: Optional[dict] = None,\n    ) -&gt; None:\n        r\"\"\"\n        Writes the dataframe to a format supported by [pyogrio][].\n\n        Parameters\n        ----------\n\n        path\n            path to output file on writeable file system or an io.BytesIO object to allow writing to memory NOTE: support for writing to memory is limited to specific drivers.\n\n        layer\n            layer name to create. If writing to memory and layer name is not provided, it layer name will be set to a UUID4 value.\n\n        driver\n            The OGR format driver used to write the vector file. By default attempts to infer driver from path. Must be provided to write to memory.\n\n        geometry_name\n            The name of the column in the dataframe that will be written as the geometry field.\n\n        geometry_type\n            The geometry type of the written layer. Currently, this needs to be specified explicitly when creating a new layer with geometries. Possible values are: \u201cUnknown\u201d, \u201cPoint\u201d, \u201cLineString\u201d, \u201cPolygon\u201d, \u201cMultiPoint\u201d, \u201cMultiLineString\u201d, \u201cMultiPolygon\u201d \u201cGeometryCollection\u201d, \u201cPoint Z\u201d, \u201cLineString Z\u201d, \u201cPolygon Z\u201d, \u201cMultiPoint Z\u201d, \u201cMultiLineString Z\u201d, \u201cMultiPolygon Z\u201d or \u201cGeometryCollection Z\u201d.\n\n            This parameter does not modify the geometry, but it will try to force the layer type of the output file to this value. Use this parameter with caution because using a wrong layer geometry type may result in errors when writing the file, may be ignored by the driver, or may result in invalid files.\n\n        crs\n            WKT-encoded CRS of the geometries to be written.    If left as None, the CRS from the geometry column's struct will be used.\n\n        encoding\n            Only used for the .dbf file of ESRI Shapefiles. If not specified, uses the default locale.\n\n        append\n            If True, the data source specified by path already exists, and the driver supports appending to an existing data source, will cause the data to be appended to the existing records in the data source. Not supported for writing to in-memory files. NOTE: append support is limited to specific drivers and GDAL versions.\n\n        dataset_metadata\n            Metadata to be stored at the dataset level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.\n\n        layer_metadata\n            Metadata to be stored at the layer level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.\n\n        metadata\n            alias of layer_metadata.\n\n        dataset_options\n            Dataset creation options (format specific) passed to OGR. Specify as a key-value dictionary.\n\n        layer_options\n            Layer creation options (format specific) passed to OGR. Specify as a key-value dictionary.\n\n        Examples\n        --------\n\n        **Writing a shapefile**\n        &gt;&gt;&gt; from spatial_polars import read_spatial\n        &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n        &gt;&gt;&gt; df = read_spatial(my_shapefile)\n        &gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\data\\roads_2.shp\")\n\n        **Writing a geopackage**\n        &gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\random_data\\my_geopackage.gpkg\", layer=\"roads\")\n\n        \"\"\"\n        geometries_wkb = (\n            self._df[geometry_name].struct.field(\"wkb_geometry\").to_numpy().copy()\n        )\n        pa_table = (\n            self._df.drop(geometry_name)\n            .with_columns(pl.Series(\"geometry\", geometries_wkb, dtype=pl.Binary))\n            .to_arrow()\n        )\n\n        if any([geometry_type is None, crs is None]):\n            geom_wkb = geometries_wkb[0]\n            geom = shapely.from_wkb(geom_wkb)\n            if geometry_type is None:\n                geometry_type = geom.geom_type\n            if crs is None:\n                crs = pyproj.CRS(self._df[geometry_name].struct.field(\"crs\")[0]).to_wkt(\n                    version=\"WKT1_GDAL\"\n                )\n\n        pyogrio.write_arrow(\n            pa_table,\n            path=path,\n            layer=layer,\n            driver=driver,\n            geometry_name=geometry_name,\n            geometry_type=geometry_type,\n            crs=crs,\n            encoding=encoding,\n            append=append,\n            dataset_metadata=dataset_metadata,\n            layer_metadata=layer_metadata,\n            metadata=metadata,\n            dataset_options=dataset_options,\n            layer_options=layer_options,\n        )\n\n    def write_geoparquet(\n        self,\n        path: str,\n        geometry_name: str = \"geometry\",\n        crs: Optional[str] = None,\n        write_bbox: bool = False,\n        write_geometry_types: Optional[bool] = None,\n    ):\n        r\"\"\"\n        Writes the dataframe to a geoparquet file.\n\n        Parameters\n        ----------\n\n        path\n            path to output file on writeable file system.\n\n        geometry_name\n            The name of the column in the dataframe that will be written as the geometry field.\n\n        crs\n            WKT-encoded CRS of the geometries to be written.  If left as None, the CRS from the geometry column's struct will be used.\n\n        write_bbox\n            May be computationally expensive for large input.\n\n        write_geometry_types\n            May be computationally expensive for large input.\n\n        Note\n        ----\n        Any rows with null geometries will be discarded.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from spatial_polars import read_spatial\n        &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n        &gt;&gt;&gt; df = read_spatial(my_shapefile)\n        &gt;&gt;&gt; df.spatial.write_geoparquet(r\"c:\\data\\roads.parquet\")\n\n        \"\"\"\n        geoarrow_table = self.to_geoarrow(geometry_name)\n        gaio.write_geoparquet_table(\n            geoarrow_table,\n            path,\n            write_bbox=write_bbox,\n            write_geometry_types=write_geometry_types,\n        )\n\n    def to_geoarrow(\n        self,\n        geometry_name: str = \"geometry\",\n    ):\n        r\"\"\"\n        Converts the dataframe to geoarrow table.\n\n        Parameters\n        ----------\n\n        geometry_name\n            The name of the column in the dataframe that will be written as the geometry field.\n\n        Note\n        ----\n        Any rows with null geometries will be discarded.\n\n\n        Examples\n        --------\n        &gt;&gt;&gt; from spatial_polars import read_spatial\n        &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n        &gt;&gt;&gt; df = read_spatial(my_shapefile)\n        &gt;&gt;&gt; df.spatial.to_geoarrow()\n        pyarrow.Table\n        osm_id: large_string\n        code: int32\n        fclass: large_string\n        name: large_string\n        ref: large_string\n        oneway: large_string\n        maxspeed: int32\n        layer: int64\n        bridge: large_string\n        tunnel: large_string\n        geometry: extension&lt;geoarrow.linestring&lt;LinestringType&gt;&gt;\n        osm_id: [[\"4265057\",\"4265058\",\"4267607\",\"4271616\",\"4275365\",...,\"4372351\",\"4372353\",\"4374903\",\"4374905\",\"4374906\"],[\"4375793\",\"4376011\",\"4377106\",\"4377123\",\"4377209\",...,\"4493766\",\"4493790\",\"4500373\",\"4500375\",\"4516633\"],...,[\"1370367863\",\"1370367864\",\"1370367868\",\"1370367873\",\"1370367874\",...,\"1370383552\",\"1370383553\",\"1370383554\",\"1370383556\",\"1370383557\"],[\"1370383558\",\"1370383559\",\"1370383560\",\"1370383561\",\"1370383562\",...,\"1370383592\",\"1370383593\",\"1370383594\",\"1370383595\",\"1370398885\"]]\n        code: [[5114,5114,5114,5115,5122,...,5122,5152,5141,5122,5141],[5111,5111,5131,5131,5115,...,5114,5111,5152,5152,5111],...,[5153,5153,5153,5153,5153,...,5153,5153,5153,5141,5141],[5141,5153,5153,5153,5153,...,5153,5153,5153,5153,5141]]\n        fclass: [[\"secondary\",\"secondary\",\"secondary\",\"tertiary\",\"residential\",...,\"residential\",\"cycleway\",\"service\",\"residential\",\"service\"],[\"motorway\",\"motorway\",\"motorway_link\",\"motorway_link\",\"tertiary\",...,\"secondary\",\"motorway\",\"cycleway\",\"cycleway\",\"motorway\"],...,[\"footway\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"service\",\"service\"],[\"service\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"footway\",\"service\"]]\n        name: [[\"55th Street\",\"Fairview Avenue\",\"31st Street\",\"59th Street\",\"61st Street\",...,\"Fairmount Avenue\",null,null,\"Mochel Drive\",null],[\"Kennedy Expressway\",\"Kennedy Expressway\",null,null,\"59th Street\",...,\"Midwest Road\",\"Ronald Reagan Memorial Tollway\",\"Main Trail\",null,\"Borman Expressway\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\n        ref: [[null,null,null,null,null,...,null,null,null,null,null],[\"I 190\",\"I 190\",null,null,null,...,null,\"I 88;IL 110\",null,null,\"I 80;I 94;US 6\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\n        oneway: [[\"F\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"B\",...,\"B\",\"F\",\"B\",\"B\",\"F\"],...,[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"]]\n        maxspeed: [[0,0,72,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,96,0,0,88],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\n        layer: [[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\n        bridge: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\n        tunnel: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\n\n        \"\"\"\n        # create pyarrow table from the dataframe without the geometry\n\n        no_null_geoms_df = self._df.filter(\n            c(geometry_name).struct.field(\"wkb_geometry\").is_not_null()\n        )\n        if len(no_null_geoms_df) != len(self._df):\n            Warning(\n                \"Dataframe contains null goemetries, rows with null geometries will be discarded.\"\n            )\n\n        pa_table = self._df.drop(geometry_name).to_arrow()\n\n        crs = pyproj.CRS(self._df[geometry_name].struct.field(\"crs\")[0]).to_wkt(\n            version=\"WKT1_GDAL\"\n        )\n\n        # create geoarrow array with crs from the geometry\n        geometries_wkb = (\n            self._df[geometry_name].struct.field(\"wkb_geometry\").to_numpy().copy()\n        )\n        geoarrow_geom_array = ga.with_crs(ga.as_geoarrow(geometries_wkb), crs)\n\n        # add the geoarrow geometry to the arrow table\n        pa_table = pa_table.append_column(geometry_name, geoarrow_geom_array)\n        return pa_table\n\n    def join(\n        self,\n        other: pl.DataFrame,\n        how: Literal[\"left\", \"right\", \"full\", \"inner\", \"semi\", \"anti\"] = \"inner\",\n        predicate: Literal[\n            \"intersects\",\n            \"within\",\n            \"contains\",\n            \"overlaps\",\n            \"crosses\",\n            \"touches\",\n            \"covers\",\n            \"covered_by\",\n            \"contains_properly\",\n            \"dwithin\",\n        ] = \"intersects\",\n        distance: Optional[float] = None,\n        on: str = \"geometry\",\n        left_on: Optional[str] = None,\n        right_on: Optional[str] = None,\n        suffix: str = \"_right\",\n        maintain_order: Literal[\n            \"none\", \"left\", \"right\", \"left_right\", \"right_left\"\n        ] = \"none\",\n    ) -&gt; pl.DataFrame:\n        r\"\"\"\n        Joins two SpatialFrames based on a spatial predicate.\n\n        Parameters\n        ----------\n        other\n            SpatialFrame to join with.\n\n        how\n            Join strategy.\n\n            * *inner*\n                Returns rows that have matching values in both tables\n            * *left*\n                Returns all rows from the left table, and the matched rows from the\n                right table\n            * *right*\n                Returns all rows from the right table, and the matched rows from the\n                left table\n            * *full*\n                Returns all rows when there is a match in either left or right table\n            * *semi*\n                Returns rows from the left table that have a match in the right table.\n            * *anti*\n                Returns rows from the left table that have no match in the right table.\n\n        predicate\n            The predicate to use for testing geometries from the tree that are within the input geometry's bounding box.\n            * *intersects*\n                Joins rows in the left frame to the right frame if they share any portion of space.\n\n            * *within*\n                Joins rows in the left frame to the right if they are completely inside a geometry from the right frame.\n\n            * *contains*\n                Joins rows in the left frame to the right if the geometry from the right frame is completely inside the geometry from the left frame\n\n            * *overlaps*\n                Joins rows in the left frame to the right if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves.\n\n            * *crosses*\n                Joins rows in the left frame to the right if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension for the geomtries.\n\n            * *touches*\n                Joins rows in the left frame to the right if they only share points on their boundaries.\n\n            * *covers*\n                Joins rows in the left frame to the right if no point of the right geometry is outside of the left geometry.\n\n\n            * *covered_by*\n                Joins rows in the left frame to the right if no point of the left geometry is outside of the right geometry.\n\n\n            * *contains_properly*\n                Joins rows in the left frame to the right if the geometry from the right is completely inside the geometry from the left with no common boundary points.\n\n\n            * *dwithin*\n                Joins rows in the left frame to the right if they are within the given `distance` of one another.\n\n        distance\n            Distances around each input geometry to join for the `dwithin` predicate. Required if predicate=`dwithin`.\n\n        on\n            Name of the geometry columns in both SpatialFrames.\n\n        left_on\n            Name of the geometry column in the left SpatialFrame for the spatial join.\n\n        right_on\n            Name of the geometry column in the right SpatialFrame for the spatial join.\n\n        suffix\n            Suffix to append to columns with a duplicate name.\n\n        maintain_order\n            Which DataFrame row order to preserve, if any.\n            Do not rely on any observed ordering without explicitly\n            setting this parameter, as your code may break in a future release.\n            Not specifying any ordering can improve performance\n            Supported for inner, left, right and full joins\n\n            * *none*\n                No specific ordering is desired. The ordering might differ across\n                Polars versions or even between different runs.\n            * *left*\n                Preserves the order of the left DataFrame.\n            * *right*\n                Preserves the order of the right DataFrame.\n            * *left_right*\n                First preserves the order of the left DataFrame, then the right.\n            * *right_left*\n                First preserves the order of the right DataFrame, then the left.\n\n        Note\n        ----\n        Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.\n\n        Examples\n        --------\n        **Spatial join roads that intersect rails**\n\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from spatial_polars import scan_spatial\n        &gt;&gt;&gt; zipped_data = r\"C:\\data\\illinois-latest-free.shp.zip\"\n        &gt;&gt;&gt; roads_df, rails_df = pl.collect_all([\n        &gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_roads_free_1\").select(\"name\", \"geometry\"),\n        &gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_railways_free_1\").select(\"name\", \"geometry\")\n        &gt;&gt;&gt;     ],\n        &gt;&gt;&gt;     engine=\"streaming\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; roads_rails_df = roads_df.spatial.join(\n        &gt;&gt;&gt;     rails_df,\n        &gt;&gt;&gt;     suffix=\"_rail\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; roads_rails_df\n        shape: (43_772, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 name            \u2506 geometry                 \u2506 name_rail                \u2506 geometry_rail            \u2502\n        \u2502 ---             \u2506 ---                      \u2506 ---                      \u2506 ---                      \u2502\n        \u2502 str             \u2506 struct[2]                \u2506 str                      \u2506 struct[2]                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n        \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n        \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00[ \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n        \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n        \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n        \u2502 \u2026               \u2506 \u2026                        \u2506 \u2026                        \u2506 \u2026                        \u2502\n        \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n        \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n        \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n        \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n        \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n        \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 Matteson Subdivision     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n        \u2502                 \u2506 x16\\x0\u2026                  \u2506                          \u2506 x1f\\x0\u2026                  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n        if left_on is None:\n            left_on = on\n        if right_on is None:\n            right_on = on\n\n        self_geometries = self._df[left_on].spatial.to_shapely_array()\n\n        other_geometries = other[right_on].spatial.to_shapely_array()\n\n        tree_query_df = pl.DataFrame(\n            shapely.STRtree(self_geometries)\n            .query(other_geometries, predicate=predicate, distance=distance)\n            .T,\n            schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n        )\n\n        if how in [\"left\", \"right\", \"full\", \"inner\"]:\n            joined = (\n                self._df.with_row_index(\"left_index\")\n                .join(\n                    tree_query_df,\n                    how=how,\n                    on=\"left_index\",\n                    maintain_order=maintain_order,\n                )\n                .join(\n                    other.with_row_index(\"right_index\"),\n                    how=how,\n                    on=\"right_index\",\n                    suffix=suffix,\n                    maintain_order=maintain_order,\n                )\n                .drop(\"right_index\", \"left_index\")\n            )\n        elif how in [\"semi\", \"anti\"]:\n            joined = (\n                self._df.with_row_index(\"left_index\")\n                .join(\n                    tree_query_df,\n                    how=how,\n                    on=\"left_index\",\n                    maintain_order=maintain_order,\n                )\n                .drop(c.left_index)\n            )\n\n        return joined\n\n    def join_nearest(\n        self,\n        other: pl.DataFrame,\n        how: Literal[\"left\", \"inner\"] = \"inner\",\n        max_distance: Optional[float] = None,\n        return_distance: bool = False,\n        exclusive: bool = False,\n        all_matches: bool = True,\n        on: str = \"geometry\",\n        left_on: Optional[str] = None,\n        right_on: Optional[str] = None,\n        suffix: str = \"_right\",\n        maintain_order: Literal[\n            \"none\", \"left\", \"right\", \"left_right\", \"right_left\"\n        ] = \"none\",\n    ) -&gt; pl.DataFrame:\n        r\"\"\"\n        Joins two dataframes based on a spatial distance .\n\n        Parameters\n        ----------\n        other\n            SpatialFrame to join with.\n\n        how\n            Join strategy.\n\n            * *inner*\n                Returns rows that have matching values in both tables\n            * *left*\n                Returns all rows from the left table, and the matched rows from the\n                right table\n\n        max_distance\n            The maximum distance to search around an input feature.\n\n        on\n            Name of the geometry columns in both SpatialFrames.\n\n        left_on\n            Name of the geometry column in the left SpatialFrame for the spatial join.\n\n        right_on\n            Name of the geometry column in the right SpatialFrame for the spatial join.\n\n        suffix\n            Suffix to append to columns with a duplicate name.\n\n        maintain_order\n            Which DataFrame row order to preserve, if any.\n            Do not rely on any observed ordering without explicitly\n            setting this parameter, as your code may break in a future release.\n            Not specifying any ordering can improve performance\n            Supported for inner, left, right and full joins\n\n            * *none*\n                No specific ordering is desired. The ordering might differ across\n                Polars versions or even between different runs.\n            * *left*\n                Preserves the order of the left DataFrame.\n            * *right*\n                Preserves the order of the right DataFrame.\n            * *left_right*\n                First preserves the order of the left DataFrame, then the right.\n            * *right_left*\n                First preserves the order of the right DataFrame, then the left.\n\n        Note\n        ----\n        Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.\n        \"\"\"\n        if left_on is None:\n            left_on = on\n        if right_on is None:\n            right_on = on\n\n        self_geometries = self._df[left_on].spatial.to_shapely_array()\n\n        other_geometries = other[right_on].spatial.to_shapely_array()\n\n        query_results = shapely.STRtree(self_geometries).query_nearest(\n            other_geometries,\n            max_distance=max_distance,\n            return_distance=return_distance,\n            exclusive=exclusive,\n            all_matches=all_matches,\n        )\n\n        if return_distance is True:\n            tree_query_df = pl.DataFrame(\n                query_results[0].T,\n                schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n            ).with_columns(pl.Series(\"distance\", query_results[1]))\n        else:\n            tree_query_df = pl.DataFrame(\n                query_results,\n                schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n            )\n\n        joined = (\n            self._df.with_row_index(\"left_index\")\n            .join(\n                tree_query_df,\n                how=how,\n                on=\"left_index\",\n                maintain_order=maintain_order,\n            )\n            .join(\n                other.with_row_index(\"right_index\"),\n                how=how,\n                on=\"right_index\",\n                suffix=suffix,\n                maintain_order=maintain_order,\n            )\n            .drop(\"right_index\", \"left_index\")\n        )\n\n        return joined\n\n    def viz(\n        self,\n        geometry_name: str = \"geometry\",\n        scatterplot_kwargs: Optional[ScatterplotLayerKwargs] = None,\n        path_kwargs: Optional[PathLayerKwargs] = None,\n        polygon_kwargs: Optional[PolygonLayerKwargs] = None,\n        map_kwargs: Optional[MapKwargs] = None,\n    ) -&gt; Map:\n        r\"\"\"Visualizes the dataframe as a layer in a Lonboard [map][lonboard.Map].\n\n        Parameters\n        ----------\n        geometry_name\n            The name of the column in the dataframe that will be use to visualize the features on the Lonboard map.\n\n        scatterplot_kwargs\n            a dict of parameters to pass down to all generated ScatterplotLayers.\n\n        path_kwargs\n            a dict of parameters to pass down to all generated PathLayers.\n\n        polygon_kwargs\n            a dict of parameters to pass down to all generated PolygonLayers.\n\n        map_kwargs\n            a dict of parameters to pass down to the generated Map.\n\n        Note\n        ----\n        Any rows with null geometries will be discarded.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from spatial_polars import read_spatial\n        &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n        &gt;&gt;&gt; df = read_spatial(my_shapefile)\n        &gt;&gt;&gt; df.spatial.viz()\n\n        \"\"\"\n        geoarrow_table = self.to_geoarrow(geometry_name)\n\n        return viz(\n            geoarrow_table,\n            scatterplot_kwargs=scatterplot_kwargs,\n            path_kwargs=path_kwargs,\n            polygon_kwargs=polygon_kwargs,\n            map_kwargs=map_kwargs,\n        )\n\n    def to_scatterplotlayer(\n        self,\n        geometry_name: str = \"geometry\",\n        filled: bool = True,\n        fill_color: Union[List, Tuple, None] = None,\n        fill_cmap_col: Optional[str] = None,\n        fill_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n        fill_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n        fill_alpha: Union[float, int, NDArray[floating], None] = None,\n        fill_normalize_cmap_col: bool = True,\n        stroked: bool = True,\n        line_color: Union[List, Tuple, None] = None,\n        line_cmap_col: Optional[str] = None,\n        line_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n        line_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n        line_alpha: Union[float, int, NDArray[floating], None] = None,\n        line_normalize_cmap_col: bool = True,\n        line_width: Union[float, int, NDArray[floating], str, None] = 1,\n        line_width_min_pixels: float = 1,\n        line_width_max_pixels: Optional[float] = None,\n        line_width_scale: float = 1,\n        line_width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n        radius: Union[float, int, NDArray[floating], str, None] = 1,\n        radius_max_pixels: Optional[float] = None,\n        radius_min_pixels: float = 0,\n        radius_scale: float = 1,\n        radius_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n        auto_highlight: bool = False,\n        highlight_color=[0, 0, 128, 128],\n        opacity: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        antialiasing: bool = True,\n        billboard: bool = False,\n    ) -&gt; ScatterplotLayer:\n        \"\"\"\n        Makes a Lonboard [ScatterplotLayer][lonboard.ScatterplotLayer] from the SpatialFrame.\n\n        Parameters\n        ----------\n        geometry_name\n            The name of the column in the SpatialFrame that will be used for the geometries of the points in the layer.\n\n        filled\n            Draw the filled area of points.\n\n        fill_color\n            The filled color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n        fill_cmap_col\n            The name of the column in the SpatialFrame that will be used to vary the color of the points in the layer.  Only applicable if `fill_cmap_type` is not None.\n\n        fill_cmap_type\n            The type of color map to use.  Only applicable if `fill_cmap_col` is set.\n\n        fill_cmap\n            If `fill_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the points in the layer.\n            If `fill_cmap_type` is `categorical`, a dictionary of mappings of the values from `fill_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `fill_cmap_col`.\n\n        fill_alpha\n            The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `fill_cmap_col` and `fill_cmap` are set.\n\n        fill_normalize_cmap_col\n            If `True` a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the points in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `fill_cmap_col` and `fill_cmap` are set and `fill_cmap_type` is `continuous`.\n\n        stroked\n            The filled color of each object in the format of\n\n        line_color\n            The outline color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n        line_cmap_col\n            The name of the column in the SpatialFrame that will be used to vary the color of the point outlines in the layer.  Only applicable if `line_cmap_type` is not None.\n\n        line_cmap_type\n            The type of color map to use.  Only applicable if `line_cmap_col` is set.\n\n        line_cmap\n            If `line_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the point outlines in the layer.\n            If `line_cmap_type` is `categorical`, a dictionary of mappings of the values from `line_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `line_cmap_col`.\n\n        line_alpha\n            The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `line_cmap_col` and `line_cmap` are set.\n\n        line_normalize_cmap_col\n            If `True` a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the point outlines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `line_cmap_col` and `line_cmap` are set and `line_cmap_type` is `continuous`.\n\n        line_width\n            The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n        line_width_min_pixels\n            The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n        line_width_max_pixels\n            The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n        line_width_scale\n            The path width multiplier that multiplied to all paths.\n\n        line_width_units\n            The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n        radius\n            The radius of each object, in units specified by radius_units (default 'meters').  If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all points. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n        radius_max_pixels\n            The maximum radius in pixels. This can be used to prevent the circle from getting too big when zoomed in.\n\n        radius_min_pixels\n            The minimum radius in pixels. This can be used to prevent the circle from getting too small when zoomed out.\n\n        radius_scale\n            A global radius multiplier for all points.\n\n        radius_units\n            The units of the radius, one of 'meters', 'common', and 'pixels'\n\n        auto_highlight\n            When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n        highlight_color\n            RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n        opacity\n            The opacity of the layer.\n\n        pickable\n            Whether the layer responds to mouse pointer picking events.\n            This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n            Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n        visible\n            Whether the layer is visible.\n            Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n            In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n        antialiasing\n            If True, circles are rendered with smoothed edges. If False, circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles.\n\n        billboard\n            If True, rendered circles always face the camera. If False circles face up (i.e. are parallel with the ground plane).\n\n        Note\n        ----\n        Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n\n        \"\"\"\n        validate_cmap_input(\n            self._df,\n            fill_cmap_col,\n            fill_cmap_type,\n            fill_cmap,\n            fill_alpha,\n            fill_normalize_cmap_col,\n        )\n        validate_cmap_input(\n            self._df,\n            line_cmap_col,\n            line_cmap_type,\n            line_cmap,\n            line_alpha,\n            line_normalize_cmap_col,\n        )\n        validate_width_and_radius_input(self._df, line_width)\n        validate_width_and_radius_input(self._df, radius)\n\n        if fill_cmap_col is not None:\n            if fill_cmap_type == \"continuous\":\n                if fill_normalize_cmap_col:\n                    norm_arr = (\n                        self._df.select(c(fill_cmap_col).spatial.min_max())\n                        .to_series()\n                        .to_numpy()\n                    )\n                else:\n                    norm_arr = self._df.select(c(fill_cmap_col)).to_series().to_numpy()\n                fill_color = apply_continuous_cmap(\n                    norm_arr, fill_cmap, alpha=fill_alpha\n                )\n            elif fill_cmap_type == \"categorical\":\n                cat_arr = self._df.select(c(fill_cmap_col)).to_series().to_arrow()\n\n                if fill_cmap is None:\n                    fill_cmap = {}\n                    for cat in self._df[fill_cmap_col].unique():\n                        fill_cmap[cat] = [\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                        ]\n\n                fill_color = apply_categorical_cmap(\n                    cat_arr, fill_cmap, alpha=fill_alpha\n                )\n\n        if line_cmap_col is not None:\n            if line_cmap_type == \"continuous\":\n                if line_normalize_cmap_col:\n                    norm_arr = (\n                        self._df.select(c(line_cmap_col).spatial.min_max())\n                        .to_series()\n                        .to_numpy()\n                    )\n                else:\n                    norm_arr = self._df.select(c(line_cmap_col)).to_series().to_numpy()\n                line_color = apply_continuous_cmap(\n                    norm_arr, line_cmap, alpha=line_alpha\n                )\n            elif line_cmap_type == \"categorical\":\n                cat_arr = self._df.select(c(line_cmap_col)).to_series().to_arrow()\n\n                if line_cmap is None:\n                    line_cmap = {}\n                    for cat in self._df[line_cmap_col].unique():\n                        line_cmap[cat] = [\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                        ]\n\n                line_color = apply_categorical_cmap(\n                    cat_arr, line_cmap, alpha=line_alpha\n                )\n\n        if isinstance(line_width, str):\n            line_width = self._df.select(c(line_width)).to_series().to_numpy()\n\n        if isinstance(radius, str):\n            radius = self._df.select(c(radius)).to_series().to_numpy()\n\n        geoarrow_table = self.to_geoarrow(geometry_name)\n\n        layer = ScatterplotLayer(\n            table=geoarrow_table,\n            antialiasing=antialiasing,\n            auto_highlight=auto_highlight,\n            billboard=billboard,\n            filled=filled,\n            get_fill_color=fill_color,\n            get_line_color=line_color,\n            get_line_width=line_width,\n            get_radius=radius,\n            highlight_color=highlight_color,\n            line_width_max_pixels=line_width_max_pixels,\n            line_width_min_pixels=line_width_min_pixels,\n            line_width_scale=line_width_scale,\n            line_width_units=line_width_units,\n            opacity=opacity,\n            pickable=pickable,\n            radius_max_pixels=radius_max_pixels,\n            radius_min_pixels=radius_min_pixels,\n            radius_scale=radius_scale,\n            radius_units=radius_units,\n            stroked=stroked,\n            visible=visible,\n        )\n        return layer\n\n    def to_pathlayer(\n        self,\n        geometry_name: str = \"geometry\",\n        color: Union[List, Tuple, None] = None,\n        cmap_col: Optional[str] = None,\n        cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n        cmap: Optional[Union[Palette, Colormap, dict]] = None,\n        alpha: Union[float, int, NDArray[floating], None] = None,\n        normalize_cmap_col: bool = True,\n        width: Union[float, int, NDArray[floating], str, None] = 1,\n        auto_highlight: bool = False,\n        billboard: bool = False,\n        cap_rounded: bool = False,\n        highlight_color=[0, 0, 128, 128],\n        joint_rounded: bool = False,\n        miter_limit: float = 4,\n        opacity: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        width_min_pixels: float = 1,\n        width_max_pixels: Optional[float] = None,\n        width_scale: float = 1,\n        width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n    ) -&gt; PathLayer:\n        \"\"\"\n        Makes a Lonboard [PathLayer][lonboard.PathLayer] from the SpatialFrame.\n\n        Parameters\n        ----------\n        geometry_name\n            The name of the column in the SpatialFrame that will be used for the geometries of the paths in the layer.\n\n        color\n            The color for every path in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n        cmap_col\n            The name of the column in the SpatialFrame that will be used to vary the color of the paths in the layer.  Only applicable if `cmap_type` is not None.\n\n        cmap_type\n            The type of color map to use.  Only applicable if `cmap_col` is set.\n\n        cmap\n            If `cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the lines in the layer.\n            If `cmap_type` is `categorical`, a dictionary of mappings of the values from `cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `cmap_col`.\n\n        alpha\n            The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `c_map_col` and `cmap` are set.\n\n        normalize_cmap_col\n            If `True` a copy of the values in cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the lines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `c_map_col` and `cmap` are set and `cmap_type` is `continuous`.\n\n        width\n            The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n        pickable\n            Whether the layer responds to mouse pointer picking events.\n            This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n            Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n        auto_highlight\n            When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n        highlight_color\n            RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n        billboard\n            If `True`, extrude the path in screen space (width always faces the camera). If `False`, the width always faces up.\n\n        cap_rounded\n            Type of caps. If `True`, draw round caps. Otherwise draw square caps.\n\n        joint_rounded\n            Type of joint. If `True`, draw round joints. Otherwise draw miter joints.\n\n        miter_limit\n            The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is `False`.\n\n        opacity\n            The opacity of the layer.\n\n        visible\n            Whether the layer is visible.\n            Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n            In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n        width_min_pixels\n            The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n        width_max_pixels\n            The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n        width_scale\n            The path width multiplier that multiplied to all paths.\n\n        width_units\n            The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n        Note\n        ----\n        Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n\n        \"\"\"\n        validate_cmap_input(\n            self._df, cmap_col, cmap_type, cmap, alpha, normalize_cmap_col\n        )\n        validate_width_and_radius_input(self._df, width)\n\n        if cmap_col is not None:\n            if cmap_type == \"continuous\":\n                if normalize_cmap_col:\n                    norm_arr = (\n                        self._df.select(c(cmap_col).spatial.min_max())\n                        .to_series()\n                        .to_numpy()\n                    )\n                else:\n                    norm_arr = self._df.select(c(cmap_col)).to_series().to_numpy()\n                color = apply_continuous_cmap(norm_arr, cmap, alpha=alpha)\n            elif cmap_type == \"categorical\":\n                cat_arr = self._df.select(c(cmap_col)).to_series().to_arrow()\n\n                if cmap is None:\n                    cmap = {}\n                    for cat in self._df[cmap_col].unique():\n                        cmap[cat] = [\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                        ]\n\n                color = apply_categorical_cmap(cat_arr, cmap, alpha=alpha)\n\n        if isinstance(width, str):\n            width = self._df.select(c(width)).to_series().to_numpy()\n\n        geoarrow_table = self.to_geoarrow(geometry_name)\n\n        layer = PathLayer(\n            table=geoarrow_table,\n            auto_highlight=auto_highlight,\n            billboard=billboard,\n            cap_rounded=cap_rounded,\n            get_width=width,\n            highlight_color=highlight_color,\n            joint_rounded=joint_rounded,\n            miter_limit=miter_limit,\n            opacity=opacity,\n            pickable=pickable,\n            visible=visible,\n            get_color=color,\n            width_min_pixels=width_min_pixels,\n            width_max_pixels=width_max_pixels,\n            width_scale=width_scale,\n            width_units=width_units,\n        )\n        return layer\n\n    def to_polygonlayer(\n        self,\n        geometry_name: str = \"geometry\",\n        filled: bool = True,\n        fill_color: Union[List, Tuple, None] = None,\n        fill_cmap_col: Optional[str] = None,\n        fill_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n        fill_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n        fill_alpha: Union[float, int, NDArray[floating], None] = None,\n        fill_normalize_cmap_col: bool = True,\n        stroked: bool = True,\n        line_color: Union[List, Tuple, None] = None,\n        line_cmap_col: Optional[str] = None,\n        line_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n        line_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n        line_alpha: Union[float, int, NDArray[floating], None] = None,\n        line_normalize_cmap_col: bool = True,\n        line_width: Union[float, int, NDArray[floating], str, None] = 1,\n        line_joint_rounded: bool = False,\n        line_miter_limit: float = 4,\n        line_width_min_pixels: float = 1,\n        line_width_max_pixels: Optional[float] = None,\n        line_width_scale: float = 1,\n        line_width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n        elevation: Union[float, int, NDArray[floating], str, None] = None,\n        elevation_scale: float = 1,\n        auto_highlight: bool = False,\n        highlight_color=[0, 0, 128, 128],\n        opacity: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        wireframe: bool = False,\n    ) -&gt; PolygonLayer:\n        \"\"\"\n        Makes a Lonboard [PolygonLayer][lonboard.PolygonLayer] from the SpatialFrame.\n\n        Parameters\n        ----------\n        geometry_name\n            The name of the column in the SpatialFrame that will be used for the geometries of the polygons in the layer.\n\n        filled\n            Whether to draw a filled polygon (solid fill).  Note that only the area between the outer polygon and any holes will be filled.\n\n        fill_color\n            The fill color for every polygon in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n        fill_cmap_col\n            The name of the column in the SpatialFrame that will be used to vary the color of the polygons in the layer.  Only applicable if `fill_cmap_type` is not None.\n\n        fill_cmap_type\n            The type of color map to use.  Only applicable if `fill_cmap_col` is set.\n\n        fill_cmap\n            If `fill_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the polygons in the layer.\n            If `fill_cmap_type` is `categorical`, a dictionary of mappings of the values from `fill_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `fill_cmap_col`.\n\n        fill_alpha\n            The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `fill_cmap_col` and `fill_cmap` are set.\n\n        fill_normalize_cmap_col\n            If `True` a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the polygons in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `fill_cmap_col` and `fill_cmap` are set and `fill_cmap_type` is `continuous`.\n\n        stroked\n            Whether to draw an outline around the polygon (solid fill).  Note that both the outer polygon as well the outlines of any holes will be drawn.\n\n        line_color\n            The color for every polygon outline in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n        line_cmap_col\n            The name of the column in the SpatialFrame that will be used to vary the color of the polygon outlines in the layer.  Only applicable if `line_cmap_type` is not None.\n\n        line_cmap_type\n            The type of color map to use.  Only applicable if `line_cmap_col` is set.\n\n        line_cmap\n            If `line_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the polygon outlines in the layer.\n            If `line_cmap_type` is `categorical`, a dictionary of mappings of the values from `line_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `line_cmap_col`.\n\n        line_alpha\n            The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `line_cmap_col` and `line_cmap` are set.\n\n        line_normalize_cmap_col\n            If `True` a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the polygon outlines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `line_cmap_col` and `line_cmap` are set and `line_cmap_type` is `continuous`.\n\n        line_width\n            The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n        line_joint_rounded\n            Type of joint. If `True`, draw round joints. Otherwise draw miter joints.\n\n        line_miter_limit\n            The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is `False`.\n\n        line_width_min_pixels\n            The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n        line_width_max_pixels\n            The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n        line_width_scale\n            The path width multiplier that multiplied to all paths.\n\n        line_width_units\n            The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n        elevation\n            The elevation to extrude each polygon with, in meters.  Only applies if extruded=True.  If a number is provided, it is used as the width for all polygons.  If an array is provided, each value in the array will be used as the width for the polygon at the same row index.  If a string is provided it will be used as a column name in the frame to use for the elevation.\n            Providing a value to elevation will set `extruded=True` on the layer.\n\n        elevation_scale\n            Elevation multiplier. The final elevation is calculated by elevation_scale * elevation(d). `elevation_scale` is a handy property to scale all elevation without updating the data.\n\n        auto_highlight\n            When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n        highlight_color\n            RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n        opacity\n            The opacity of the layer.\n\n        pickable\n            Whether the layer responds to mouse pointer picking events.\n            This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n            Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n        visible\n            Whether the layer is visible.\n            Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n            In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n        wireframe\n            Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.\n\n        Note\n        ----\n        Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n        \"\"\"\n        validate_cmap_input(\n            self._df,\n            fill_cmap_col,\n            fill_cmap_type,\n            fill_cmap,\n            fill_alpha,\n            fill_normalize_cmap_col,\n        )\n        validate_cmap_input(\n            self._df,\n            line_cmap_col,\n            line_cmap_type,\n            line_cmap,\n            line_alpha,\n            line_normalize_cmap_col,\n        )\n        validate_width_and_radius_input(self._df, line_width)\n\n        if fill_cmap_col is not None:\n            if fill_cmap_type == \"continuous\":\n                if fill_normalize_cmap_col:\n                    norm_arr = (\n                        self._df.select(c(fill_cmap_col).spatial.min_max())\n                        .to_series()\n                        .to_numpy()\n                    )\n                else:\n                    norm_arr = self._df.select(c(fill_cmap_col)).to_series().to_numpy()\n                fill_color = apply_continuous_cmap(\n                    norm_arr, fill_cmap, alpha=fill_alpha\n                )\n            elif fill_cmap_type == \"categorical\":\n                cat_arr = self._df.select(c(fill_cmap_col)).to_series().to_arrow()\n\n                if fill_cmap is None:\n                    fill_cmap = {}\n                    for cat in self._df[fill_cmap_col].unique():\n                        fill_cmap[cat] = [\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                        ]\n\n                fill_color = apply_categorical_cmap(\n                    cat_arr, fill_cmap, alpha=fill_alpha\n                )\n\n        if line_cmap_col is not None:\n            if line_cmap_type == \"continuous\":\n                if line_normalize_cmap_col:\n                    norm_arr = (\n                        self._df.select(c(line_cmap_col).spatial.min_max())\n                        .to_series()\n                        .to_numpy()\n                    )\n                else:\n                    norm_arr = self._df.select(c(line_cmap_col)).to_series().to_numpy()\n                line_color = apply_continuous_cmap(\n                    norm_arr, line_cmap, alpha=line_alpha\n                )\n            elif line_cmap_type == \"categorical\":\n                cat_arr = self._df.select(c(line_cmap_col)).to_series().to_arrow()\n\n                if line_cmap is None:\n                    line_cmap = {}\n                    for cat in self._df[line_cmap_col].unique():\n                        line_cmap[cat] = [\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                            random.randint(0, 255),\n                        ]\n\n                line_color = apply_categorical_cmap(\n                    cat_arr, line_cmap, alpha=line_alpha\n                )\n\n        if isinstance(line_width, str):\n            line_width = self._df.select(c(line_width)).to_series().to_numpy()\n\n        extruded = False\n        if elevation is not None:\n            extruded = True\n        if isinstance(elevation, str):\n            elevation = self._df.select(c(elevation)).to_series().to_numpy()\n\n        geoarrow_table = self.to_geoarrow(geometry_name)\n\n        layer = PolygonLayer(\n            table=geoarrow_table,\n            auto_highlight=auto_highlight,\n            elevation_scale=elevation_scale,\n            extruded=extruded,\n            filled=filled,\n            get_elevation=elevation,\n            get_fill_color=fill_color,\n            get_line_color=line_color,\n            get_line_width=line_width,\n            highlight_color=highlight_color,\n            line_joint_rounded=line_joint_rounded,\n            line_miter_limit=line_miter_limit,\n            line_width_max_pixels=line_width_max_pixels,\n            line_width_min_pixels=line_width_min_pixels,\n            line_width_scale=line_width_scale,\n            line_width_units=line_width_units,\n            opacity=opacity,\n            pickable=pickable,\n            stroked=stroked,\n            visible=visible,\n            wireframe=wireframe,\n        )\n        return layer\n\n    @staticmethod\n    def from_point_coords(\n        df, x_col: str, y_col: str, z_col: Optional[str] = None, crs: Any = 4326\n    ):\n        r\"\"\"\n        Creates a SpatialFrame from a polars DataFrame with x/y/(z) columns.\n\n        Parameters\n        ----------\n\n        x_col\n            The name of the column in the DataFrame which holds the X coordinates.\n\n        y_col\n            The name of the column in the DataFrame which holds the Y coordinates.\n\n        z_col\n            The name of the column in the DataFrame which holds the Z coordinates.\n\n        crs\n            A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n            PROJ string\n\n            Dictionary of PROJ parameters\n\n            PROJ keyword arguments for parameters\n\n            JSON string with PROJ parameters\n\n            CRS WKT string\n\n            An authority string [i.e. \u2018epsg:4326\u2019]\n\n            An EPSG integer code [i.e. 4326]\n\n            A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]\n\n            An object with a to_wkt method.\n\n            A pyproj.crs.CRS class\n\n        Examples\n        --------\n        Creating a SpatialFrame from a polars df with a columns of coordinates of points .\n\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from spatial_polars import SpatialFrame\n        &gt;&gt;&gt; df = pl.DataFrame({\n        &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n        &gt;&gt;&gt;     \"x\":[-90.18497, -90.06211],\n        &gt;&gt;&gt;     \"y\":[38.62456, 38.66072],\n        &gt;&gt;&gt;     \"z\":[0,0]\n        &gt;&gt;&gt; })\n        &gt;&gt;&gt; s_df = SpatialFrame.from_point_coords(df, \"x\", \"y\", \"z\")\n        &gt;&gt;&gt; s_df\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Place        \u2506 geometry                        \u2502\n        \u2502 ---          \u2506 ---                             \u2502\n        \u2502 str          \u2506 struct[2]                       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n        \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        \"\"\"\n        coord_cols = [x_col, y_col]\n        if z_col is not None:\n            coord_cols.append(z_col)\n\n        points = shapely.points(df.select(coord_cols).to_numpy().copy())\n        wkb_array = shapely.to_wkb(points)\n        crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n        return df.drop(coord_cols).with_columns(\n            pl.struct(\n                pl.Series(\"wkb_geometry\", wkb_array, dtype=pl.Binary),\n                pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n            ).alias(\"geometry\")\n        )\n\n    @staticmethod\n    def from_WKB(df: pl.DataFrame, wkb_col: str, crs: Any = 4326):\n        r\"\"\"\n        Creates a SpatialFrame from a polars DataFrame with a column of WKB.\n\n        Parameters\n        ----------\n        wkb_col\n            The name of the column in the DataFrame which holds geometry WKB.\n\n        crs\n            A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n            PROJ string\n\n            Dictionary of PROJ parameters\n\n            PROJ keyword arguments for parameters\n\n            JSON string with PROJ parameters\n\n            CRS WKT string\n\n            An authority string [i.e. 'epsg:4326']\n\n            An EPSG integer code [i.e. 4326]\n\n            A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e ('epsg', '4326')]\n\n            An object with a to_wkt method.\n\n            A pyproj.crs.CRS class\n\n        Examples\n        --------\n        Creating a SpatialFrame from a polars df with a column of WKB.\n\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; import shapely\n        &gt;&gt;&gt; from spatial_polars import SpatialFrame\n        &gt;&gt;&gt; arch_wkb = shapely.Point(-90.18497, 38.62456).wkb\n        &gt;&gt;&gt; monks_mound_wkb = shapely.Point(-90.06211, 38.66072).wkb\n        &gt;&gt;&gt; df = pl.DataFrame({\n        &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n        &gt;&gt;&gt;     \"wkb\":[arch_wkb, monks_mound_wkb],\n        &gt;&gt;&gt; })\n        &gt;&gt;&gt; s_df = SpatialFrame.from_WKB(df, \"wkb\")\n        &gt;&gt;&gt; s_df\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Place        \u2506 geometry                        \u2502\n        \u2502 ---          \u2506 ---                             \u2502\n        \u2502 str          \u2506 struct[2]                       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n        \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        \"\"\"\n        crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n\n        return df.with_columns(\n            pl.struct(\n                c(wkb_col).alias(\"wkb_geometry\"),\n                pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n            ).alias(\"geometry\")\n        ).drop(c(wkb_col))\n\n    @staticmethod\n    def from_WKT(df, wkt_col: str, crs: Any = 4326):\n        r\"\"\"\n        Creates a SpatialFrame from a polars DataFrame with a column of WKT.\n\n        Parameters\n        ----------\n\n        wkt_col\n            The name of the column in the DataFrame which holds geometry WKT.\n\n        crs\n            A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n            PROJ string\n\n            Dictionary of PROJ parameters\n\n            PROJ keyword arguments for parameters\n\n            JSON string with PROJ parameters\n\n            CRS WKT string\n\n            An authority string [i.e. \u2018epsg:4326\u2019]\n\n            An EPSG integer code [i.e. 4326]\n\n            A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]\n\n            An object with a to_wkt method.\n\n            A pyproj.crs.CRS class\n\n        Examples\n        --------\n        Creating a SpatialFrame from a polars df with a column of WKT.\n\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; import shapely\n        &gt;&gt;&gt; from spatial_polars import SpatialFrame\n        &gt;&gt;&gt; arch_wkt = shapely.Point(-90.18497, 38.62456).wkt\n        &gt;&gt;&gt; monks_mound_wkt = shapely.Point(-90.06211, 38.66072).wkt\n        &gt;&gt;&gt; df = pl.DataFrame({\n        &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n        &gt;&gt;&gt;     \"wkt\":[arch_wkt, monks_mound_wkt],\n        &gt;&gt;&gt; })\n        &gt;&gt;&gt; s_df = SpatialFrame.from_WKT(df, \"wkt\")\n        &gt;&gt;&gt; s_df\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Place        \u2506 geometry                        \u2502\n        \u2502 ---          \u2506 ---                             \u2502\n        \u2502 str          \u2506 struct[2]                       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n        \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        \"\"\"\n        geoms = shapely.from_wkt(df.select(wkt_col).to_series().to_numpy().copy())\n        wkb_array = shapely.to_wkb(geoms)\n        crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n        return df.with_columns(\n            pl.struct(\n                pl.Series(\"wkb_geometry\", wkb_array, dtype=pl.Binary),\n                pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n            ).alias(\"geometry\")\n        ).drop(c(wkt_col))\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.write_spatial","title":"<code>write_spatial(path, layer=None, driver=None, geometry_name='geometry', geometry_type=None, crs=None, encoding=None, append=False, dataset_metadata=None, layer_metadata=None, metadata=None, dataset_options=None, layer_options=None)</code>","text":"<p>Writes the dataframe to a format supported by pyogrio.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | BytesIO</code> <p>path to output file on writeable file system or an io.BytesIO object to allow writing to memory NOTE: support for writing to memory is limited to specific drivers.</p> required <code>layer</code> <code>Optional[str]</code> <p>layer name to create. If writing to memory and layer name is not provided, it layer name will be set to a UUID4 value.</p> <code>None</code> <code>driver</code> <code>Optional[str]</code> <p>The OGR format driver used to write the vector file. By default attempts to infer driver from path. Must be provided to write to memory.</p> <code>None</code> <code>geometry_name</code> <code>str</code> <p>The name of the column in the dataframe that will be written as the geometry field.</p> <code>'geometry'</code> <code>geometry_type</code> <code>Optional[str]</code> <p>The geometry type of the written layer. Currently, this needs to be specified explicitly when creating a new layer with geometries. Possible values are: \u201cUnknown\u201d, \u201cPoint\u201d, \u201cLineString\u201d, \u201cPolygon\u201d, \u201cMultiPoint\u201d, \u201cMultiLineString\u201d, \u201cMultiPolygon\u201d \u201cGeometryCollection\u201d, \u201cPoint Z\u201d, \u201cLineString Z\u201d, \u201cPolygon Z\u201d, \u201cMultiPoint Z\u201d, \u201cMultiLineString Z\u201d, \u201cMultiPolygon Z\u201d or \u201cGeometryCollection Z\u201d.</p> <p>This parameter does not modify the geometry, but it will try to force the layer type of the output file to this value. Use this parameter with caution because using a wrong layer geometry type may result in errors when writing the file, may be ignored by the driver, or may result in invalid files.</p> <code>None</code> <code>crs</code> <code>Optional[str]</code> <p>WKT-encoded CRS of the geometries to be written.    If left as None, the CRS from the geometry column's struct will be used.</p> <code>None</code> <code>encoding</code> <code>Optional[str]</code> <p>Only used for the .dbf file of ESRI Shapefiles. If not specified, uses the default locale.</p> <code>None</code> <code>append</code> <code>bool</code> <p>If True, the data source specified by path already exists, and the driver supports appending to an existing data source, will cause the data to be appended to the existing records in the data source. Not supported for writing to in-memory files. NOTE: append support is limited to specific drivers and GDAL versions.</p> <code>False</code> <code>dataset_metadata</code> <code>Optional[dict]</code> <p>Metadata to be stored at the dataset level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> <code>None</code> <code>layer_metadata</code> <code>Optional[dict]</code> <p>Metadata to be stored at the layer level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>alias of layer_metadata.</p> <code>None</code> <code>dataset_options</code> <code>Optional[dict]</code> <p>Dataset creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> <code>None</code> <code>layer_options</code> <code>Optional[dict]</code> <p>Layer creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> <code>None</code> <p>Examples:</p> <p>Writing a shapefile</p> <pre><code>&gt;&gt;&gt; from spatial_polars import read_spatial\n&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; df = read_spatial(my_shapefile)\n&gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\data\\roads_2.shp\")\n</code></pre> <p>Writing a geopackage</p> <pre><code>&gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\random_data\\my_geopackage.gpkg\", layer=\"roads\")\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def write_spatial(\n    self,\n    path: str | BytesIO,\n    layer: Optional[str] = None,\n    driver: Optional[str] = None,\n    geometry_name: str = \"geometry\",\n    geometry_type: Optional[str] = None,\n    crs: Optional[str] = None,\n    encoding: Optional[str] = None,\n    append: bool = False,\n    dataset_metadata: Optional[dict] = None,\n    layer_metadata: Optional[dict] = None,\n    metadata: Optional[dict] = None,\n    dataset_options: Optional[dict] = None,\n    layer_options: Optional[dict] = None,\n) -&gt; None:\n    r\"\"\"\n    Writes the dataframe to a format supported by [pyogrio][].\n\n    Parameters\n    ----------\n\n    path\n        path to output file on writeable file system or an io.BytesIO object to allow writing to memory NOTE: support for writing to memory is limited to specific drivers.\n\n    layer\n        layer name to create. If writing to memory and layer name is not provided, it layer name will be set to a UUID4 value.\n\n    driver\n        The OGR format driver used to write the vector file. By default attempts to infer driver from path. Must be provided to write to memory.\n\n    geometry_name\n        The name of the column in the dataframe that will be written as the geometry field.\n\n    geometry_type\n        The geometry type of the written layer. Currently, this needs to be specified explicitly when creating a new layer with geometries. Possible values are: \u201cUnknown\u201d, \u201cPoint\u201d, \u201cLineString\u201d, \u201cPolygon\u201d, \u201cMultiPoint\u201d, \u201cMultiLineString\u201d, \u201cMultiPolygon\u201d \u201cGeometryCollection\u201d, \u201cPoint Z\u201d, \u201cLineString Z\u201d, \u201cPolygon Z\u201d, \u201cMultiPoint Z\u201d, \u201cMultiLineString Z\u201d, \u201cMultiPolygon Z\u201d or \u201cGeometryCollection Z\u201d.\n\n        This parameter does not modify the geometry, but it will try to force the layer type of the output file to this value. Use this parameter with caution because using a wrong layer geometry type may result in errors when writing the file, may be ignored by the driver, or may result in invalid files.\n\n    crs\n        WKT-encoded CRS of the geometries to be written.    If left as None, the CRS from the geometry column's struct will be used.\n\n    encoding\n        Only used for the .dbf file of ESRI Shapefiles. If not specified, uses the default locale.\n\n    append\n        If True, the data source specified by path already exists, and the driver supports appending to an existing data source, will cause the data to be appended to the existing records in the data source. Not supported for writing to in-memory files. NOTE: append support is limited to specific drivers and GDAL versions.\n\n    dataset_metadata\n        Metadata to be stored at the dataset level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.\n\n    layer_metadata\n        Metadata to be stored at the layer level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.\n\n    metadata\n        alias of layer_metadata.\n\n    dataset_options\n        Dataset creation options (format specific) passed to OGR. Specify as a key-value dictionary.\n\n    layer_options\n        Layer creation options (format specific) passed to OGR. Specify as a key-value dictionary.\n\n    Examples\n    --------\n\n    **Writing a shapefile**\n    &gt;&gt;&gt; from spatial_polars import read_spatial\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; df = read_spatial(my_shapefile)\n    &gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\data\\roads_2.shp\")\n\n    **Writing a geopackage**\n    &gt;&gt;&gt; df.spatial.write_spatial(r\"C:\\random_data\\my_geopackage.gpkg\", layer=\"roads\")\n\n    \"\"\"\n    geometries_wkb = (\n        self._df[geometry_name].struct.field(\"wkb_geometry\").to_numpy().copy()\n    )\n    pa_table = (\n        self._df.drop(geometry_name)\n        .with_columns(pl.Series(\"geometry\", geometries_wkb, dtype=pl.Binary))\n        .to_arrow()\n    )\n\n    if any([geometry_type is None, crs is None]):\n        geom_wkb = geometries_wkb[0]\n        geom = shapely.from_wkb(geom_wkb)\n        if geometry_type is None:\n            geometry_type = geom.geom_type\n        if crs is None:\n            crs = pyproj.CRS(self._df[geometry_name].struct.field(\"crs\")[0]).to_wkt(\n                version=\"WKT1_GDAL\"\n            )\n\n    pyogrio.write_arrow(\n        pa_table,\n        path=path,\n        layer=layer,\n        driver=driver,\n        geometry_name=geometry_name,\n        geometry_type=geometry_type,\n        crs=crs,\n        encoding=encoding,\n        append=append,\n        dataset_metadata=dataset_metadata,\n        layer_metadata=layer_metadata,\n        metadata=metadata,\n        dataset_options=dataset_options,\n        layer_options=layer_options,\n    )\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.write_geoparquet","title":"<code>write_geoparquet(path, geometry_name='geometry', crs=None, write_bbox=False, write_geometry_types=None)</code>","text":"<p>Writes the dataframe to a geoparquet file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to output file on writeable file system.</p> required <code>geometry_name</code> <code>str</code> <p>The name of the column in the dataframe that will be written as the geometry field.</p> <code>'geometry'</code> <code>crs</code> <code>Optional[str]</code> <p>WKT-encoded CRS of the geometries to be written.  If left as None, the CRS from the geometry column's struct will be used.</p> <code>None</code> <code>write_bbox</code> <code>bool</code> <p>May be computationally expensive for large input.</p> <code>False</code> <code>write_geometry_types</code> <code>Optional[bool]</code> <p>May be computationally expensive for large input.</p> <code>None</code> Note <p>Any rows with null geometries will be discarded.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spatial_polars import read_spatial\n&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; df = read_spatial(my_shapefile)\n&gt;&gt;&gt; df.spatial.write_geoparquet(r\"c:\\data\\roads.parquet\")\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def write_geoparquet(\n    self,\n    path: str,\n    geometry_name: str = \"geometry\",\n    crs: Optional[str] = None,\n    write_bbox: bool = False,\n    write_geometry_types: Optional[bool] = None,\n):\n    r\"\"\"\n    Writes the dataframe to a geoparquet file.\n\n    Parameters\n    ----------\n\n    path\n        path to output file on writeable file system.\n\n    geometry_name\n        The name of the column in the dataframe that will be written as the geometry field.\n\n    crs\n        WKT-encoded CRS of the geometries to be written.  If left as None, the CRS from the geometry column's struct will be used.\n\n    write_bbox\n        May be computationally expensive for large input.\n\n    write_geometry_types\n        May be computationally expensive for large input.\n\n    Note\n    ----\n    Any rows with null geometries will be discarded.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from spatial_polars import read_spatial\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; df = read_spatial(my_shapefile)\n    &gt;&gt;&gt; df.spatial.write_geoparquet(r\"c:\\data\\roads.parquet\")\n\n    \"\"\"\n    geoarrow_table = self.to_geoarrow(geometry_name)\n    gaio.write_geoparquet_table(\n        geoarrow_table,\n        path,\n        write_bbox=write_bbox,\n        write_geometry_types=write_geometry_types,\n    )\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.to_geoarrow","title":"<code>to_geoarrow(geometry_name='geometry')</code>","text":"<p>Converts the dataframe to geoarrow table.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_name</code> <code>str</code> <p>The name of the column in the dataframe that will be written as the geometry field.</p> <code>'geometry'</code> Note <p>Any rows with null geometries will be discarded.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spatial_polars import read_spatial\n&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; df = read_spatial(my_shapefile)\n&gt;&gt;&gt; df.spatial.to_geoarrow()\npyarrow.Table\nosm_id: large_string\ncode: int32\nfclass: large_string\nname: large_string\nref: large_string\noneway: large_string\nmaxspeed: int32\nlayer: int64\nbridge: large_string\ntunnel: large_string\ngeometry: extension&lt;geoarrow.linestring&lt;LinestringType&gt;&gt;\nosm_id: [[\"4265057\",\"4265058\",\"4267607\",\"4271616\",\"4275365\",...,\"4372351\",\"4372353\",\"4374903\",\"4374905\",\"4374906\"],[\"4375793\",\"4376011\",\"4377106\",\"4377123\",\"4377209\",...,\"4493766\",\"4493790\",\"4500373\",\"4500375\",\"4516633\"],...,[\"1370367863\",\"1370367864\",\"1370367868\",\"1370367873\",\"1370367874\",...,\"1370383552\",\"1370383553\",\"1370383554\",\"1370383556\",\"1370383557\"],[\"1370383558\",\"1370383559\",\"1370383560\",\"1370383561\",\"1370383562\",...,\"1370383592\",\"1370383593\",\"1370383594\",\"1370383595\",\"1370398885\"]]\ncode: [[5114,5114,5114,5115,5122,...,5122,5152,5141,5122,5141],[5111,5111,5131,5131,5115,...,5114,5111,5152,5152,5111],...,[5153,5153,5153,5153,5153,...,5153,5153,5153,5141,5141],[5141,5153,5153,5153,5153,...,5153,5153,5153,5153,5141]]\nfclass: [[\"secondary\",\"secondary\",\"secondary\",\"tertiary\",\"residential\",...,\"residential\",\"cycleway\",\"service\",\"residential\",\"service\"],[\"motorway\",\"motorway\",\"motorway_link\",\"motorway_link\",\"tertiary\",...,\"secondary\",\"motorway\",\"cycleway\",\"cycleway\",\"motorway\"],...,[\"footway\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"service\",\"service\"],[\"service\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"footway\",\"service\"]]\nname: [[\"55th Street\",\"Fairview Avenue\",\"31st Street\",\"59th Street\",\"61st Street\",...,\"Fairmount Avenue\",null,null,\"Mochel Drive\",null],[\"Kennedy Expressway\",\"Kennedy Expressway\",null,null,\"59th Street\",...,\"Midwest Road\",\"Ronald Reagan Memorial Tollway\",\"Main Trail\",null,\"Borman Expressway\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\nref: [[null,null,null,null,null,...,null,null,null,null,null],[\"I 190\",\"I 190\",null,null,null,...,null,\"I 88;IL 110\",null,null,\"I 80;I 94;US 6\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\noneway: [[\"F\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"B\",...,\"B\",\"F\",\"B\",\"B\",\"F\"],...,[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"]]\nmaxspeed: [[0,0,72,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,96,0,0,88],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\nlayer: [[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\nbridge: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\ntunnel: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def to_geoarrow(\n    self,\n    geometry_name: str = \"geometry\",\n):\n    r\"\"\"\n    Converts the dataframe to geoarrow table.\n\n    Parameters\n    ----------\n\n    geometry_name\n        The name of the column in the dataframe that will be written as the geometry field.\n\n    Note\n    ----\n    Any rows with null geometries will be discarded.\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; from spatial_polars import read_spatial\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; df = read_spatial(my_shapefile)\n    &gt;&gt;&gt; df.spatial.to_geoarrow()\n    pyarrow.Table\n    osm_id: large_string\n    code: int32\n    fclass: large_string\n    name: large_string\n    ref: large_string\n    oneway: large_string\n    maxspeed: int32\n    layer: int64\n    bridge: large_string\n    tunnel: large_string\n    geometry: extension&lt;geoarrow.linestring&lt;LinestringType&gt;&gt;\n    osm_id: [[\"4265057\",\"4265058\",\"4267607\",\"4271616\",\"4275365\",...,\"4372351\",\"4372353\",\"4374903\",\"4374905\",\"4374906\"],[\"4375793\",\"4376011\",\"4377106\",\"4377123\",\"4377209\",...,\"4493766\",\"4493790\",\"4500373\",\"4500375\",\"4516633\"],...,[\"1370367863\",\"1370367864\",\"1370367868\",\"1370367873\",\"1370367874\",...,\"1370383552\",\"1370383553\",\"1370383554\",\"1370383556\",\"1370383557\"],[\"1370383558\",\"1370383559\",\"1370383560\",\"1370383561\",\"1370383562\",...,\"1370383592\",\"1370383593\",\"1370383594\",\"1370383595\",\"1370398885\"]]\n    code: [[5114,5114,5114,5115,5122,...,5122,5152,5141,5122,5141],[5111,5111,5131,5131,5115,...,5114,5111,5152,5152,5111],...,[5153,5153,5153,5153,5153,...,5153,5153,5153,5141,5141],[5141,5153,5153,5153,5153,...,5153,5153,5153,5153,5141]]\n    fclass: [[\"secondary\",\"secondary\",\"secondary\",\"tertiary\",\"residential\",...,\"residential\",\"cycleway\",\"service\",\"residential\",\"service\"],[\"motorway\",\"motorway\",\"motorway_link\",\"motorway_link\",\"tertiary\",...,\"secondary\",\"motorway\",\"cycleway\",\"cycleway\",\"motorway\"],...,[\"footway\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"service\",\"service\"],[\"service\",\"footway\",\"footway\",\"footway\",\"footway\",...,\"footway\",\"footway\",\"footway\",\"footway\",\"service\"]]\n    name: [[\"55th Street\",\"Fairview Avenue\",\"31st Street\",\"59th Street\",\"61st Street\",...,\"Fairmount Avenue\",null,null,\"Mochel Drive\",null],[\"Kennedy Expressway\",\"Kennedy Expressway\",null,null,\"59th Street\",...,\"Midwest Road\",\"Ronald Reagan Memorial Tollway\",\"Main Trail\",null,\"Borman Expressway\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\n    ref: [[null,null,null,null,null,...,null,null,null,null,null],[\"I 190\",\"I 190\",null,null,null,...,null,\"I 88;IL 110\",null,null,\"I 80;I 94;US 6\"],...,[null,null,null,null,null,...,null,null,null,null,null],[null,null,null,null,null,...,null,null,null,null,null]]\n    oneway: [[\"F\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"B\",...,\"B\",\"F\",\"B\",\"B\",\"F\"],...,[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\",...,\"B\",\"B\",\"B\",\"B\",\"B\"]]\n    maxspeed: [[0,0,72,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,96,0,0,88],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\n    layer: [[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0],...,[0,0,0,0,0,...,0,0,0,0,0],[0,0,0,0,0,...,0,0,0,0,0]]\n    bridge: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\n    tunnel: [[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],...,[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"],[\"F\",\"F\",\"F\",\"F\",\"F\",...,\"F\",\"F\",\"F\",\"F\",\"F\"]]\n\n    \"\"\"\n    # create pyarrow table from the dataframe without the geometry\n\n    no_null_geoms_df = self._df.filter(\n        c(geometry_name).struct.field(\"wkb_geometry\").is_not_null()\n    )\n    if len(no_null_geoms_df) != len(self._df):\n        Warning(\n            \"Dataframe contains null goemetries, rows with null geometries will be discarded.\"\n        )\n\n    pa_table = self._df.drop(geometry_name).to_arrow()\n\n    crs = pyproj.CRS(self._df[geometry_name].struct.field(\"crs\")[0]).to_wkt(\n        version=\"WKT1_GDAL\"\n    )\n\n    # create geoarrow array with crs from the geometry\n    geometries_wkb = (\n        self._df[geometry_name].struct.field(\"wkb_geometry\").to_numpy().copy()\n    )\n    geoarrow_geom_array = ga.with_crs(ga.as_geoarrow(geometries_wkb), crs)\n\n    # add the geoarrow geometry to the arrow table\n    pa_table = pa_table.append_column(geometry_name, geoarrow_geom_array)\n    return pa_table\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.join","title":"<code>join(other, how='inner', predicate='intersects', distance=None, on='geometry', left_on=None, right_on=None, suffix='_right', maintain_order='none')</code>","text":"<p>Joins two SpatialFrames based on a spatial predicate.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DataFrame</code> <p>SpatialFrame to join with.</p> required <code>how</code> <code>Literal['left', 'right', 'full', 'inner', 'semi', 'anti']</code> <p>Join strategy.</p> <ul> <li>inner     Returns rows that have matching values in both tables</li> <li>left     Returns all rows from the left table, and the matched rows from the     right table</li> <li>right     Returns all rows from the right table, and the matched rows from the     left table</li> <li>full     Returns all rows when there is a match in either left or right table</li> <li>semi     Returns rows from the left table that have a match in the right table.</li> <li>anti     Returns rows from the left table that have no match in the right table.</li> </ul> <code>'inner'</code> <code>predicate</code> <code>Literal['intersects', 'within', 'contains', 'overlaps', 'crosses', 'touches', 'covers', 'covered_by', 'contains_properly', 'dwithin']</code> <p>The predicate to use for testing geometries from the tree that are within the input geometry's bounding box. * intersects     Joins rows in the left frame to the right frame if they share any portion of space.</p> <ul> <li> <p>within     Joins rows in the left frame to the right if they are completely inside a geometry from the right frame.</p> </li> <li> <p>contains     Joins rows in the left frame to the right if the geometry from the right frame is completely inside the geometry from the left frame</p> </li> <li> <p>overlaps     Joins rows in the left frame to the right if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves.</p> </li> <li> <p>crosses     Joins rows in the left frame to the right if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension for the geomtries.</p> </li> <li> <p>touches     Joins rows in the left frame to the right if they only share points on their boundaries.</p> </li> <li> <p>covers     Joins rows in the left frame to the right if no point of the right geometry is outside of the left geometry.</p> </li> <li> <p>covered_by     Joins rows in the left frame to the right if no point of the left geometry is outside of the right geometry.</p> </li> <li> <p>contains_properly     Joins rows in the left frame to the right if the geometry from the right is completely inside the geometry from the left with no common boundary points.</p> </li> <li> <p>dwithin     Joins rows in the left frame to the right if they are within the given <code>distance</code> of one another.</p> </li> </ul> <code>'intersects'</code> <code>distance</code> <code>Optional[float]</code> <p>Distances around each input geometry to join for the <code>dwithin</code> predicate. Required if predicate=<code>dwithin</code>.</p> <code>None</code> <code>on</code> <code>str</code> <p>Name of the geometry columns in both SpatialFrames.</p> <code>'geometry'</code> <code>left_on</code> <code>Optional[str]</code> <p>Name of the geometry column in the left SpatialFrame for the spatial join.</p> <code>None</code> <code>right_on</code> <code>Optional[str]</code> <p>Name of the geometry column in the right SpatialFrame for the spatial join.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <code>maintain_order</code> <code>Literal['none', 'left', 'right', 'left_right', 'right_left']</code> <p>Which DataFrame row order to preserve, if any. Do not rely on any observed ordering without explicitly setting this parameter, as your code may break in a future release. Not specifying any ordering can improve performance Supported for inner, left, right and full joins</p> <ul> <li>none     No specific ordering is desired. The ordering might differ across     Polars versions or even between different runs.</li> <li>left     Preserves the order of the left DataFrame.</li> <li>right     Preserves the order of the right DataFrame.</li> <li>left_right     First preserves the order of the left DataFrame, then the right.</li> <li>right_left     First preserves the order of the right DataFrame, then the left.</li> </ul> <code>'none'</code> Note <p>Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.</p> <p>Examples:</p> <p>Spatial join roads that intersect rails</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from spatial_polars import scan_spatial\n&gt;&gt;&gt; zipped_data = r\"C:\\data\\illinois-latest-free.shp.zip\"\n&gt;&gt;&gt; roads_df, rails_df = pl.collect_all([\n&gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_roads_free_1\").select(\"name\", \"geometry\"),\n&gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_railways_free_1\").select(\"name\", \"geometry\")\n&gt;&gt;&gt;     ],\n&gt;&gt;&gt;     engine=\"streaming\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; roads_rails_df = roads_df.spatial.join(\n&gt;&gt;&gt;     rails_df,\n&gt;&gt;&gt;     suffix=\"_rail\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; roads_rails_df\nshape: (43_772, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 name            \u2506 geometry                 \u2506 name_rail                \u2506 geometry_rail            \u2502\n\u2502 ---             \u2506 ---                      \u2506 ---                      \u2506 ---                      \u2502\n\u2502 str             \u2506 struct[2]                \u2506 str                      \u2506 struct[2]                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n\u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n\u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00[ \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n\u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n\u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n\u2502 \u2026               \u2506 \u2026                        \u2506 \u2026                        \u2506 \u2026                        \u2502\n\u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n\u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n\u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n\u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n\u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n\u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 Matteson Subdivision     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n\u2502                 \u2506 x16\\x0\u2026                  \u2506                          \u2506 x1f\\x0\u2026                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def join(\n    self,\n    other: pl.DataFrame,\n    how: Literal[\"left\", \"right\", \"full\", \"inner\", \"semi\", \"anti\"] = \"inner\",\n    predicate: Literal[\n        \"intersects\",\n        \"within\",\n        \"contains\",\n        \"overlaps\",\n        \"crosses\",\n        \"touches\",\n        \"covers\",\n        \"covered_by\",\n        \"contains_properly\",\n        \"dwithin\",\n    ] = \"intersects\",\n    distance: Optional[float] = None,\n    on: str = \"geometry\",\n    left_on: Optional[str] = None,\n    right_on: Optional[str] = None,\n    suffix: str = \"_right\",\n    maintain_order: Literal[\n        \"none\", \"left\", \"right\", \"left_right\", \"right_left\"\n    ] = \"none\",\n) -&gt; pl.DataFrame:\n    r\"\"\"\n    Joins two SpatialFrames based on a spatial predicate.\n\n    Parameters\n    ----------\n    other\n        SpatialFrame to join with.\n\n    how\n        Join strategy.\n\n        * *inner*\n            Returns rows that have matching values in both tables\n        * *left*\n            Returns all rows from the left table, and the matched rows from the\n            right table\n        * *right*\n            Returns all rows from the right table, and the matched rows from the\n            left table\n        * *full*\n            Returns all rows when there is a match in either left or right table\n        * *semi*\n            Returns rows from the left table that have a match in the right table.\n        * *anti*\n            Returns rows from the left table that have no match in the right table.\n\n    predicate\n        The predicate to use for testing geometries from the tree that are within the input geometry's bounding box.\n        * *intersects*\n            Joins rows in the left frame to the right frame if they share any portion of space.\n\n        * *within*\n            Joins rows in the left frame to the right if they are completely inside a geometry from the right frame.\n\n        * *contains*\n            Joins rows in the left frame to the right if the geometry from the right frame is completely inside the geometry from the left frame\n\n        * *overlaps*\n            Joins rows in the left frame to the right if they have some but not all points/space in common, have the same dimension, and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves.\n\n        * *crosses*\n            Joins rows in the left frame to the right if they have some but not all interior points in common, the intersection is one dimension less than the maximum dimension for the geomtries.\n\n        * *touches*\n            Joins rows in the left frame to the right if they only share points on their boundaries.\n\n        * *covers*\n            Joins rows in the left frame to the right if no point of the right geometry is outside of the left geometry.\n\n\n        * *covered_by*\n            Joins rows in the left frame to the right if no point of the left geometry is outside of the right geometry.\n\n\n        * *contains_properly*\n            Joins rows in the left frame to the right if the geometry from the right is completely inside the geometry from the left with no common boundary points.\n\n\n        * *dwithin*\n            Joins rows in the left frame to the right if they are within the given `distance` of one another.\n\n    distance\n        Distances around each input geometry to join for the `dwithin` predicate. Required if predicate=`dwithin`.\n\n    on\n        Name of the geometry columns in both SpatialFrames.\n\n    left_on\n        Name of the geometry column in the left SpatialFrame for the spatial join.\n\n    right_on\n        Name of the geometry column in the right SpatialFrame for the spatial join.\n\n    suffix\n        Suffix to append to columns with a duplicate name.\n\n    maintain_order\n        Which DataFrame row order to preserve, if any.\n        Do not rely on any observed ordering without explicitly\n        setting this parameter, as your code may break in a future release.\n        Not specifying any ordering can improve performance\n        Supported for inner, left, right and full joins\n\n        * *none*\n            No specific ordering is desired. The ordering might differ across\n            Polars versions or even between different runs.\n        * *left*\n            Preserves the order of the left DataFrame.\n        * *right*\n            Preserves the order of the right DataFrame.\n        * *left_right*\n            First preserves the order of the left DataFrame, then the right.\n        * *right_left*\n            First preserves the order of the right DataFrame, then the left.\n\n    Note\n    ----\n    Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.\n\n    Examples\n    --------\n    **Spatial join roads that intersect rails**\n\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; from spatial_polars import scan_spatial\n    &gt;&gt;&gt; zipped_data = r\"C:\\data\\illinois-latest-free.shp.zip\"\n    &gt;&gt;&gt; roads_df, rails_df = pl.collect_all([\n    &gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_roads_free_1\").select(\"name\", \"geometry\"),\n    &gt;&gt;&gt;         scan_spatial(zipped_data, \"gis_osm_railways_free_1\").select(\"name\", \"geometry\")\n    &gt;&gt;&gt;     ],\n    &gt;&gt;&gt;     engine=\"streaming\"\n    &gt;&gt;&gt; )\n    &gt;&gt;&gt; roads_rails_df = roads_df.spatial.join(\n    &gt;&gt;&gt;     rails_df,\n    &gt;&gt;&gt;     suffix=\"_rail\"\n    &gt;&gt;&gt; )\n    &gt;&gt;&gt; roads_rails_df\n    shape: (43_772, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 name            \u2506 geometry                 \u2506 name_rail                \u2506 geometry_rail            \u2502\n    \u2502 ---             \u2506 ---                      \u2506 ---                      \u2506 ---                      \u2502\n    \u2502 str             \u2506 struct[2]                \u2506 str                      \u2506 struct[2]                \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n    \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n    \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00[ \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n    \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00Y \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n    \u2502 Kingery Highway \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00] \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 \\x00\\x\u2026                  \u2502\n    \u2502 \u2026               \u2506 \u2026                        \u2506 \u2026                        \u2506 \u2026                        \u2502\n    \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n    \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 BNSF Chicago Subdivision \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n    \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n    \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 UP Kenosha Subdivision   \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n    \u2502                 \u2506 x02\\x0\u2026                  \u2506                          \u2506 x02\\x0\u2026                  \u2502\n    \u2502 null            \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2506 Matteson Subdivision     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\ \u2502\n    \u2502                 \u2506 x16\\x0\u2026                  \u2506                          \u2506 x1f\\x0\u2026                  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if left_on is None:\n        left_on = on\n    if right_on is None:\n        right_on = on\n\n    self_geometries = self._df[left_on].spatial.to_shapely_array()\n\n    other_geometries = other[right_on].spatial.to_shapely_array()\n\n    tree_query_df = pl.DataFrame(\n        shapely.STRtree(self_geometries)\n        .query(other_geometries, predicate=predicate, distance=distance)\n        .T,\n        schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n    )\n\n    if how in [\"left\", \"right\", \"full\", \"inner\"]:\n        joined = (\n            self._df.with_row_index(\"left_index\")\n            .join(\n                tree_query_df,\n                how=how,\n                on=\"left_index\",\n                maintain_order=maintain_order,\n            )\n            .join(\n                other.with_row_index(\"right_index\"),\n                how=how,\n                on=\"right_index\",\n                suffix=suffix,\n                maintain_order=maintain_order,\n            )\n            .drop(\"right_index\", \"left_index\")\n        )\n    elif how in [\"semi\", \"anti\"]:\n        joined = (\n            self._df.with_row_index(\"left_index\")\n            .join(\n                tree_query_df,\n                how=how,\n                on=\"left_index\",\n                maintain_order=maintain_order,\n            )\n            .drop(c.left_index)\n        )\n\n    return joined\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.join_nearest","title":"<code>join_nearest(other, how='inner', max_distance=None, return_distance=False, exclusive=False, all_matches=True, on='geometry', left_on=None, right_on=None, suffix='_right', maintain_order='none')</code>","text":"<p>Joins two dataframes based on a spatial distance .</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DataFrame</code> <p>SpatialFrame to join with.</p> required <code>how</code> <code>Literal['left', 'inner']</code> <p>Join strategy.</p> <ul> <li>inner     Returns rows that have matching values in both tables</li> <li>left     Returns all rows from the left table, and the matched rows from the     right table</li> </ul> <code>'inner'</code> <code>max_distance</code> <code>Optional[float]</code> <p>The maximum distance to search around an input feature.</p> <code>None</code> <code>on</code> <code>str</code> <p>Name of the geometry columns in both SpatialFrames.</p> <code>'geometry'</code> <code>left_on</code> <code>Optional[str]</code> <p>Name of the geometry column in the left SpatialFrame for the spatial join.</p> <code>None</code> <code>right_on</code> <code>Optional[str]</code> <p>Name of the geometry column in the right SpatialFrame for the spatial join.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <code>maintain_order</code> <code>Literal['none', 'left', 'right', 'left_right', 'right_left']</code> <p>Which DataFrame row order to preserve, if any. Do not rely on any observed ordering without explicitly setting this parameter, as your code may break in a future release. Not specifying any ordering can improve performance Supported for inner, left, right and full joins</p> <ul> <li>none     No specific ordering is desired. The ordering might differ across     Polars versions or even between different runs.</li> <li>left     Preserves the order of the left DataFrame.</li> <li>right     Preserves the order of the right DataFrame.</li> <li>left_right     First preserves the order of the left DataFrame, then the right.</li> <li>right_left     First preserves the order of the right DataFrame, then the left.</li> </ul> <code>'none'</code> Note <p>Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.</p> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def join_nearest(\n    self,\n    other: pl.DataFrame,\n    how: Literal[\"left\", \"inner\"] = \"inner\",\n    max_distance: Optional[float] = None,\n    return_distance: bool = False,\n    exclusive: bool = False,\n    all_matches: bool = True,\n    on: str = \"geometry\",\n    left_on: Optional[str] = None,\n    right_on: Optional[str] = None,\n    suffix: str = \"_right\",\n    maintain_order: Literal[\n        \"none\", \"left\", \"right\", \"left_right\", \"right_left\"\n    ] = \"none\",\n) -&gt; pl.DataFrame:\n    r\"\"\"\n    Joins two dataframes based on a spatial distance .\n\n    Parameters\n    ----------\n    other\n        SpatialFrame to join with.\n\n    how\n        Join strategy.\n\n        * *inner*\n            Returns rows that have matching values in both tables\n        * *left*\n            Returns all rows from the left table, and the matched rows from the\n            right table\n\n    max_distance\n        The maximum distance to search around an input feature.\n\n    on\n        Name of the geometry columns in both SpatialFrames.\n\n    left_on\n        Name of the geometry column in the left SpatialFrame for the spatial join.\n\n    right_on\n        Name of the geometry column in the right SpatialFrame for the spatial join.\n\n    suffix\n        Suffix to append to columns with a duplicate name.\n\n    maintain_order\n        Which DataFrame row order to preserve, if any.\n        Do not rely on any observed ordering without explicitly\n        setting this parameter, as your code may break in a future release.\n        Not specifying any ordering can improve performance\n        Supported for inner, left, right and full joins\n\n        * *none*\n            No specific ordering is desired. The ordering might differ across\n            Polars versions or even between different runs.\n        * *left*\n            Preserves the order of the left DataFrame.\n        * *right*\n            Preserves the order of the right DataFrame.\n        * *left_right*\n            First preserves the order of the left DataFrame, then the right.\n        * *right_left*\n            First preserves the order of the right DataFrame, then the left.\n\n    Note\n    ----\n    Spatial joins only take into account x/y coodrdinates, any Z values present in the geometries are ignored.\n    \"\"\"\n    if left_on is None:\n        left_on = on\n    if right_on is None:\n        right_on = on\n\n    self_geometries = self._df[left_on].spatial.to_shapely_array()\n\n    other_geometries = other[right_on].spatial.to_shapely_array()\n\n    query_results = shapely.STRtree(self_geometries).query_nearest(\n        other_geometries,\n        max_distance=max_distance,\n        return_distance=return_distance,\n        exclusive=exclusive,\n        all_matches=all_matches,\n    )\n\n    if return_distance is True:\n        tree_query_df = pl.DataFrame(\n            query_results[0].T,\n            schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n        ).with_columns(pl.Series(\"distance\", query_results[1]))\n    else:\n        tree_query_df = pl.DataFrame(\n            query_results,\n            schema={\"right_index\": pl.Int64, \"left_index\": pl.Int64},\n        )\n\n    joined = (\n        self._df.with_row_index(\"left_index\")\n        .join(\n            tree_query_df,\n            how=how,\n            on=\"left_index\",\n            maintain_order=maintain_order,\n        )\n        .join(\n            other.with_row_index(\"right_index\"),\n            how=how,\n            on=\"right_index\",\n            suffix=suffix,\n            maintain_order=maintain_order,\n        )\n        .drop(\"right_index\", \"left_index\")\n    )\n\n    return joined\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.viz","title":"<code>viz(geometry_name='geometry', scatterplot_kwargs=None, path_kwargs=None, polygon_kwargs=None, map_kwargs=None)</code>","text":"<p>Visualizes the dataframe as a layer in a Lonboard map.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_name</code> <code>str</code> <p>The name of the column in the dataframe that will be use to visualize the features on the Lonboard map.</p> <code>'geometry'</code> <code>scatterplot_kwargs</code> <code>Optional[ScatterplotLayerKwargs]</code> <p>a dict of parameters to pass down to all generated ScatterplotLayers.</p> <code>None</code> <code>path_kwargs</code> <code>Optional[PathLayerKwargs]</code> <p>a dict of parameters to pass down to all generated PathLayers.</p> <code>None</code> <code>polygon_kwargs</code> <code>Optional[PolygonLayerKwargs]</code> <p>a dict of parameters to pass down to all generated PolygonLayers.</p> <code>None</code> <code>map_kwargs</code> <code>Optional[MapKwargs]</code> <p>a dict of parameters to pass down to the generated Map.</p> <code>None</code> Note <p>Any rows with null geometries will be discarded.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spatial_polars import read_spatial\n&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; df = read_spatial(my_shapefile)\n&gt;&gt;&gt; df.spatial.viz()\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def viz(\n    self,\n    geometry_name: str = \"geometry\",\n    scatterplot_kwargs: Optional[ScatterplotLayerKwargs] = None,\n    path_kwargs: Optional[PathLayerKwargs] = None,\n    polygon_kwargs: Optional[PolygonLayerKwargs] = None,\n    map_kwargs: Optional[MapKwargs] = None,\n) -&gt; Map:\n    r\"\"\"Visualizes the dataframe as a layer in a Lonboard [map][lonboard.Map].\n\n    Parameters\n    ----------\n    geometry_name\n        The name of the column in the dataframe that will be use to visualize the features on the Lonboard map.\n\n    scatterplot_kwargs\n        a dict of parameters to pass down to all generated ScatterplotLayers.\n\n    path_kwargs\n        a dict of parameters to pass down to all generated PathLayers.\n\n    polygon_kwargs\n        a dict of parameters to pass down to all generated PolygonLayers.\n\n    map_kwargs\n        a dict of parameters to pass down to the generated Map.\n\n    Note\n    ----\n    Any rows with null geometries will be discarded.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from spatial_polars import read_spatial\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; df = read_spatial(my_shapefile)\n    &gt;&gt;&gt; df.spatial.viz()\n\n    \"\"\"\n    geoarrow_table = self.to_geoarrow(geometry_name)\n\n    return viz(\n        geoarrow_table,\n        scatterplot_kwargs=scatterplot_kwargs,\n        path_kwargs=path_kwargs,\n        polygon_kwargs=polygon_kwargs,\n        map_kwargs=map_kwargs,\n    )\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.to_scatterplotlayer","title":"<code>to_scatterplotlayer(geometry_name='geometry', filled=True, fill_color=None, fill_cmap_col=None, fill_cmap_type=None, fill_cmap=None, fill_alpha=None, fill_normalize_cmap_col=True, stroked=True, line_color=None, line_cmap_col=None, line_cmap_type=None, line_cmap=None, line_alpha=None, line_normalize_cmap_col=True, line_width=1, line_width_min_pixels=1, line_width_max_pixels=None, line_width_scale=1, line_width_units='meters', radius=1, radius_max_pixels=None, radius_min_pixels=0, radius_scale=1, radius_units='meters', auto_highlight=False, highlight_color=[0, 0, 128, 128], opacity=1, pickable=True, visible=True, antialiasing=True, billboard=False)</code>","text":"<p>Makes a Lonboard ScatterplotLayer from the SpatialFrame.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_name</code> <code>str</code> <p>The name of the column in the SpatialFrame that will be used for the geometries of the points in the layer.</p> <code>'geometry'</code> <code>filled</code> <code>bool</code> <p>Draw the filled area of points.</p> <code>True</code> <code>fill_color</code> <code>Union[List, Tuple, None]</code> <p>The filled color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.</p> <code>None</code> <code>fill_cmap_col</code> <code>Optional[str]</code> <p>The name of the column in the SpatialFrame that will be used to vary the color of the points in the layer.  Only applicable if <code>fill_cmap_type</code> is not None.</p> <code>None</code> <code>fill_cmap_type</code> <code>Union[Literal['categorical', 'continuous'], None]</code> <p>The type of color map to use.  Only applicable if <code>fill_cmap_col</code> is set.</p> <code>None</code> <code>fill_cmap</code> <code>Optional[Union[Palette, Colormap, dict]]</code> <p>If <code>fill_cmap_type</code> is <code>continuous</code>, The palettable.colorbrewer.diverging colormap used to vary the color of the points in the layer. If <code>fill_cmap_type</code> is <code>categorical</code>, a dictionary of mappings of the values from <code>fill_cmap_col</code> to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in <code>fill_cmap_col</code>.</p> <code>None</code> <code>fill_alpha</code> <code>Union[float, int, NDArray[floating], None]</code> <p>The value which will be provided to the alpha chanel of the color for color map.  Only applicable if <code>fill_cmap_col</code> and <code>fill_cmap</code> are set.</p> <code>None</code> <code>fill_normalize_cmap_col</code> <code>bool</code> <p>If <code>True</code> a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's <code>apply_continuous_cmap</code> function to set the colors of the points in the layer.  If <code>False</code>, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if <code>fill_cmap_col</code> and <code>fill_cmap</code> are set and <code>fill_cmap_type</code> is <code>continuous</code>.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>The filled color of each object in the format of</p> <code>True</code> <code>line_color</code> <code>Union[List, Tuple, None]</code> <p>The outline color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.</p> <code>None</code> <code>line_cmap_col</code> <code>Optional[str]</code> <p>The name of the column in the SpatialFrame that will be used to vary the color of the point outlines in the layer.  Only applicable if <code>line_cmap_type</code> is not None.</p> <code>None</code> <code>line_cmap_type</code> <code>Union[Literal['categorical', 'continuous'], None]</code> <p>The type of color map to use.  Only applicable if <code>line_cmap_col</code> is set.</p> <code>None</code> <code>line_cmap</code> <code>Optional[Union[Palette, Colormap, dict]]</code> <p>If <code>line_cmap_type</code> is <code>continuous</code>, The palettable.colorbrewer.diverging colormap used to vary the color of the point outlines in the layer. If <code>line_cmap_type</code> is <code>categorical</code>, a dictionary of mappings of the values from <code>line_cmap_col</code> to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in <code>line_cmap_col</code>.</p> <code>None</code> <code>line_alpha</code> <code>Union[float, int, NDArray[floating], None]</code> <p>The value which will be provided to the alpha chanel of the color for color map.  Only applicable if <code>line_cmap_col</code> and <code>line_cmap</code> are set.</p> <code>None</code> <code>line_normalize_cmap_col</code> <code>bool</code> <p>If <code>True</code> a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's <code>apply_continuous_cmap</code> function to set the colors of the point outlines in the layer.  If <code>False</code>, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if <code>line_cmap_col</code> and <code>line_cmap</code> are set and <code>line_cmap_type</code> is <code>continuous</code>.</p> <code>True</code> <code>line_width</code> <code>Union[float, int, NDArray[floating], str, None]</code> <p>The width of each path, in units specified by <code>width_units</code> (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.</p> <code>1</code> <code>line_width_min_pixels</code> <code>float</code> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <code>1</code> <code>line_width_max_pixels</code> <code>Optional[float]</code> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <code>None</code> <code>line_width_scale</code> <code>float</code> <p>The path width multiplier that multiplied to all paths.</p> <code>1</code> <code>line_width_units</code> <code>Literal['meters', 'common', 'pixels']</code> <p>The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.</p> <code>'meters'</code> <code>radius</code> <code>Union[float, int, NDArray[floating], str, None]</code> <p>The radius of each object, in units specified by radius_units (default 'meters').  If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all points. If an array is provided, each value in the array will be used as the width for the path at the same row index.</p> <code>1</code> <code>radius_max_pixels</code> <code>Optional[float]</code> <p>The maximum radius in pixels. This can be used to prevent the circle from getting too big when zoomed in.</p> <code>None</code> <code>radius_min_pixels</code> <code>float</code> <p>The minimum radius in pixels. This can be used to prevent the circle from getting too small when zoomed out.</p> <code>0</code> <code>radius_scale</code> <code>float</code> <p>A global radius multiplier for all points.</p> <code>1</code> <code>radius_units</code> <code>Literal['meters', 'common', 'pixels']</code> <p>The units of the radius, one of 'meters', 'common', and 'pixels'</p> <code>'meters'</code> <code>auto_highlight</code> <code>bool</code> <p>When <code>True</code>, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires <code>pickable</code> to be <code>True</code>.</p> <code>False</code> <code>highlight_color</code> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight</code>=<code>True</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <code>[0, 0, 128, 128]</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether the layer responds to mouse pointer picking events. This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance. Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list. In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <code>True</code> <code>antialiasing</code> <code>bool</code> <p>If True, circles are rendered with smoothed edges. If False, circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles.</p> <code>True</code> <code>billboard</code> <code>bool</code> <p>If True, rendered circles always face the camera. If False circles face up (i.e. are parallel with the ground plane).</p> <code>False</code> Note <p>Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.</p> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def to_scatterplotlayer(\n    self,\n    geometry_name: str = \"geometry\",\n    filled: bool = True,\n    fill_color: Union[List, Tuple, None] = None,\n    fill_cmap_col: Optional[str] = None,\n    fill_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n    fill_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n    fill_alpha: Union[float, int, NDArray[floating], None] = None,\n    fill_normalize_cmap_col: bool = True,\n    stroked: bool = True,\n    line_color: Union[List, Tuple, None] = None,\n    line_cmap_col: Optional[str] = None,\n    line_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n    line_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n    line_alpha: Union[float, int, NDArray[floating], None] = None,\n    line_normalize_cmap_col: bool = True,\n    line_width: Union[float, int, NDArray[floating], str, None] = 1,\n    line_width_min_pixels: float = 1,\n    line_width_max_pixels: Optional[float] = None,\n    line_width_scale: float = 1,\n    line_width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n    radius: Union[float, int, NDArray[floating], str, None] = 1,\n    radius_max_pixels: Optional[float] = None,\n    radius_min_pixels: float = 0,\n    radius_scale: float = 1,\n    radius_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n    auto_highlight: bool = False,\n    highlight_color=[0, 0, 128, 128],\n    opacity: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    antialiasing: bool = True,\n    billboard: bool = False,\n) -&gt; ScatterplotLayer:\n    \"\"\"\n    Makes a Lonboard [ScatterplotLayer][lonboard.ScatterplotLayer] from the SpatialFrame.\n\n    Parameters\n    ----------\n    geometry_name\n        The name of the column in the SpatialFrame that will be used for the geometries of the points in the layer.\n\n    filled\n        Draw the filled area of points.\n\n    fill_color\n        The filled color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n    fill_cmap_col\n        The name of the column in the SpatialFrame that will be used to vary the color of the points in the layer.  Only applicable if `fill_cmap_type` is not None.\n\n    fill_cmap_type\n        The type of color map to use.  Only applicable if `fill_cmap_col` is set.\n\n    fill_cmap\n        If `fill_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the points in the layer.\n        If `fill_cmap_type` is `categorical`, a dictionary of mappings of the values from `fill_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `fill_cmap_col`.\n\n    fill_alpha\n        The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `fill_cmap_col` and `fill_cmap` are set.\n\n    fill_normalize_cmap_col\n        If `True` a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the points in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `fill_cmap_col` and `fill_cmap` are set and `fill_cmap_type` is `continuous`.\n\n    stroked\n        The filled color of each object in the format of\n\n    line_color\n        The outline color of each object in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n    line_cmap_col\n        The name of the column in the SpatialFrame that will be used to vary the color of the point outlines in the layer.  Only applicable if `line_cmap_type` is not None.\n\n    line_cmap_type\n        The type of color map to use.  Only applicable if `line_cmap_col` is set.\n\n    line_cmap\n        If `line_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the point outlines in the layer.\n        If `line_cmap_type` is `categorical`, a dictionary of mappings of the values from `line_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `line_cmap_col`.\n\n    line_alpha\n        The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `line_cmap_col` and `line_cmap` are set.\n\n    line_normalize_cmap_col\n        If `True` a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the point outlines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `line_cmap_col` and `line_cmap` are set and `line_cmap_type` is `continuous`.\n\n    line_width\n        The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n    line_width_min_pixels\n        The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n    line_width_max_pixels\n        The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n    line_width_scale\n        The path width multiplier that multiplied to all paths.\n\n    line_width_units\n        The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n    radius\n        The radius of each object, in units specified by radius_units (default 'meters').  If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all points. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n    radius_max_pixels\n        The maximum radius in pixels. This can be used to prevent the circle from getting too big when zoomed in.\n\n    radius_min_pixels\n        The minimum radius in pixels. This can be used to prevent the circle from getting too small when zoomed out.\n\n    radius_scale\n        A global radius multiplier for all points.\n\n    radius_units\n        The units of the radius, one of 'meters', 'common', and 'pixels'\n\n    auto_highlight\n        When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n    highlight_color\n        RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n    opacity\n        The opacity of the layer.\n\n    pickable\n        Whether the layer responds to mouse pointer picking events.\n        This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n        Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n    visible\n        Whether the layer is visible.\n        Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n        In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n    antialiasing\n        If True, circles are rendered with smoothed edges. If False, circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles.\n\n    billboard\n        If True, rendered circles always face the camera. If False circles face up (i.e. are parallel with the ground plane).\n\n    Note\n    ----\n    Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n\n    \"\"\"\n    validate_cmap_input(\n        self._df,\n        fill_cmap_col,\n        fill_cmap_type,\n        fill_cmap,\n        fill_alpha,\n        fill_normalize_cmap_col,\n    )\n    validate_cmap_input(\n        self._df,\n        line_cmap_col,\n        line_cmap_type,\n        line_cmap,\n        line_alpha,\n        line_normalize_cmap_col,\n    )\n    validate_width_and_radius_input(self._df, line_width)\n    validate_width_and_radius_input(self._df, radius)\n\n    if fill_cmap_col is not None:\n        if fill_cmap_type == \"continuous\":\n            if fill_normalize_cmap_col:\n                norm_arr = (\n                    self._df.select(c(fill_cmap_col).spatial.min_max())\n                    .to_series()\n                    .to_numpy()\n                )\n            else:\n                norm_arr = self._df.select(c(fill_cmap_col)).to_series().to_numpy()\n            fill_color = apply_continuous_cmap(\n                norm_arr, fill_cmap, alpha=fill_alpha\n            )\n        elif fill_cmap_type == \"categorical\":\n            cat_arr = self._df.select(c(fill_cmap_col)).to_series().to_arrow()\n\n            if fill_cmap is None:\n                fill_cmap = {}\n                for cat in self._df[fill_cmap_col].unique():\n                    fill_cmap[cat] = [\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                    ]\n\n            fill_color = apply_categorical_cmap(\n                cat_arr, fill_cmap, alpha=fill_alpha\n            )\n\n    if line_cmap_col is not None:\n        if line_cmap_type == \"continuous\":\n            if line_normalize_cmap_col:\n                norm_arr = (\n                    self._df.select(c(line_cmap_col).spatial.min_max())\n                    .to_series()\n                    .to_numpy()\n                )\n            else:\n                norm_arr = self._df.select(c(line_cmap_col)).to_series().to_numpy()\n            line_color = apply_continuous_cmap(\n                norm_arr, line_cmap, alpha=line_alpha\n            )\n        elif line_cmap_type == \"categorical\":\n            cat_arr = self._df.select(c(line_cmap_col)).to_series().to_arrow()\n\n            if line_cmap is None:\n                line_cmap = {}\n                for cat in self._df[line_cmap_col].unique():\n                    line_cmap[cat] = [\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                    ]\n\n            line_color = apply_categorical_cmap(\n                cat_arr, line_cmap, alpha=line_alpha\n            )\n\n    if isinstance(line_width, str):\n        line_width = self._df.select(c(line_width)).to_series().to_numpy()\n\n    if isinstance(radius, str):\n        radius = self._df.select(c(radius)).to_series().to_numpy()\n\n    geoarrow_table = self.to_geoarrow(geometry_name)\n\n    layer = ScatterplotLayer(\n        table=geoarrow_table,\n        antialiasing=antialiasing,\n        auto_highlight=auto_highlight,\n        billboard=billboard,\n        filled=filled,\n        get_fill_color=fill_color,\n        get_line_color=line_color,\n        get_line_width=line_width,\n        get_radius=radius,\n        highlight_color=highlight_color,\n        line_width_max_pixels=line_width_max_pixels,\n        line_width_min_pixels=line_width_min_pixels,\n        line_width_scale=line_width_scale,\n        line_width_units=line_width_units,\n        opacity=opacity,\n        pickable=pickable,\n        radius_max_pixels=radius_max_pixels,\n        radius_min_pixels=radius_min_pixels,\n        radius_scale=radius_scale,\n        radius_units=radius_units,\n        stroked=stroked,\n        visible=visible,\n    )\n    return layer\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.to_pathlayer","title":"<code>to_pathlayer(geometry_name='geometry', color=None, cmap_col=None, cmap_type=None, cmap=None, alpha=None, normalize_cmap_col=True, width=1, auto_highlight=False, billboard=False, cap_rounded=False, highlight_color=[0, 0, 128, 128], joint_rounded=False, miter_limit=4, opacity=1, pickable=True, visible=True, width_min_pixels=1, width_max_pixels=None, width_scale=1, width_units='meters')</code>","text":"<p>Makes a Lonboard PathLayer from the SpatialFrame.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_name</code> <code>str</code> <p>The name of the column in the SpatialFrame that will be used for the geometries of the paths in the layer.</p> <code>'geometry'</code> <code>color</code> <code>Union[List, Tuple, None]</code> <p>The color for every path in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.</p> <code>None</code> <code>cmap_col</code> <code>Optional[str]</code> <p>The name of the column in the SpatialFrame that will be used to vary the color of the paths in the layer.  Only applicable if <code>cmap_type</code> is not None.</p> <code>None</code> <code>cmap_type</code> <code>Union[Literal['categorical', 'continuous'], None]</code> <p>The type of color map to use.  Only applicable if <code>cmap_col</code> is set.</p> <code>None</code> <code>cmap</code> <code>Optional[Union[Palette, Colormap, dict]]</code> <p>If <code>cmap_type</code> is <code>continuous</code>, The palettable.colorbrewer.diverging colormap used to vary the color of the lines in the layer. If <code>cmap_type</code> is <code>categorical</code>, a dictionary of mappings of the values from <code>cmap_col</code> to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in <code>cmap_col</code>.</p> <code>None</code> <code>alpha</code> <code>Union[float, int, NDArray[floating], None]</code> <p>The value which will be provided to the alpha chanel of the color for color map.  Only applicable if <code>c_map_col</code> and <code>cmap</code> are set.</p> <code>None</code> <code>normalize_cmap_col</code> <code>bool</code> <p>If <code>True</code> a copy of the values in cmap_col will be normalized to be between 0-1 for use by Lonboard's <code>apply_continuous_cmap</code> function to set the colors of the lines in the layer.  If <code>False</code>, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if <code>c_map_col</code> and <code>cmap</code> are set and <code>cmap_type</code> is <code>continuous</code>.</p> <code>True</code> <code>width</code> <code>Union[float, int, NDArray[floating], str, None]</code> <p>The width of each path, in units specified by <code>width_units</code> (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether the layer responds to mouse pointer picking events. This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance. Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <code>True</code> <code>auto_highlight</code> <code>bool</code> <p>When <code>True</code>, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires <code>pickable</code> to be <code>True</code>.</p> <code>False</code> <code>highlight_color</code> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight</code>=<code>True</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <code>[0, 0, 128, 128]</code> <code>billboard</code> <code>bool</code> <p>If <code>True</code>, extrude the path in screen space (width always faces the camera). If <code>False</code>, the width always faces up.</p> <code>False</code> <code>cap_rounded</code> <code>bool</code> <p>Type of caps. If <code>True</code>, draw round caps. Otherwise draw square caps.</p> <code>False</code> <code>joint_rounded</code> <code>bool</code> <p>Type of joint. If <code>True</code>, draw round joints. Otherwise draw miter joints.</p> <code>False</code> <code>miter_limit</code> <code>float</code> <p>The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is <code>False</code>.</p> <code>4</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer.</p> <code>1</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list. In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <code>True</code> <code>width_min_pixels</code> <code>float</code> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <code>1</code> <code>width_max_pixels</code> <code>Optional[float]</code> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <code>None</code> <code>width_scale</code> <code>float</code> <p>The path width multiplier that multiplied to all paths.</p> <code>1</code> <code>width_units</code> <code>Literal['meters', 'common', 'pixels']</code> <p>The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.</p> <code>'meters'</code> Note <p>Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.</p> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def to_pathlayer(\n    self,\n    geometry_name: str = \"geometry\",\n    color: Union[List, Tuple, None] = None,\n    cmap_col: Optional[str] = None,\n    cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n    cmap: Optional[Union[Palette, Colormap, dict]] = None,\n    alpha: Union[float, int, NDArray[floating], None] = None,\n    normalize_cmap_col: bool = True,\n    width: Union[float, int, NDArray[floating], str, None] = 1,\n    auto_highlight: bool = False,\n    billboard: bool = False,\n    cap_rounded: bool = False,\n    highlight_color=[0, 0, 128, 128],\n    joint_rounded: bool = False,\n    miter_limit: float = 4,\n    opacity: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    width_min_pixels: float = 1,\n    width_max_pixels: Optional[float] = None,\n    width_scale: float = 1,\n    width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n) -&gt; PathLayer:\n    \"\"\"\n    Makes a Lonboard [PathLayer][lonboard.PathLayer] from the SpatialFrame.\n\n    Parameters\n    ----------\n    geometry_name\n        The name of the column in the SpatialFrame that will be used for the geometries of the paths in the layer.\n\n    color\n        The color for every path in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n    cmap_col\n        The name of the column in the SpatialFrame that will be used to vary the color of the paths in the layer.  Only applicable if `cmap_type` is not None.\n\n    cmap_type\n        The type of color map to use.  Only applicable if `cmap_col` is set.\n\n    cmap\n        If `cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the lines in the layer.\n        If `cmap_type` is `categorical`, a dictionary of mappings of the values from `cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `cmap_col`.\n\n    alpha\n        The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `c_map_col` and `cmap` are set.\n\n    normalize_cmap_col\n        If `True` a copy of the values in cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the lines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `c_map_col` and `cmap` are set and `cmap_type` is `continuous`.\n\n    width\n        The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n    pickable\n        Whether the layer responds to mouse pointer picking events.\n        This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n        Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n    auto_highlight\n        When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n    highlight_color\n        RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n    billboard\n        If `True`, extrude the path in screen space (width always faces the camera). If `False`, the width always faces up.\n\n    cap_rounded\n        Type of caps. If `True`, draw round caps. Otherwise draw square caps.\n\n    joint_rounded\n        Type of joint. If `True`, draw round joints. Otherwise draw miter joints.\n\n    miter_limit\n        The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is `False`.\n\n    opacity\n        The opacity of the layer.\n\n    visible\n        Whether the layer is visible.\n        Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n        In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n    width_min_pixels\n        The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n    width_max_pixels\n        The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n    width_scale\n        The path width multiplier that multiplied to all paths.\n\n    width_units\n        The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n    Note\n    ----\n    Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n\n    \"\"\"\n    validate_cmap_input(\n        self._df, cmap_col, cmap_type, cmap, alpha, normalize_cmap_col\n    )\n    validate_width_and_radius_input(self._df, width)\n\n    if cmap_col is not None:\n        if cmap_type == \"continuous\":\n            if normalize_cmap_col:\n                norm_arr = (\n                    self._df.select(c(cmap_col).spatial.min_max())\n                    .to_series()\n                    .to_numpy()\n                )\n            else:\n                norm_arr = self._df.select(c(cmap_col)).to_series().to_numpy()\n            color = apply_continuous_cmap(norm_arr, cmap, alpha=alpha)\n        elif cmap_type == \"categorical\":\n            cat_arr = self._df.select(c(cmap_col)).to_series().to_arrow()\n\n            if cmap is None:\n                cmap = {}\n                for cat in self._df[cmap_col].unique():\n                    cmap[cat] = [\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                    ]\n\n            color = apply_categorical_cmap(cat_arr, cmap, alpha=alpha)\n\n    if isinstance(width, str):\n        width = self._df.select(c(width)).to_series().to_numpy()\n\n    geoarrow_table = self.to_geoarrow(geometry_name)\n\n    layer = PathLayer(\n        table=geoarrow_table,\n        auto_highlight=auto_highlight,\n        billboard=billboard,\n        cap_rounded=cap_rounded,\n        get_width=width,\n        highlight_color=highlight_color,\n        joint_rounded=joint_rounded,\n        miter_limit=miter_limit,\n        opacity=opacity,\n        pickable=pickable,\n        visible=visible,\n        get_color=color,\n        width_min_pixels=width_min_pixels,\n        width_max_pixels=width_max_pixels,\n        width_scale=width_scale,\n        width_units=width_units,\n    )\n    return layer\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.to_polygonlayer","title":"<code>to_polygonlayer(geometry_name='geometry', filled=True, fill_color=None, fill_cmap_col=None, fill_cmap_type=None, fill_cmap=None, fill_alpha=None, fill_normalize_cmap_col=True, stroked=True, line_color=None, line_cmap_col=None, line_cmap_type=None, line_cmap=None, line_alpha=None, line_normalize_cmap_col=True, line_width=1, line_joint_rounded=False, line_miter_limit=4, line_width_min_pixels=1, line_width_max_pixels=None, line_width_scale=1, line_width_units='meters', elevation=None, elevation_scale=1, auto_highlight=False, highlight_color=[0, 0, 128, 128], opacity=1, pickable=True, visible=True, wireframe=False)</code>","text":"<p>Makes a Lonboard PolygonLayer from the SpatialFrame.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_name</code> <code>str</code> <p>The name of the column in the SpatialFrame that will be used for the geometries of the polygons in the layer.</p> <code>'geometry'</code> <code>filled</code> <code>bool</code> <p>Whether to draw a filled polygon (solid fill).  Note that only the area between the outer polygon and any holes will be filled.</p> <code>True</code> <code>fill_color</code> <code>Union[List, Tuple, None]</code> <p>The fill color for every polygon in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.</p> <code>None</code> <code>fill_cmap_col</code> <code>Optional[str]</code> <p>The name of the column in the SpatialFrame that will be used to vary the color of the polygons in the layer.  Only applicable if <code>fill_cmap_type</code> is not None.</p> <code>None</code> <code>fill_cmap_type</code> <code>Union[Literal['categorical', 'continuous'], None]</code> <p>The type of color map to use.  Only applicable if <code>fill_cmap_col</code> is set.</p> <code>None</code> <code>fill_cmap</code> <code>Optional[Union[Palette, Colormap, dict]]</code> <p>If <code>fill_cmap_type</code> is <code>continuous</code>, The palettable.colorbrewer.diverging colormap used to vary the color of the polygons in the layer. If <code>fill_cmap_type</code> is <code>categorical</code>, a dictionary of mappings of the values from <code>fill_cmap_col</code> to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in <code>fill_cmap_col</code>.</p> <code>None</code> <code>fill_alpha</code> <code>Union[float, int, NDArray[floating], None]</code> <p>The value which will be provided to the alpha chanel of the color for color map.  Only applicable if <code>fill_cmap_col</code> and <code>fill_cmap</code> are set.</p> <code>None</code> <code>fill_normalize_cmap_col</code> <code>bool</code> <p>If <code>True</code> a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's <code>apply_continuous_cmap</code> function to set the colors of the polygons in the layer.  If <code>False</code>, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if <code>fill_cmap_col</code> and <code>fill_cmap</code> are set and <code>fill_cmap_type</code> is <code>continuous</code>.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw an outline around the polygon (solid fill).  Note that both the outer polygon as well the outlines of any holes will be drawn.</p> <code>True</code> <code>line_color</code> <code>Union[List, Tuple, None]</code> <p>The color for every polygon outline in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.</p> <code>None</code> <code>line_cmap_col</code> <code>Optional[str]</code> <p>The name of the column in the SpatialFrame that will be used to vary the color of the polygon outlines in the layer.  Only applicable if <code>line_cmap_type</code> is not None.</p> <code>None</code> <code>line_cmap_type</code> <code>Union[Literal['categorical', 'continuous'], None]</code> <p>The type of color map to use.  Only applicable if <code>line_cmap_col</code> is set.</p> <code>None</code> <code>line_cmap</code> <code>Optional[Union[Palette, Colormap, dict]]</code> <p>If <code>line_cmap_type</code> is <code>continuous</code>, The palettable.colorbrewer.diverging colormap used to vary the color of the polygon outlines in the layer. If <code>line_cmap_type</code> is <code>categorical</code>, a dictionary of mappings of the values from <code>line_cmap_col</code> to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in <code>line_cmap_col</code>.</p> <code>None</code> <code>line_alpha</code> <code>Union[float, int, NDArray[floating], None]</code> <p>The value which will be provided to the alpha chanel of the color for color map.  Only applicable if <code>line_cmap_col</code> and <code>line_cmap</code> are set.</p> <code>None</code> <code>line_normalize_cmap_col</code> <code>bool</code> <p>If <code>True</code> a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's <code>apply_continuous_cmap</code> function to set the colors of the polygon outlines in the layer.  If <code>False</code>, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if <code>line_cmap_col</code> and <code>line_cmap</code> are set and <code>line_cmap_type</code> is <code>continuous</code>.</p> <code>True</code> <code>line_width</code> <code>Union[float, int, NDArray[floating], str, None]</code> <p>The width of each path, in units specified by <code>width_units</code> (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.</p> <code>1</code> <code>line_joint_rounded</code> <code>bool</code> <p>Type of joint. If <code>True</code>, draw round joints. Otherwise draw miter joints.</p> <code>False</code> <code>line_miter_limit</code> <code>float</code> <p>The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is <code>False</code>.</p> <code>4</code> <code>line_width_min_pixels</code> <code>float</code> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <code>1</code> <code>line_width_max_pixels</code> <code>Optional[float]</code> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <code>None</code> <code>line_width_scale</code> <code>float</code> <p>The path width multiplier that multiplied to all paths.</p> <code>1</code> <code>line_width_units</code> <code>Literal['meters', 'common', 'pixels']</code> <p>The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.</p> <code>'meters'</code> <code>elevation</code> <code>Union[float, int, NDArray[floating], str, None]</code> <p>The elevation to extrude each polygon with, in meters.  Only applies if extruded=True.  If a number is provided, it is used as the width for all polygons.  If an array is provided, each value in the array will be used as the width for the polygon at the same row index.  If a string is provided it will be used as a column name in the frame to use for the elevation. Providing a value to elevation will set <code>extruded=True</code> on the layer.</p> <code>None</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier. The final elevation is calculated by elevation_scale * elevation(d). <code>elevation_scale</code> is a handy property to scale all elevation without updating the data.</p> <code>1</code> <code>auto_highlight</code> <code>bool</code> <p>When <code>True</code>, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires <code>pickable</code> to be <code>True</code>.</p> <code>False</code> <code>highlight_color</code> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight</code>=<code>True</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <code>[0, 0, 128, 128]</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether the layer responds to mouse pointer picking events. This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance. Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list. In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <code>True</code> <code>wireframe</code> <code>bool</code> <p>Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.</p> <code>False</code> Note <p>Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.</p> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>def to_polygonlayer(\n    self,\n    geometry_name: str = \"geometry\",\n    filled: bool = True,\n    fill_color: Union[List, Tuple, None] = None,\n    fill_cmap_col: Optional[str] = None,\n    fill_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n    fill_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n    fill_alpha: Union[float, int, NDArray[floating], None] = None,\n    fill_normalize_cmap_col: bool = True,\n    stroked: bool = True,\n    line_color: Union[List, Tuple, None] = None,\n    line_cmap_col: Optional[str] = None,\n    line_cmap_type: Union[Literal[\"categorical\", \"continuous\"], None] = None,\n    line_cmap: Optional[Union[Palette, Colormap, dict]] = None,\n    line_alpha: Union[float, int, NDArray[floating], None] = None,\n    line_normalize_cmap_col: bool = True,\n    line_width: Union[float, int, NDArray[floating], str, None] = 1,\n    line_joint_rounded: bool = False,\n    line_miter_limit: float = 4,\n    line_width_min_pixels: float = 1,\n    line_width_max_pixels: Optional[float] = None,\n    line_width_scale: float = 1,\n    line_width_units: Literal[\"meters\", \"common\", \"pixels\"] = \"meters\",\n    elevation: Union[float, int, NDArray[floating], str, None] = None,\n    elevation_scale: float = 1,\n    auto_highlight: bool = False,\n    highlight_color=[0, 0, 128, 128],\n    opacity: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    wireframe: bool = False,\n) -&gt; PolygonLayer:\n    \"\"\"\n    Makes a Lonboard [PolygonLayer][lonboard.PolygonLayer] from the SpatialFrame.\n\n    Parameters\n    ----------\n    geometry_name\n        The name of the column in the SpatialFrame that will be used for the geometries of the polygons in the layer.\n\n    filled\n        Whether to draw a filled polygon (solid fill).  Note that only the area between the outer polygon and any holes will be filled.\n\n    fill_color\n        The fill color for every polygon in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n    fill_cmap_col\n        The name of the column in the SpatialFrame that will be used to vary the color of the polygons in the layer.  Only applicable if `fill_cmap_type` is not None.\n\n    fill_cmap_type\n        The type of color map to use.  Only applicable if `fill_cmap_col` is set.\n\n    fill_cmap\n        If `fill_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the polygons in the layer.\n        If `fill_cmap_type` is `categorical`, a dictionary of mappings of the values from `fill_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `fill_cmap_col`.\n\n    fill_alpha\n        The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `fill_cmap_col` and `fill_cmap` are set.\n\n    fill_normalize_cmap_col\n        If `True` a copy of the values in fill_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the polygons in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `fill_cmap_col` and `fill_cmap` are set and `fill_cmap_type` is `continuous`.\n\n    stroked\n        Whether to draw an outline around the polygon (solid fill).  Note that both the outer polygon as well the outlines of any holes will be drawn.\n\n    line_color\n        The color for every polygon outline in the format of [r, g, b, [a]]. Each channel is a number between 0-255 and a is 255 if not supplied.\n\n    line_cmap_col\n        The name of the column in the SpatialFrame that will be used to vary the color of the polygon outlines in the layer.  Only applicable if `line_cmap_type` is not None.\n\n    line_cmap_type\n        The type of color map to use.  Only applicable if `line_cmap_col` is set.\n\n    line_cmap\n        If `line_cmap_type` is `continuous`, The palettable.colorbrewer.diverging colormap used to vary the color of the polygon outlines in the layer.\n        If `line_cmap_type` is `categorical`, a dictionary of mappings of the values from `line_cmap_col` to a list of of [r, g, b] color codes, or None. If None, random colors will be selected for each value in `line_cmap_col`.\n\n    line_alpha\n        The value which will be provided to the alpha chanel of the color for color map.  Only applicable if `line_cmap_col` and `line_cmap` are set.\n\n    line_normalize_cmap_col\n        If `True` a copy of the values in line_cmap_col will be normalized to be between 0-1 for use by Lonboard's `apply_continuous_cmap` function to set the colors of the polygon outlines in the layer.  If `False`, the values in the column are assumed to already be between 0-1 and do not need to be normalized. Only applicable if `line_cmap_col` and `line_cmap` are set and `line_cmap_type` is `continuous`.\n\n    line_width\n        The width of each path, in units specified by `width_units` (default 'meters'). If a string is provided, the values from the SpatialFrame in the column with the name will be used.  If a number is provided, it is used as the width for all paths. If an array is provided, each value in the array will be used as the width for the path at the same row index.\n\n    line_joint_rounded\n        Type of joint. If `True`, draw round joints. Otherwise draw miter joints.\n\n    line_miter_limit\n        The maximum extent of a joint in ratio to the stroke width. Only works if jointRounded is `False`.\n\n    line_width_min_pixels\n        The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n\n    line_width_max_pixels\n        The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n\n    line_width_scale\n        The path width multiplier that multiplied to all paths.\n\n    line_width_units\n        The units of the line width, one of 'meters', 'common', and 'pixels'. See unit system.\n\n    elevation\n        The elevation to extrude each polygon with, in meters.  Only applies if extruded=True.  If a number is provided, it is used as the width for all polygons.  If an array is provided, each value in the array will be used as the width for the polygon at the same row index.  If a string is provided it will be used as a column name in the frame to use for the elevation.\n        Providing a value to elevation will set `extruded=True` on the layer.\n\n    elevation_scale\n        Elevation multiplier. The final elevation is calculated by elevation_scale * elevation(d). `elevation_scale` is a handy property to scale all elevation without updating the data.\n\n    auto_highlight\n        When `True`, the current object pointed to by the mouse pointer (when hovered over) is highlighted with highlightColor.  Requires `pickable` to be `True`.\n\n    highlight_color\n        RGBA color to blend with the highlighted object (the hovered over object if `auto_highlight`=`True`). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.\n\n    opacity\n        The opacity of the layer.\n\n    pickable\n        Whether the layer responds to mouse pointer picking events.\n        This must be set to `True` for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.\n        Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to `False`.\n\n    visible\n        Whether the layer is visible.\n        Under most circumstances, using the `visible` attribute to control the visibility of layers is recommended over removing/adding the layer from the `Map.layers` list.\n        In particular, toggling the `visible` attribute will persist the layer on the JavaScript side, while removing/adding the layer from the `Map.layers` list will re-download and re-render from scratch.\n\n    wireframe\n        Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.\n\n    Note\n    ----\n    Implementation varies slightly from Lonboard for the setting of color and width to make it easy to use from the SpatialFrame.\n\n    \"\"\"\n    validate_cmap_input(\n        self._df,\n        fill_cmap_col,\n        fill_cmap_type,\n        fill_cmap,\n        fill_alpha,\n        fill_normalize_cmap_col,\n    )\n    validate_cmap_input(\n        self._df,\n        line_cmap_col,\n        line_cmap_type,\n        line_cmap,\n        line_alpha,\n        line_normalize_cmap_col,\n    )\n    validate_width_and_radius_input(self._df, line_width)\n\n    if fill_cmap_col is not None:\n        if fill_cmap_type == \"continuous\":\n            if fill_normalize_cmap_col:\n                norm_arr = (\n                    self._df.select(c(fill_cmap_col).spatial.min_max())\n                    .to_series()\n                    .to_numpy()\n                )\n            else:\n                norm_arr = self._df.select(c(fill_cmap_col)).to_series().to_numpy()\n            fill_color = apply_continuous_cmap(\n                norm_arr, fill_cmap, alpha=fill_alpha\n            )\n        elif fill_cmap_type == \"categorical\":\n            cat_arr = self._df.select(c(fill_cmap_col)).to_series().to_arrow()\n\n            if fill_cmap is None:\n                fill_cmap = {}\n                for cat in self._df[fill_cmap_col].unique():\n                    fill_cmap[cat] = [\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                    ]\n\n            fill_color = apply_categorical_cmap(\n                cat_arr, fill_cmap, alpha=fill_alpha\n            )\n\n    if line_cmap_col is not None:\n        if line_cmap_type == \"continuous\":\n            if line_normalize_cmap_col:\n                norm_arr = (\n                    self._df.select(c(line_cmap_col).spatial.min_max())\n                    .to_series()\n                    .to_numpy()\n                )\n            else:\n                norm_arr = self._df.select(c(line_cmap_col)).to_series().to_numpy()\n            line_color = apply_continuous_cmap(\n                norm_arr, line_cmap, alpha=line_alpha\n            )\n        elif line_cmap_type == \"categorical\":\n            cat_arr = self._df.select(c(line_cmap_col)).to_series().to_arrow()\n\n            if line_cmap is None:\n                line_cmap = {}\n                for cat in self._df[line_cmap_col].unique():\n                    line_cmap[cat] = [\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                        random.randint(0, 255),\n                    ]\n\n            line_color = apply_categorical_cmap(\n                cat_arr, line_cmap, alpha=line_alpha\n            )\n\n    if isinstance(line_width, str):\n        line_width = self._df.select(c(line_width)).to_series().to_numpy()\n\n    extruded = False\n    if elevation is not None:\n        extruded = True\n    if isinstance(elevation, str):\n        elevation = self._df.select(c(elevation)).to_series().to_numpy()\n\n    geoarrow_table = self.to_geoarrow(geometry_name)\n\n    layer = PolygonLayer(\n        table=geoarrow_table,\n        auto_highlight=auto_highlight,\n        elevation_scale=elevation_scale,\n        extruded=extruded,\n        filled=filled,\n        get_elevation=elevation,\n        get_fill_color=fill_color,\n        get_line_color=line_color,\n        get_line_width=line_width,\n        highlight_color=highlight_color,\n        line_joint_rounded=line_joint_rounded,\n        line_miter_limit=line_miter_limit,\n        line_width_max_pixels=line_width_max_pixels,\n        line_width_min_pixels=line_width_min_pixels,\n        line_width_scale=line_width_scale,\n        line_width_units=line_width_units,\n        opacity=opacity,\n        pickable=pickable,\n        stroked=stroked,\n        visible=visible,\n        wireframe=wireframe,\n    )\n    return layer\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.from_point_coords","title":"<code>from_point_coords(df, x_col, y_col, z_col=None, crs=4326)</code>  <code>staticmethod</code>","text":"<p>Creates a SpatialFrame from a polars DataFrame with x/y/(z) columns.</p> <p>Parameters:</p> Name Type Description Default <code>x_col</code> <code>str</code> <p>The name of the column in the DataFrame which holds the X coordinates.</p> required <code>y_col</code> <code>str</code> <p>The name of the column in the DataFrame which holds the Y coordinates.</p> required <code>z_col</code> <code>Optional[str]</code> <p>The name of the column in the DataFrame which holds the Z coordinates.</p> <code>None</code> <code>crs</code> <code>Any</code> <p>A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.</p> <p>PROJ string</p> <p>Dictionary of PROJ parameters</p> <p>PROJ keyword arguments for parameters</p> <p>JSON string with PROJ parameters</p> <p>CRS WKT string</p> <p>An authority string [i.e. \u2018epsg:4326\u2019]</p> <p>An EPSG integer code [i.e. 4326]</p> <p>A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]</p> <p>An object with a to_wkt method.</p> <p>A pyproj.crs.CRS class</p> <code>4326</code> <p>Examples:</p> <p>Creating a SpatialFrame from a polars df with a columns of coordinates of points .</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from spatial_polars import SpatialFrame\n&gt;&gt;&gt; df = pl.DataFrame({\n&gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n&gt;&gt;&gt;     \"x\":[-90.18497, -90.06211],\n&gt;&gt;&gt;     \"y\":[38.62456, 38.66072],\n&gt;&gt;&gt;     \"z\":[0,0]\n&gt;&gt;&gt; })\n&gt;&gt;&gt; s_df = SpatialFrame.from_point_coords(df, \"x\", \"y\", \"z\")\n&gt;&gt;&gt; s_df\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>@staticmethod\ndef from_point_coords(\n    df, x_col: str, y_col: str, z_col: Optional[str] = None, crs: Any = 4326\n):\n    r\"\"\"\n    Creates a SpatialFrame from a polars DataFrame with x/y/(z) columns.\n\n    Parameters\n    ----------\n\n    x_col\n        The name of the column in the DataFrame which holds the X coordinates.\n\n    y_col\n        The name of the column in the DataFrame which holds the Y coordinates.\n\n    z_col\n        The name of the column in the DataFrame which holds the Z coordinates.\n\n    crs\n        A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n        PROJ string\n\n        Dictionary of PROJ parameters\n\n        PROJ keyword arguments for parameters\n\n        JSON string with PROJ parameters\n\n        CRS WKT string\n\n        An authority string [i.e. \u2018epsg:4326\u2019]\n\n        An EPSG integer code [i.e. 4326]\n\n        A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]\n\n        An object with a to_wkt method.\n\n        A pyproj.crs.CRS class\n\n    Examples\n    --------\n    Creating a SpatialFrame from a polars df with a columns of coordinates of points .\n\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; from spatial_polars import SpatialFrame\n    &gt;&gt;&gt; df = pl.DataFrame({\n    &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n    &gt;&gt;&gt;     \"x\":[-90.18497, -90.06211],\n    &gt;&gt;&gt;     \"y\":[38.62456, 38.66072],\n    &gt;&gt;&gt;     \"z\":[0,0]\n    &gt;&gt;&gt; })\n    &gt;&gt;&gt; s_df = SpatialFrame.from_point_coords(df, \"x\", \"y\", \"z\")\n    &gt;&gt;&gt; s_df\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Place        \u2506 geometry                        \u2502\n    \u2502 ---          \u2506 ---                             \u2502\n    \u2502 str          \u2506 struct[2]                       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n    \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    \"\"\"\n    coord_cols = [x_col, y_col]\n    if z_col is not None:\n        coord_cols.append(z_col)\n\n    points = shapely.points(df.select(coord_cols).to_numpy().copy())\n    wkb_array = shapely.to_wkb(points)\n    crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n    return df.drop(coord_cols).with_columns(\n        pl.struct(\n            pl.Series(\"wkb_geometry\", wkb_array, dtype=pl.Binary),\n            pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n        ).alias(\"geometry\")\n    )\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.from_WKB","title":"<code>from_WKB(df, wkb_col, crs=4326)</code>  <code>staticmethod</code>","text":"<p>Creates a SpatialFrame from a polars DataFrame with a column of WKB.</p> <p>Parameters:</p> Name Type Description Default <code>wkb_col</code> <code>str</code> <p>The name of the column in the DataFrame which holds geometry WKB.</p> required <code>crs</code> <code>Any</code> <p>A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.</p> <p>PROJ string</p> <p>Dictionary of PROJ parameters</p> <p>PROJ keyword arguments for parameters</p> <p>JSON string with PROJ parameters</p> <p>CRS WKT string</p> <p>An authority string [i.e. 'epsg:4326']</p> <p>An EPSG integer code [i.e. 4326]</p> <p>A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e ('epsg', '4326')]</p> <p>An object with a to_wkt method.</p> <p>A pyproj.crs.CRS class</p> <code>4326</code> <p>Examples:</p> <p>Creating a SpatialFrame from a polars df with a column of WKB.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; from spatial_polars import SpatialFrame\n&gt;&gt;&gt; arch_wkb = shapely.Point(-90.18497, 38.62456).wkb\n&gt;&gt;&gt; monks_mound_wkb = shapely.Point(-90.06211, 38.66072).wkb\n&gt;&gt;&gt; df = pl.DataFrame({\n&gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n&gt;&gt;&gt;     \"wkb\":[arch_wkb, monks_mound_wkb],\n&gt;&gt;&gt; })\n&gt;&gt;&gt; s_df = SpatialFrame.from_WKB(df, \"wkb\")\n&gt;&gt;&gt; s_df\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>@staticmethod\ndef from_WKB(df: pl.DataFrame, wkb_col: str, crs: Any = 4326):\n    r\"\"\"\n    Creates a SpatialFrame from a polars DataFrame with a column of WKB.\n\n    Parameters\n    ----------\n    wkb_col\n        The name of the column in the DataFrame which holds geometry WKB.\n\n    crs\n        A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n        PROJ string\n\n        Dictionary of PROJ parameters\n\n        PROJ keyword arguments for parameters\n\n        JSON string with PROJ parameters\n\n        CRS WKT string\n\n        An authority string [i.e. 'epsg:4326']\n\n        An EPSG integer code [i.e. 4326]\n\n        A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e ('epsg', '4326')]\n\n        An object with a to_wkt method.\n\n        A pyproj.crs.CRS class\n\n    Examples\n    --------\n    Creating a SpatialFrame from a polars df with a column of WKB.\n\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; import shapely\n    &gt;&gt;&gt; from spatial_polars import SpatialFrame\n    &gt;&gt;&gt; arch_wkb = shapely.Point(-90.18497, 38.62456).wkb\n    &gt;&gt;&gt; monks_mound_wkb = shapely.Point(-90.06211, 38.66072).wkb\n    &gt;&gt;&gt; df = pl.DataFrame({\n    &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n    &gt;&gt;&gt;     \"wkb\":[arch_wkb, monks_mound_wkb],\n    &gt;&gt;&gt; })\n    &gt;&gt;&gt; s_df = SpatialFrame.from_WKB(df, \"wkb\")\n    &gt;&gt;&gt; s_df\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Place        \u2506 geometry                        \u2502\n    \u2502 ---          \u2506 ---                             \u2502\n    \u2502 str          \u2506 struct[2]                       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n    \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    \"\"\"\n    crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n\n    return df.with_columns(\n        pl.struct(\n            c(wkb_col).alias(\"wkb_geometry\"),\n            pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n        ).alias(\"geometry\")\n    ).drop(c(wkb_col))\n</code></pre>"},{"location":"SpatialFrame/#spatial_polars.spatialframe.SpatialFrame.from_WKT","title":"<code>from_WKT(df, wkt_col, crs=4326)</code>  <code>staticmethod</code>","text":"<p>Creates a SpatialFrame from a polars DataFrame with a column of WKT.</p> <p>Parameters:</p> Name Type Description Default <code>wkt_col</code> <code>str</code> <p>The name of the column in the DataFrame which holds geometry WKT.</p> required <code>crs</code> <code>Any</code> <p>A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.</p> <p>PROJ string</p> <p>Dictionary of PROJ parameters</p> <p>PROJ keyword arguments for parameters</p> <p>JSON string with PROJ parameters</p> <p>CRS WKT string</p> <p>An authority string [i.e. \u2018epsg:4326\u2019]</p> <p>An EPSG integer code [i.e. 4326]</p> <p>A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]</p> <p>An object with a to_wkt method.</p> <p>A pyproj.crs.CRS class</p> <code>4326</code> <p>Examples:</p> <p>Creating a SpatialFrame from a polars df with a column of WKT.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; from spatial_polars import SpatialFrame\n&gt;&gt;&gt; arch_wkt = shapely.Point(-90.18497, 38.62456).wkt\n&gt;&gt;&gt; monks_mound_wkt = shapely.Point(-90.06211, 38.66072).wkt\n&gt;&gt;&gt; df = pl.DataFrame({\n&gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n&gt;&gt;&gt;     \"wkt\":[arch_wkt, monks_mound_wkt],\n&gt;&gt;&gt; })\n&gt;&gt;&gt; s_df = SpatialFrame.from_WKT(df, \"wkt\")\n&gt;&gt;&gt; s_df\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src\\spatial_polars\\spatialframe.py</code> <pre><code>@staticmethod\ndef from_WKT(df, wkt_col: str, crs: Any = 4326):\n    r\"\"\"\n    Creates a SpatialFrame from a polars DataFrame with a column of WKT.\n\n    Parameters\n    ----------\n\n    wkt_col\n        The name of the column in the DataFrame which holds geometry WKT.\n\n    crs\n        A crs representation that can be provided to pyproj.CRS.from_user_input to produce a CRS.\n\n        PROJ string\n\n        Dictionary of PROJ parameters\n\n        PROJ keyword arguments for parameters\n\n        JSON string with PROJ parameters\n\n        CRS WKT string\n\n        An authority string [i.e. \u2018epsg:4326\u2019]\n\n        An EPSG integer code [i.e. 4326]\n\n        A tuple of (\u201cauth_name\u201d: \u201cauth_code\u201d) [i.e (\u2018epsg\u2019, \u20184326\u2019)]\n\n        An object with a to_wkt method.\n\n        A pyproj.crs.CRS class\n\n    Examples\n    --------\n    Creating a SpatialFrame from a polars df with a column of WKT.\n\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; import shapely\n    &gt;&gt;&gt; from spatial_polars import SpatialFrame\n    &gt;&gt;&gt; arch_wkt = shapely.Point(-90.18497, 38.62456).wkt\n    &gt;&gt;&gt; monks_mound_wkt = shapely.Point(-90.06211, 38.66072).wkt\n    &gt;&gt;&gt; df = pl.DataFrame({\n    &gt;&gt;&gt;     \"Place\":[\"Gateway Arch\", \"Monks Mound\"],\n    &gt;&gt;&gt;     \"wkt\":[arch_wkt, monks_mound_wkt],\n    &gt;&gt;&gt; })\n    &gt;&gt;&gt; s_df = SpatialFrame.from_WKT(df, \"wkt\")\n    &gt;&gt;&gt; s_df\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Place        \u2506 geometry                        \u2502\n    \u2502 ---          \u2506 ---                             \u2502\n    \u2502 str          \u2506 struct[2]                       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n    \u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    \"\"\"\n    geoms = shapely.from_wkt(df.select(wkt_col).to_series().to_numpy().copy())\n    wkb_array = shapely.to_wkb(geoms)\n    crs_wkt = pyproj.CRS.from_user_input(crs).to_wkt()\n    return df.with_columns(\n        pl.struct(\n            pl.Series(\"wkb_geometry\", wkb_array, dtype=pl.Binary),\n            pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n        ).alias(\"geometry\")\n    ).drop(c(wkt_col))\n</code></pre>"},{"location":"io/","title":"IO","text":""},{"location":"io/#spatial_polars.io.scan_spatial","title":"<code>scan_spatial(path_or_buffer, layer=None, encoding=None, bbox=None, mask=None)</code>","text":"<p>Scans a data source supported by pyogrio or a geoparquet file to produce a polars LazyFrame.</p> Note <p>Although geoparquet is supported, this implementation, in its current state, leaves a lot to be desired.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_buffer</code> <code>str | Path | BytesIO</code> <p>A dataset path or URI, raw buffer, or file-like object with a read method.</p> required <code>layer</code> <code>Optional[str | int]</code> <p>If an integer is provided, it corresponds to the index of the layer with the data source. If a string is provided, it must match the name of the layer in the data source. Defaults to first layer in data source.</p> <code>None</code> <code>encoding</code> <code>Optional[str]</code> <p>If present, will be used as the encoding for reading string values from the data source. By default will automatically try to detect the native encoding and decode to UTF-8.</p> <code>None</code> <code>bbox</code> <code>Optional[tuple[float, float, float, float]]</code> <p>If present, will be used to filter records whose geometry intersects this box. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned. Cannot be combined with mask keyword.  Tuple should be in the format of (xmin, ymin, xmax, ymax).</p> <code>None</code> <code>mask</code> <code>Optional[Polygon]</code> <p>If present, will be used to filter records whose geometry intersects this geometry. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this geometry will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect the bounding box of this geometry will be returned. Requires Shapely &gt;= 2.0. Cannot be combined with bbox keyword.</p> <code>None</code> <p>Examples:</p> <p>Scanning a layer from a geopackage:</p> <pre><code>&gt;&gt;&gt; my_geopackage = r\"c:\\data\\hiking_club.gpkg\"\n&gt;&gt;&gt; lf = scan_spatial(my_geopackage, layer=\"hike\")\n&gt;&gt;&gt; lf\nnaive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\nPYTHON SCAN []\nPROJECT */4 COLUMNS\n</code></pre> <p>Scanning a shapefile:</p> <pre><code>&gt;&gt;&gt; from spatial_polars import scan_spatial\n&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; lf = scan_spatial(my_shapefile)\n&gt;&gt;&gt; lf\nnaive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\nPYTHON SCAN []\nPROJECT */11 COLUMNS\n</code></pre> <p>Scanning a shapefile from within a zipped directory:</p> <pre><code>&gt;&gt;&gt; zipped_shapefiles = r\"C:\\data\\illinois-latest-free.shp.zip\"\n&gt;&gt;&gt; lf = scan_spatial(zipped_shapefiles, layer=\"gis_osm_roads_free_1\")\n&gt;&gt;&gt; lf\nnaive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\nPYTHON SCAN []\nPROJECT */11 COLUMNS\n</code></pre> Source code in <code>src\\spatial_polars\\io.py</code> <pre><code>def scan_spatial(\n    path_or_buffer: str | Path | BytesIO,\n    layer: Optional[str | int] = None,\n    encoding: Optional[str] = None,\n    bbox: Optional[tuple[float, float, float, float]] = None,\n    mask: Optional[shapely.Polygon] = None,\n) -&gt; pl.LazyFrame:\n    r\"\"\"\n    Scans a data source [supported by pyogrio](https://pyogrio.readthedocs.io/en/stable/supported_formats.html) or a geoparquet file to produce a polars LazyFrame.\n\n    Note\n    ----\n    Although geoparquet is supported, this implementation, in its current state, leaves a lot to be desired.\n\n    Parameters\n    ----------\n\n    path_or_buffer\n        A dataset path or URI, raw buffer, or file-like object with a read method.\n\n    layer\n        If an integer is provided, it corresponds to the index of the layer with the\n        data source. If a string is provided, it must match the name of the layer in\n        the data source. Defaults to first layer in data source.\n\n    encoding\n        If present, will be used as the encoding for reading string values from the\n        data source. By default will automatically try to detect the native encoding\n        and decode to UTF-8.\n\n    bbox\n        If present, will be used to filter records whose geometry intersects this\n        box. This must be in the same CRS as the dataset. If GEOS is present and\n        used by GDAL, only geometries that intersect this bbox will be returned;\n        if GEOS is not available or not used by GDAL, all geometries with bounding\n        boxes that intersect this bbox will be returned. Cannot be combined with mask\n        keyword.  Tuple should be in the format of (xmin, ymin, xmax, ymax).\n\n    mask\n        If present, will be used to filter records whose geometry intersects this\n        geometry. This must be in the same CRS as the dataset. If GEOS is present\n        and used by GDAL, only geometries that intersect this geometry will be\n        returned; if GEOS is not available or not used by GDAL, all geometries with\n        bounding boxes that intersect the bounding box of this geometry will be\n        returned. Requires Shapely &gt;= 2.0. Cannot be combined with bbox keyword.\n\n    Examples\n    --------\n    **Scanning a layer from a geopackage:**\n\n    &gt;&gt;&gt; my_geopackage = r\"c:\\data\\hiking_club.gpkg\"\n    &gt;&gt;&gt; lf = scan_spatial(my_geopackage, layer=\"hike\")\n    &gt;&gt;&gt; lf\n    naive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\n    PYTHON SCAN []\n    PROJECT */4 COLUMNS\n\n    **Scanning a shapefile:**\n\n    &gt;&gt;&gt; from spatial_polars import scan_spatial\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; lf = scan_spatial(my_shapefile)\n    &gt;&gt;&gt; lf\n    naive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\n    PYTHON SCAN []\n    PROJECT */11 COLUMNS\n\n    **Scanning a shapefile from within a zipped directory:**\n\n    &gt;&gt;&gt; zipped_shapefiles = r\"C:\\data\\illinois-latest-free.shp.zip\"\n    &gt;&gt;&gt; lf = scan_spatial(zipped_shapefiles, layer=\"gis_osm_roads_free_1\")\n    &gt;&gt;&gt; lf\n    naive plan: (run LazyFrame.explain(optimized=True) to see the optimized plan)\n    PYTHON SCAN []\n    PROJECT */11 COLUMNS\n    \"\"\"\n    if isinstance(path_or_buffer, (str, Path)) and str(path_or_buffer).endswith(\n        \".parquet\"\n    ):\n        # TODO look into libgdal-arrow-parquet from conda forge\n        # https://pyogrio.readthedocs.io/en/latest/install.html#conda-forge\n        schema = pl.scan_parquet(path_or_buffer).collect_schema()\n        if schema.get(\"geometry\") is not None:\n            schema[\"geometry\"] = spatial_series_dtype\n        if bbox is not None:\n            mask = shapely.Polygon(shapely.box(*bbox))\n\n        def source_generator(\n            with_columns: list[str] | None,\n            predicate: pl.Expr | None,\n            n_rows: int | None,\n            batch_size: int | None,\n        ) -&gt; Iterator[pl.DataFrame]:\n            \"\"\"\n            Generator function that creates the source.\n            This function will be registered as IO source.\n            \"\"\"\n            if mask is not None:\n                if \"geometry\" not in with_columns:\n                    with_columns.append(\"geometry\")\n\n            tab = _pq.read_table(path_or_buffer)\n            tab_metadata = tab.schema.metadata if tab.schema.metadata else {}\n            if b\"geo\" in tab_metadata:\n                geo_meta = json.loads(tab_metadata[b\"geo\"])\n            else:\n                geo_meta = {}\n            geom_col = geo_meta[\"primary_column\"]\n            crs_wkt = pyproj.CRS(geo_meta[\"columns\"][geom_col][\"crs\"]).to_wkt()\n\n            if batch_size is None:\n                batch_size = 10000\n\n            if with_columns is None:\n                read_geometry = True\n            elif \"geometry\" in with_columns:\n                read_geometry = True\n            else:\n                read_geometry = False\n\n            lf = pl.scan_parquet(path_or_buffer)\n\n            if with_columns is not None:\n                lf = lf.select(with_columns)\n\n            if predicate is not None:\n                lf = lf.filter(predicate)\n\n            previous_max = 0\n            while n_rows is None or n_rows &gt; 0:\n                batch = lf.slice(previous_max, previous_max + batch_size).collect()\n                if batch.height is None or batch.height == 0:\n                    break\n                if n_rows is not None and n_rows &lt;= 0:\n                    break\n\n                if read_geometry:\n                    # get the geometries from the batch\n                    geometries = batch[0:n_rows][geom_col]\n                    shapely_goms = shapely.from_wkb(geometries)\n                    geometries = shapely.to_wkb(shapely_goms)\n\n                    # create the dataframe with the non geometry columns\n                    # then add struct column with the WKB geometries/CRS\n                    df = pl.DataFrame(batch[0:n_rows].drop(geom_col)).with_columns(\n                        pl.struct(\n                            pl.Series(\"wkb_geometry\", geometries, dtype=pl.Binary),\n                            pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n                        ).alias(\"geometry\")\n                    )\n                else:\n                    df = pl.DataFrame(batch[0:n_rows])\n                previous_max += df.height\n\n                if n_rows is not None:\n                    n_rows -= df.height\n\n                if predicate is not None:\n                    df = df.filter(predicate)\n\n                if mask is not None:\n                    df = df.filter(pl.col(\"geometry\").spatial.intersects(mask))\n                if mask is not None:\n                    if \"geometry\" not in with_columns:\n                        df = df.drop(\"geometry\")\n\n                yield df\n\n    else:\n        # not geoparquet\n        layer_info = pyogrio.read_info(path_or_buffer, layer=layer, encoding=encoding)\n        schema = dict(\n            zip(\n                layer_info[\"fields\"],\n                [PYOGRIO_POLARS_DTYPES[dt] for dt in layer_info[\"dtypes\"]],\n            )\n        )\n        if layer_info.get(\"geometry_type\"):\n            schema[\"geometry\"] = spatial_series_dtype\n\n        def source_generator(\n            with_columns: list[str] | None,\n            predicate: pl.Expr | None,\n            n_rows: int | None,\n            batch_size: int | None,\n        ) -&gt; Iterator[pl.DataFrame]:\n            \"\"\"\n            Generator function that creates the source.\n            This function will be registered as IO source.\n            \"\"\"\n\n            if batch_size is None:\n                batch_size = 100\n\n            if with_columns is None:\n                read_geometry = True\n            elif \"geometry\" in with_columns:\n                read_geometry = True\n                with_columns.remove(\"geometry\")\n            else:\n                read_geometry = False\n\n            with pyogrio.open_arrow(\n                path_or_buffer,\n                layer=layer,\n                encoding=encoding,\n                columns=with_columns,\n                read_geometry=read_geometry,\n                force_2d=False,\n                bbox=bbox,\n                mask=mask,\n                batch_size=batch_size,\n                use_pyarrow=True,\n            ) as source:\n                meta, reader = source\n\n                # extract the crs from the metadata\n                crs_wkt = pyproj.CRS(meta[\"crs\"]).to_wkt()\n\n                geom_col = meta[\"geometry_name\"] or \"wkb_geometry\"\n\n                while n_rows is None or n_rows &gt; 0:\n                    for batch in reader:\n                        if n_rows is not None and n_rows &lt;= 0:\n                            break\n\n                        if read_geometry:\n                            # get the geometries from the batch\n                            geometries = batch[geom_col][0:n_rows]\n                            shapely_goms = shapely.from_wkb(geometries)\n                            geometries = shapely.to_wkb(shapely_goms)\n\n                            print(batch)\n\n                            # create the dataframe with the non geometry columns\n                            # then add struct column with the WKB geometries/CRS\n                            df = pl.DataFrame(\n                                batch[0:n_rows].drop_columns(geom_col)\n                            ).with_columns(\n                                pl.struct(\n                                    pl.Series(\n                                        \"wkb_geometry\", geometries, dtype=pl.Binary\n                                    ),\n                                    pl.lit(crs_wkt, dtype=pl.Categorical).alias(\"crs\"),\n                                ).alias(\"geometry\")\n                            )\n                        else:\n                            df = pl.DataFrame(batch[0:n_rows])\n\n                        if n_rows is not None:\n                            n_rows -= df.height\n\n                        if predicate is not None:\n                            df = df.filter(predicate)\n\n                        yield df\n                    if n_rows is None or n_rows &lt;= 0:\n                        break\n\n    return register_io_source(io_source=source_generator, schema=schema)\n</code></pre>"},{"location":"io/#spatial_polars.io.read_spatial","title":"<code>read_spatial(path_or_buffer, layer=None, encoding=None, bbox=None, mask=None)</code>","text":"<p>Reads a spatial data source supported by pyogrio to produce a polars DataFrame.</p> Note <p>Although geoparquet is supported, this implementation, in its current state, leaves a lot to be desired.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_buffer</code> <code>str | Path | BytesIO</code> <p>A dataset path or URI, raw buffer, or file-like object with a read method.</p> required <code>layer</code> <code>Optional[str | int]</code> <p>If an integer is provided, it corresponds to the index of the layer with the data source. If a string is provided, it must match the name of the layer in the data source. Defaults to first layer in data source.</p> <code>None</code> <code>encoding</code> <code>Optional[str]</code> <p>If present, will be used as the encoding for reading string values from the data source. By default will automatically try to detect the native encoding and decode to UTF-8.</p> <code>None</code> <code>bbox</code> <code>Optional[tuple[float, float, float, float]]</code> <p>If present, will be used to filter records whose geometry intersects this box. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned. Cannot be combined with mask keyword.  Tuple should be in the format of (xmin, ymin, xmax, ymax).</p> <code>None</code> <code>mask</code> <code>Optional[Polygon]</code> <p>If present, will be used to filter records whose geometry intersects this geometry. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this geometry will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect the bounding box of this geometry will be returned. Requires Shapely &gt;= 2.0. Cannot be combined with bbox keyword.</p> <code>None</code> <p>Examples:</p> <p>Scanning a layer from a geopackage:</p> <pre><code>&gt;&gt;&gt; from spatial_polars import read_spatial\n&gt;&gt;&gt; my_geopackage = r\"c:\\data\\hiking_club.gpkg\"\n&gt;&gt;&gt; df = read_spatial(my_geopackage, layer=\"hike\")\n&gt;&gt;&gt; df\nshape: (31, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 LOCATION                        \u2506 DATE       \u2506 DISTANCE \u2506 geometry                        \u2502\n\u2502 ---                             \u2506 ---        \u2506 ---      \u2506 ---                             \u2502\n\u2502 str                             \u2506 date       \u2506 f64      \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Watershed Nature Center         \u2506 2023-01-14 \u2506 1.25     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xd8\\x0\u2026 \u2502\n\u2502 Ellis Island                    \u2506 2023-03-11 \u2506 2.25     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\x82\\x0\u2026 \u2502\n\u2502 Cahokia Mounds State Historic \u2026 \u2506 2023-02-04 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xb1\\x0\u2026 \u2502\n\u2502 Willoughby Heritage Farm        \u2506 2022-12-03 \u2506 0.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xef\\x0\u2026 \u2502\n\u2502 Pere Marquette State Park       \u2506 2022-10-15 \u2506 1.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x002\\x02\\x\u2026 \u2502\n\u2502 \u2026                               \u2506 \u2026          \u2506 \u2026        \u2506 \u2026                               \u2502\n\u2502 Haunted Glen Carbon             \u2506 2024-10-19 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\x82\\x0\u2026 \u2502\n\u2502 Watershed Nature Center         \u2506 2024-10-08 \u2506 1.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x000\\x00\\x\u2026 \u2502\n\u2502 Beaver Dam State Park           \u2506 2024-10-26 \u2506 2.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xc4\\x0\u2026 \u2502\n\u2502 Willoughby Heritage Farm        \u2506 2024-12-07 \u2506 1.5      \u2506 {b\"\\x01\\x02\\x00\\x00\\x00&gt;\\x02\\x\u2026 \u2502\n\u2502 Cahokia Mounds State Historic \u2026 \u2506 2025-03-08 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xeb\\x0\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Scanning a shapefile:</p> <pre><code>&gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n&gt;&gt;&gt; df = read_spatial(my_shapefile)\n&gt;&gt;&gt; df\nshape: (1_662_837, 11)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 osm_id     \u2506 code \u2506 fclass      \u2506 name        \u2506 \u2026 \u2506 layer \u2506 bridge \u2506 tunnel \u2506 geometry           \u2502\n\u2502 ---        \u2506 ---  \u2506 ---         \u2506 ---         \u2506   \u2506 ---   \u2506 ---    \u2506 ---    \u2506 ---                \u2502\n\u2502 str        \u2506 i32  \u2506 str         \u2506 str         \u2506   \u2506 i64   \u2506 str    \u2506 str    \u2506 struct[2]          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4265057    \u2506 5114 \u2506 secondary   \u2506 55th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x03\\x0\u2026      \u2502\n\u2502 4265058    \u2506 5114 \u2506 secondary   \u2506 Fairview    \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506 Avenue      \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0e\\x0\u2026      \u2502\n\u2502 4267607    \u2506 5114 \u2506 secondary   \u2506 31st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2502 4271616    \u2506 5115 \u2506 tertiary    \u2506 59th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x15\\x0\u2026      \u2502\n\u2502 4275365    \u2506 5122 \u2506 residential \u2506 61st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\"\\x00\\x\u2026      \u2502\n\u2502 \u2026          \u2506 \u2026    \u2506 \u2026           \u2506 \u2026           \u2506 \u2026 \u2506 \u2026     \u2506 \u2026      \u2506 \u2026      \u2506 \u2026                  \u2502\n\u2502 1370383592 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2502 1370383593 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x07\\x0\u2026      \u2502\n\u2502 1370383594 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x1c\\x0\u2026      \u2502\n\u2502 1370383595 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0b\\x0\u2026      \u2502\n\u2502 1370398885 \u2506 5141 \u2506 service     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Scanning a shapefile from within a zipped directory:</p> <pre><code>&gt;&gt;&gt; zipped_shapefiles = r\"C:\\data\\illinois-latest-free.shp.zip\"\n&gt;&gt;&gt; df = read_spatial(zipped_shapefiles, layer=\"gis_osm_roads_free_1\")\n&gt;&gt;&gt; df\nshape: (1_662_837, 11)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 osm_id     \u2506 code \u2506 fclass      \u2506 name        \u2506 \u2026 \u2506 layer \u2506 bridge \u2506 tunnel \u2506 geometry           \u2502\n\u2502 ---        \u2506 ---  \u2506 ---         \u2506 ---         \u2506   \u2506 ---   \u2506 ---    \u2506 ---    \u2506 ---                \u2502\n\u2502 str        \u2506 i32  \u2506 str         \u2506 str         \u2506   \u2506 i64   \u2506 str    \u2506 str    \u2506 struct[2]          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4265057    \u2506 5114 \u2506 secondary   \u2506 55th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x03\\x0\u2026      \u2502\n\u2502 4265058    \u2506 5114 \u2506 secondary   \u2506 Fairview    \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506 Avenue      \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0e\\x0\u2026      \u2502\n\u2502 4267607    \u2506 5114 \u2506 secondary   \u2506 31st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2502 4271616    \u2506 5115 \u2506 tertiary    \u2506 59th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x15\\x0\u2026      \u2502\n\u2502 4275365    \u2506 5122 \u2506 residential \u2506 61st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\"\\x00\\x\u2026      \u2502\n\u2502 \u2026          \u2506 \u2026    \u2506 \u2026           \u2506 \u2026           \u2506 \u2026 \u2506 \u2026     \u2506 \u2026      \u2506 \u2026      \u2506 \u2026                  \u2502\n\u2502 1370383592 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2502 1370383593 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x07\\x0\u2026      \u2502\n\u2502 1370383594 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x1c\\x0\u2026      \u2502\n\u2502 1370383595 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0b\\x0\u2026      \u2502\n\u2502 1370398885 \u2506 5141 \u2506 service     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n\u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src\\spatial_polars\\io.py</code> <pre><code>def read_spatial(\n    path_or_buffer: str | Path | BytesIO,\n    layer: Optional[str | int] = None,\n    encoding: Optional[str] = None,\n    bbox: Optional[tuple[float, float, float, float]] = None,\n    mask: Optional[shapely.Polygon] = None,\n) -&gt; pl.DataFrame:\n    r\"\"\"\n    Reads a spatial data source [supported by pyogrio](https://pyogrio.readthedocs.io/en/stable/supported_formats.html) to produce a polars DataFrame.\n\n    Note\n    ----\n    Although geoparquet is supported, this implementation, in its current state, leaves a lot to be desired.\n\n    Parameters\n    ----------\n\n    path_or_buffer\n        A dataset path or URI, raw buffer, or file-like object with a read method.\n\n    layer\n        If an integer is provided, it corresponds to the index of the layer with the\n        data source. If a string is provided, it must match the name of the layer in\n        the data source. Defaults to first layer in data source.\n\n    encoding\n        If present, will be used as the encoding for reading string values from the\n        data source. By default will automatically try to detect the native encoding\n        and decode to UTF-8.\n\n    bbox\n        If present, will be used to filter records whose geometry intersects this\n        box. This must be in the same CRS as the dataset. If GEOS is present and\n        used by GDAL, only geometries that intersect this bbox will be returned;\n        if GEOS is not available or not used by GDAL, all geometries with bounding\n        boxes that intersect this bbox will be returned. Cannot be combined with mask\n        keyword.  Tuple should be in the format of (xmin, ymin, xmax, ymax).\n\n    mask\n        If present, will be used to filter records whose geometry intersects this\n        geometry. This must be in the same CRS as the dataset. If GEOS is present\n        and used by GDAL, only geometries that intersect this geometry will be\n        returned; if GEOS is not available or not used by GDAL, all geometries with\n        bounding boxes that intersect the bounding box of this geometry will be\n        returned. Requires Shapely &gt;= 2.0. Cannot be combined with bbox keyword.\n\n    Examples\n    --------\n    **Scanning a layer from a geopackage:**\n\n    &gt;&gt;&gt; from spatial_polars import read_spatial\n    &gt;&gt;&gt; my_geopackage = r\"c:\\data\\hiking_club.gpkg\"\n    &gt;&gt;&gt; df = read_spatial(my_geopackage, layer=\"hike\")\n    &gt;&gt;&gt; df\n    shape: (31, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 LOCATION                        \u2506 DATE       \u2506 DISTANCE \u2506 geometry                        \u2502\n    \u2502 ---                             \u2506 ---        \u2506 ---      \u2506 ---                             \u2502\n    \u2502 str                             \u2506 date       \u2506 f64      \u2506 struct[2]                       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 Watershed Nature Center         \u2506 2023-01-14 \u2506 1.25     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xd8\\x0\u2026 \u2502\n    \u2502 Ellis Island                    \u2506 2023-03-11 \u2506 2.25     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\x82\\x0\u2026 \u2502\n    \u2502 Cahokia Mounds State Historic \u2026 \u2506 2023-02-04 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xb1\\x0\u2026 \u2502\n    \u2502 Willoughby Heritage Farm        \u2506 2022-12-03 \u2506 0.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xef\\x0\u2026 \u2502\n    \u2502 Pere Marquette State Park       \u2506 2022-10-15 \u2506 1.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x002\\x02\\x\u2026 \u2502\n    \u2502 \u2026                               \u2506 \u2026          \u2506 \u2026        \u2506 \u2026                               \u2502\n    \u2502 Haunted Glen Carbon             \u2506 2024-10-19 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\x82\\x0\u2026 \u2502\n    \u2502 Watershed Nature Center         \u2506 2024-10-08 \u2506 1.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x000\\x00\\x\u2026 \u2502\n    \u2502 Beaver Dam State Park           \u2506 2024-10-26 \u2506 2.0      \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xc4\\x0\u2026 \u2502\n    \u2502 Willoughby Heritage Farm        \u2506 2024-12-07 \u2506 1.5      \u2506 {b\"\\x01\\x02\\x00\\x00\\x00&gt;\\x02\\x\u2026 \u2502\n    \u2502 Cahokia Mounds State Historic \u2026 \u2506 2025-03-08 \u2506 1.75     \u2506 {b\"\\x01\\x02\\x00\\x00\\x00\\xeb\\x0\u2026 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    **Scanning a shapefile:**\n\n    &gt;&gt;&gt; my_shapefile = r\"c:\\data\\roads.shp\"\n    &gt;&gt;&gt; df = read_spatial(my_shapefile)\n    &gt;&gt;&gt; df\n    shape: (1_662_837, 11)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 osm_id     \u2506 code \u2506 fclass      \u2506 name        \u2506 \u2026 \u2506 layer \u2506 bridge \u2506 tunnel \u2506 geometry           \u2502\n    \u2502 ---        \u2506 ---  \u2506 ---         \u2506 ---         \u2506   \u2506 ---   \u2506 ---    \u2506 ---    \u2506 ---                \u2502\n    \u2502 str        \u2506 i32  \u2506 str         \u2506 str         \u2506   \u2506 i64   \u2506 str    \u2506 str    \u2506 struct[2]          \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 4265057    \u2506 5114 \u2506 secondary   \u2506 55th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x03\\x0\u2026      \u2502\n    \u2502 4265058    \u2506 5114 \u2506 secondary   \u2506 Fairview    \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506 Avenue      \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0e\\x0\u2026      \u2502\n    \u2502 4267607    \u2506 5114 \u2506 secondary   \u2506 31st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2502 4271616    \u2506 5115 \u2506 tertiary    \u2506 59th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x15\\x0\u2026      \u2502\n    \u2502 4275365    \u2506 5122 \u2506 residential \u2506 61st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\"\\x00\\x\u2026      \u2502\n    \u2502 \u2026          \u2506 \u2026    \u2506 \u2026           \u2506 \u2026           \u2506 \u2026 \u2506 \u2026     \u2506 \u2026      \u2506 \u2026      \u2506 \u2026                  \u2502\n    \u2502 1370383592 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2502 1370383593 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x07\\x0\u2026      \u2502\n    \u2502 1370383594 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x1c\\x0\u2026      \u2502\n    \u2502 1370383595 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0b\\x0\u2026      \u2502\n    \u2502 1370398885 \u2506 5141 \u2506 service     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    **Scanning a shapefile from within a zipped directory:**\n\n    &gt;&gt;&gt; zipped_shapefiles = r\"C:\\data\\illinois-latest-free.shp.zip\"\n    &gt;&gt;&gt; df = read_spatial(zipped_shapefiles, layer=\"gis_osm_roads_free_1\")\n    &gt;&gt;&gt; df\n    shape: (1_662_837, 11)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 osm_id     \u2506 code \u2506 fclass      \u2506 name        \u2506 \u2026 \u2506 layer \u2506 bridge \u2506 tunnel \u2506 geometry           \u2502\n    \u2502 ---        \u2506 ---  \u2506 ---         \u2506 ---         \u2506   \u2506 ---   \u2506 ---    \u2506 ---    \u2506 ---                \u2502\n    \u2502 str        \u2506 i32  \u2506 str         \u2506 str         \u2506   \u2506 i64   \u2506 str    \u2506 str    \u2506 struct[2]          \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 4265057    \u2506 5114 \u2506 secondary   \u2506 55th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x03\\x0\u2026      \u2502\n    \u2502 4265058    \u2506 5114 \u2506 secondary   \u2506 Fairview    \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506 Avenue      \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0e\\x0\u2026      \u2502\n    \u2502 4267607    \u2506 5114 \u2506 secondary   \u2506 31st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2502 4271616    \u2506 5115 \u2506 tertiary    \u2506 59th Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x15\\x0\u2026      \u2502\n    \u2502 4275365    \u2506 5122 \u2506 residential \u2506 61st Street \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\"\\x00\\x\u2026      \u2502\n    \u2502 \u2026          \u2506 \u2026    \u2506 \u2026           \u2506 \u2026           \u2506 \u2026 \u2506 \u2026     \u2506 \u2026      \u2506 \u2026      \u2506 \u2026                  \u2502\n    \u2502 1370383592 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2502 1370383593 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x07\\x0\u2026      \u2502\n    \u2502 1370383594 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x1c\\x0\u2026      \u2502\n    \u2502 1370383595 \u2506 5153 \u2506 footway     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x0b\\x0\u2026      \u2502\n    \u2502 1370398885 \u2506 5141 \u2506 service     \u2506 null        \u2506 \u2026 \u2506 0     \u2506 F      \u2506 F      \u2506 {b\"\\x01\\x02\\x00\\x0 \u2502\n    \u2502            \u2506      \u2506             \u2506             \u2506   \u2506       \u2506        \u2506        \u2506 0\\x00\\x02\\x0\u2026      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    return scan_spatial(\n        path_or_buffer=path_or_buffer,\n        layer=layer,\n        encoding=encoding,\n        bbox=bbox,\n        mask=mask,\n    ).collect(engine=\"streaming\")\n</code></pre>"},{"location":"examples/reading_data/","title":"Reading Spatial Data","text":"<p>Spatial polars provides an IO plugin that allows us to scan a spatial data into a lazyframe using the scan_spatial  function.  The <code>scan_spatial</code> function uses pyogrio under the hood to read the data, so anything it can read, spatial polars can read.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> Reading Spatial Data Setup<pre><code>import zipfile # (1)!\n\nimport geodatasets # (2)!\nimport polars as pl # (3)!\nimport shapely # (4)!\n\nfrom spatial_polars import scan_spatial, read_spatial # (5)!\n</code></pre> <ol> <li>This is just so we can peek inside a zip file it's unnecessary for a typical workflow</li> <li>See note above about geodatasets, also not needed for a normal workflow</li> <li>yup, we need polars!</li> <li>You may or may not need shapely imported, we need it for the mask example below to make a shapely polygon.  If you aren't using it directly you wont need to import it.</li> <li>The scan_spatial function is where the spatial polars magic starts, and read_spatial is helpful too</li> </ol> <p>We'll start by downloading the geoda.nyc_earnings dataset.</p> <p>The data from geodatasets is zipped, but pyogrio has no issue reading directly out of a zip file, so there isn't any need to unzip anything first.  </p> <p>Just to show what's inside the nyc_earnings dataset we'll just print out the contents of the zip file and see that there's a shapefile with all it's associated files.</p> looking inside the geoda.nyc_earnings zip file<pre><code>nyc_earnings_path = geodatasets.get_path(\"geoda.nyc_earnings\")\nwith zipfile.ZipFile(nyc_earnings_path, \"r\") as zip_file:\n    for file_name in zip_file.namelist():\n        print(file_name)\n</code></pre> <pre><code>NYC Area2010_2data.dbf # (1)!\n__MACOSX/\n__MACOSX/._NYC Area2010_2data.dbf\nNYC Area2010_2data.prj # (2)!\n__MACOSX/._NYC Area2010_2data.prj\nNYC Area2010_2data.shp # (3)!\n__MACOSX/._NYC Area2010_2data.shp\nNYC Area2010_2data.shx # (4)!\n__MACOSX/._NYC Area2010_2data.shx\n</code></pre> <ol> <li>Our shapefile's dbf of our tabular information</li> <li>Our shapefile's coordinate system information</li> <li>Our shapefile's geometries</li> <li>Our shapefile's file that links the geometries and tabular information</li> </ol>"},{"location":"examples/reading_data/#scan_spatial","title":"scan_spatial()","text":"<p>To scan the data and produce a polars LazyFrame we use the scan_spatial function.  The cell below will produce a LazyFrame of the nyc earnings shapefile.  When we collect the schema, we'll see that it's got a lot of columns, the last of which is \"geometry\", a struct of our shapefile's geometry stored as WKB and CRS information.</p> Scanning a zipped shapefile<pre><code>nyc_earnings_lf = scan_spatial(geodatasets.get_path(\"geoda.nyc_earnings\"))\nnyc_earnings_lf.collect_schema()\n</code></pre> <pre><code>Schema([('STATEFP10', String),\n        ('COUNTYFP10', Int64),\n        ('TRACTCE10', String),\n        ('BLOCKCE10', String),\n...SNIP... # (1)!\n        ('CE02_14', Int64),\n        ('CE03_14', Int64),\n        ('geometry',\n         Struct({'wkb_geometry': Binary, 'crs': Categorical(ordering='physical')}))]) # (2)!\n</code></pre> <ol> <li>There are 71 columns, but this documentation doesn't need to show them all </li> <li>This 'geometry' struct is the geometry from our data source, the 'wkb_geometry' field of the struct holds the geometry encoded as WKB, and the 'crs' field is the coordinate reference system for the geometries.</li> </ol>"},{"location":"examples/reading_data/#collecting-the-lazyframe","title":"Collecting the LazyFrame","text":"<p>To see the actual data, just like any other polars LazyFrame, we can collect the LazyFrame.</p> Collecting a LazyFrame into a DataFrame<pre><code>print(nyc_earnings_lf.collect(engine=\"streaming\"))\n</code></pre> <pre><code>shape: (108_487, 71) # (1)!\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 STATEFP10 \u2506 COUNTYFP10 \u2506 TRACTCE10 \u2506 BLOCKCE10 \u2506 \u2026 \u2506 CE01_14 \u2506 CE02_14 \u2506 CE03_14 \u2506 geometry      \u2502\n\u2502 ---       \u2506 ---        \u2506 ---       \u2506 ---       \u2506   \u2506 ---     \u2506 ---     \u2506 ---     \u2506 ---           \u2502\n\u2502 str       \u2506 i64        \u2506 str       \u2506 str       \u2506   \u2506 i64     \u2506 i64     \u2506 i64     \u2506 struct[2]     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 36        \u2506 5          \u2506 051600    \u2506 5011      \u2506 \u2026 \u2506 0       \u2506 0       \u2506 0       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 5          \u2506 030000    \u2506 4003      \u2506 \u2026 \u2506 22      \u2506 38      \u2506 51      \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 5          \u2506 040900    \u2506 1001      \u2506 \u2026 \u2506 1       \u2506 3       \u2506 0       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 5          \u2506 040900    \u2506 2000      \u2506 \u2026 \u2506 327     \u2506 552     \u2506 733     \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 5          \u2506 041100    \u2506 1000      \u2506 \u2026 \u2506 0       \u2506 0       \u2506 0       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 \u2026         \u2506 \u2026          \u2506 \u2026         \u2506 \u2026         \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026       \u2506 \u2026             \u2502\n\u2502 36        \u2506 119        \u2506 002201    \u2506 2018      \u2506 \u2026 \u2506 2       \u2506 1       \u2506 2       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n...\n\u2502 36        \u2506 119        \u2506 000900    \u2506 1016      \u2506 \u2026 \u2506 15      \u2506 21      \u2506 55      \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>That's 108K rows and 71 columns</li> </ol>"},{"location":"examples/reading_data/#optimizations","title":"Optimizations","text":"<p>Like all the polars provided <code>scan_*</code> functions, scan spatial will make use of polars optimizations when the query is collected.  This can lead to dramatic speed improvements, and reduce RAM consumption.</p> Collecting a LazyFrame into a DataFrame with predicate/projection pushdown<pre><code>nyc_earnings_df = nyc_earnings_lf.filter(\n    pl.col(\"COUNTYFP10\") == 119 # (1)!\n).select(\n    pl.col(\"COUNTYFP10\"), \n    pl.col(\"NAME10\"),  # (2)!\n    pl.col(\"geometry\")\n).collect(engine=\"streaming\") # (3)!\nprint(nyc_earnings_df)\n</code></pre> <ol> <li>This filter will limit the rows to just the ones where COUNTYFP10 is 119</li> <li>This will limit the columns that are read from the shapefile to just these three</li> <li>Give us a DataFrame that has only the rows we filtered on, and just the columns we selected</li> </ol> <pre><code>shape: (15_081, 3) # (1)!\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 COUNTYFP10 \u2506 NAME10     \u2506 geometry                        \u2502\n\u2502 ---        \u2506 ---        \u2506 ---                             \u2502\n\u2502 i64        \u2506 str        \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 119        \u2506 Block 1010 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 4005 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x02\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 3023 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 3016 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 4008 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 \u2026          \u2506 \u2026          \u2506 \u2026                               \u2502\n\u2502 119        \u2506 Block 2018 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 2017 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 2018 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 1005 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2502 119        \u2506 Block 1016 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Just a few rows and columns (remember, the shapefile has 108K rows and 71 columns).  Note that all the rows have COUNTYFP10 = 119 and obviously we only have three of the 71 columns</li> </ol> <p>'Missing' parameters</p> <p>Users that are familiar with pyogrio (or geopandas), may wonder why spatial polars has no \"columns\", \"where\", \"fids\", or \"sql\" parameters on the scan_spatial function.  These parameters are used by pygrio to limit the columns and rows that are read from a datasource.  Spatial polars operates differently.  Under the covers it does use the columns parameter from pyogrio, but instead of the user explicitly stating the columns in the scan_spatial function, polars will pass the columns needed for your query to pyogrio for you when it collects your query.  The where clause is different, polars expressions do not relate 1:1 to a where clause, so when the data is fetched by polars using the scan_spatial function, it will apply the polars predicate to each batch of records pyogrio reads before passing the records to the rest of the polars pipeline.</p>"},{"location":"examples/reading_data/#the-bbox-parameter","title":"The <code>bbox</code> Parameter","text":"<p>The <code>scan_spatial</code> function also has the ability to apply a spatial filter to the input data to only read in features that intersect a specific area.  The bounding box' extent can be provided to the <code>bbox</code> parameter as a tuple of floats for the xmin, ymin, xmax, ymax.</p> Spatial filter with the `bbox` parameter<pre><code>nyc_earnings_lf2 = scan_spatial(\n    geodatasets.get_path(\"geoda.nyc_earnings\"), \n    bbox=(1816900, 639414, 1817000, 639668) # (1)!\n)\nprint(nyc_earnings_lf2.collect(engine=\"streaming\"))\n</code></pre> <ol> <li>Only give us the rows that intersect this bounding box when we collect.  These corrdinates are just some numbers chosen at random which produce a small number of rows in the resulting dataframe.</li> </ol> <pre><code>shape: (4, 71) # (1)!\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 STATEFP10 \u2506 COUNTYFP10 \u2506 TRACTCE10 \u2506 BLOCKCE10 \u2506 \u2026 \u2506 CE01_14 \u2506 CE02_14 \u2506 CE03_14 \u2506 geometry      \u2502\n\u2502 ---       \u2506 ---        \u2506 ---       \u2506 ---       \u2506   \u2506 ---     \u2506 ---     \u2506 ---     \u2506 ---           \u2502\n\u2502 str       \u2506 i64        \u2506 str       \u2506 str       \u2506   \u2506 i64     \u2506 i64     \u2506 i64     \u2506 struct[2]     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1010      \u2506 \u2026 \u2506 0       \u2506 0       \u2506 0       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1022      \u2506 \u2026 \u2506 2       \u2506 1       \u2506 2       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1006      \u2506 \u2026 \u2506 16      \u2506 19      \u2506 28      \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1021      \u2506 \u2026 \u2506 4       \u2506 4       \u2506 9       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Just a 4 rows within that little box (remember, the shapefile has 108K rows and 71 columns)</li> </ol>"},{"location":"examples/reading_data/#the-mask-parameter","title":"The <code>mask</code> Parameter","text":"<p>We could use those same coordinates in the bbox example as a shapely polygon to get the same results thru the mask parameter.  If we had a shapely polygon that was a non-rectangle shape that would be ok also.</p> Spatial filter with the mask parameter<pre><code>mask_polygon = shapely.Polygon( # (1)!\n    (\n        (1816900, 639414),\n        (1816900, 639668),\n        (1817000, 639668),\n        (1817000, 639414),\n        (1816900, 639414),\n    )\n)\nnyc_earnings_lf3 = scan_spatial(\n    geodatasets.get_path(\"geoda.nyc_earnings\"), \n    mask=mask_polygon # (2)!\n)\nprint(nyc_earnings_lf3.collect(engine=\"streaming\"))\n</code></pre> <ol> <li>Make a polygon with the same coordinates as the bbox example above</li> <li>Use the polygon to mask the reading of the data from the shapefile</li> </ol> <pre><code>shape: (4, 71) # (1)!\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 STATEFP10 \u2506 COUNTYFP10 \u2506 TRACTCE10 \u2506 BLOCKCE10 \u2506 \u2026 \u2506 CE01_14 \u2506 CE02_14 \u2506 CE03_14 \u2506 geometry      \u2502\n\u2502 ---       \u2506 ---        \u2506 ---       \u2506 ---       \u2506   \u2506 ---     \u2506 ---     \u2506 ---     \u2506 ---           \u2502\n\u2502 str       \u2506 i64        \u2506 str       \u2506 str       \u2506   \u2506 i64     \u2506 i64     \u2506 i64     \u2506 struct[2]     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1010      \u2506 \u2026 \u2506 0       \u2506 0       \u2506 0       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1022      \u2506 \u2026 \u2506 2       \u2506 1       \u2506 2       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1006      \u2506 \u2026 \u2506 16      \u2506 19      \u2506 28      \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2502 36        \u2506 119        \u2506 014701    \u2506 1021      \u2506 \u2026 \u2506 4       \u2506 4       \u2506 9       \u2506 {b\"\\x01\\x03\\x \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 00\\x00\\x00\\x0 \u2502\n\u2502           \u2506            \u2506           \u2506           \u2506   \u2506         \u2506         \u2506         \u2506 1\\x0\u2026         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Just the same 4 rows as the bbox example within that little mask polygon (remember, the shapefile has 108K rows and 71 columns)</li> </ol>"},{"location":"examples/reading_data/#the-layer-parameter","title":"The layer Parameter","text":"<p>Reading from a data source which contains more than one table is accomplished with the <code>layer</code> parameter.</p> <p>geoda.milwaukee1 from geodatasets is a geopackage.  Geopackages are SQLite databases which can contain more than one table.</p> Using the layer parameter<pre><code>layer_param_df = scan_spatial(\n    geodatasets.get_path(\"geoda.milwaukee1\"), \n    layer=\"wi_final_census2_random4\" # (1)!\n).collect(engine=\"streaming\")\nprint(layer_param_df)\n</code></pre> <ol> <li>Because there is more than one table in the geopackage we need to tell scan_spatial which table to read from.</li> </ol> <pre><code>shape: (417, 35)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 FIPS        \u2506 MSA       \u2506 TOT_POP \u2506 POP_16 \u2506 \u2026 \u2506 PCTBLACK \u2506 PCTBLCK  \u2506 polyid \u2506 geometry         \u2502\n\u2502 ---         \u2506 ---       \u2506 ---     \u2506 ---    \u2506   \u2506 ---      \u2506 ---      \u2506 ---    \u2506 ---              \u2502\n\u2502 str         \u2506 str       \u2506 i32     \u2506 i32    \u2506   \u2506 f32      \u2506 f32      \u2506 i16    \u2506 struct[2]        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 55131430100 \u2506 Milwaukee \u2506 5068    \u2506 1248   \u2506 \u2026 \u2506 0.860631 \u2506 0.000987 \u2506 1      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55089610100 \u2506 Milwaukee \u2506 8003    \u2506 1812   \u2506 \u2026 \u2506 0.005959 \u2506 0.004373 \u2506 2      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131410100 \u2506 Milwaukee \u2506 4393    \u2506 1026   \u2506 \u2026 \u2506 0.030012 \u2506 0.000455 \u2506 3      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131400101 \u2506 Milwaukee \u2506 7687    \u2506 1801   \u2506 \u2026 \u2506 0.141892 \u2506 0.000781 \u2506 4      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131420104 \u2506 Milwaukee \u2506 5086    \u2506 1065   \u2506 \u2026 \u2506 0.010384 \u2506 0.012584 \u2506 5      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 \u2026           \u2506 \u2026         \u2506 \u2026       \u2506 \u2026      \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026      \u2506 \u2026                \u2502\n\u2502 55079160201 \u2506 Milwaukee \u2506 8476    \u2506 1619   \u2506 \u2026 \u2506 0.973236 \u2506 0.040349 \u2506 413    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55133203900 \u2506 Milwaukee \u2506 7705    \u2506 1771   \u2506 \u2026 \u2506 0.0      \u2506 0.004932 \u2506 414    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079160202 \u2506 Milwaukee \u2506 6169    \u2506 1532   \u2506 \u2026 \u2506 0.000759 \u2506 0.01232  \u2506 415    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079160300 \u2506 Milwaukee \u2506 7398    \u2506 1915   \u2506 \u2026 \u2506 0.007703 \u2506 0.022979 \u2506 416    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079150400 \u2506 Milwaukee \u2506 1092    \u2506 212    \u2506 \u2026 \u2506 0.739302 \u2506 0.0      \u2506 417    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/reading_data/#read_spatial","title":"read_spatial()","text":"<p>Additionally, spatial polars also has a read_spatial function which will simply call <code>scan_spatial</code> and then call <code>.collect(engine=\"streaming\")</code> to return a dataframe with all the columns and rows of a datasource.</p> read_spatial<pre><code>read_df = read_spatial( \n    geodatasets.get_path(\"geoda.milwaukee1\"), \n    layer=\"wi_final_census2_random4\"\n) # (1)!\nprint(read_df)\n</code></pre> <ol> <li>No need to collect anything, read_spatial does that for you</li> </ol> <pre><code>shape: (417, 35) # (1)!\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 FIPS        \u2506 MSA       \u2506 TOT_POP \u2506 POP_16 \u2506 \u2026 \u2506 PCTBLACK \u2506 PCTBLCK  \u2506 polyid \u2506 geometry         \u2502\n\u2502 ---         \u2506 ---       \u2506 ---     \u2506 ---    \u2506   \u2506 ---      \u2506 ---      \u2506 ---    \u2506 ---              \u2502\n\u2502 str         \u2506 str       \u2506 i32     \u2506 i32    \u2506   \u2506 f32      \u2506 f32      \u2506 i16    \u2506 struct[2]        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 55131430100 \u2506 Milwaukee \u2506 5068    \u2506 1248   \u2506 \u2026 \u2506 0.860631 \u2506 0.000987 \u2506 1      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55089610100 \u2506 Milwaukee \u2506 8003    \u2506 1812   \u2506 \u2026 \u2506 0.005959 \u2506 0.004373 \u2506 2      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131410100 \u2506 Milwaukee \u2506 4393    \u2506 1026   \u2506 \u2026 \u2506 0.030012 \u2506 0.000455 \u2506 3      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131400101 \u2506 Milwaukee \u2506 7687    \u2506 1801   \u2506 \u2026 \u2506 0.141892 \u2506 0.000781 \u2506 4      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55131420104 \u2506 Milwaukee \u2506 5086    \u2506 1065   \u2506 \u2026 \u2506 0.010384 \u2506 0.012584 \u2506 5      \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 \u2026           \u2506 \u2026         \u2506 \u2026       \u2506 \u2026      \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026      \u2506 \u2026                \u2502\n\u2502 55079160201 \u2506 Milwaukee \u2506 8476    \u2506 1619   \u2506 \u2026 \u2506 0.973236 \u2506 0.040349 \u2506 413    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55133203900 \u2506 Milwaukee \u2506 7705    \u2506 1771   \u2506 \u2026 \u2506 0.0      \u2506 0.004932 \u2506 414    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079160202 \u2506 Milwaukee \u2506 6169    \u2506 1532   \u2506 \u2026 \u2506 0.000759 \u2506 0.01232  \u2506 415    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079160300 \u2506 Milwaukee \u2506 7398    \u2506 1915   \u2506 \u2026 \u2506 0.007703 \u2506 0.022979 \u2506 416    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2502 55079150400 \u2506 Milwaukee \u2506 1092    \u2506 212    \u2506 \u2026 \u2506 0.739302 \u2506 0.0      \u2506 417    \u2506 {b\"\\x01\\x03\\x00\\ \u2502\n\u2502             \u2506           \u2506         \u2506        \u2506   \u2506          \u2506          \u2506        \u2506 x00\\x00\\x01\\x0\u2026  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li> <p>Exactly the same results as <code>scan_spatial().collect(engine=\"streaming\")</code> (1)</p> <ol> <li>Because that's exactly what it's doing  </li> </ol> </li> </ol>"},{"location":"examples/reprojection/","title":"Reprojection","text":"<p>Spatial polars is happy to reproject your data using pyproj in the exact same manner as geopandas using the .reproject expression.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>To reproject data into a new CRS you can use the <code>.spatial.reproject()</code> expression</p> Reprojecting data to a new CRS<pre><code>import geodatasets\nimport polars as pl\n\nfrom spatial_polars import scan_spatial\n\ngeom = (\n    scan_spatial(\n        geodatasets.get_path(\"geoda.nyc_earnings\")  # (1)!\n    )\n    .select(\n        pl.col(\"geometry\").spatial.to_shapely_array()  # (2)!\n    )\n    .head(1)\n    .collect()\n    .item()\n)  # (3)!\n\nprint(f\"Without reprojecting centroid of first geometry: {geom.centroid.coords[0]}\")\n\n\ngeom = (\n    scan_spatial(\n        geodatasets.get_path(\"geoda.nyc_earnings\")  # (4)!\n    )\n    .select(\n        pl.col(\"geometry\").spatial.reproject(4326).spatial.to_shapely_array()  # (5)!\n    )\n    .head(1)\n    .collect()\n    .item()\n)  # (6)!\n\nprint(f\"With reprojecting centroid of first geometry: {geom.centroid.coords[0]}\")\n</code></pre> <ol> <li> <p>Scan the nyc_earnings geodataset </p> <p>Note</p> <p>This data is in the USA_Contiguous_Albers_Equal_Area_Conic projection</p> </li> <li> <p>Select the geometry column and convert it to shapely geometry objects</p> </li> <li>Collect the first row of the dataframe and grab the item from the dataframe since it only has one column and one row</li> <li>Scan the same dataset as above</li> <li>Select the geometry column reproject it to WGS84 and convert it to shapely geometry objects </li> <li>Collect the first row of the dataframe and grab the item from the dataframe since it only has one column and one row</li> </ol> <pre><code>Without reprojecting centroid of first geometry: (1841811.263290252, 592543.3261750872)\nWith reprojecting centroid of first geometry: (-73.77001694078662, 40.85653306959936)\n</code></pre>"},{"location":"examples/spatial_join/","title":"Spatial Joins","text":"<p>Spatial polars can perform a spatial join to join two dataframes based on geomtric predicate.  </p> <p>Not lazy</p> <p>Spatial joins are currently only implemented for DataFrames they are not yet available for LazyFrames.</p> <p>Thanks to Natural Earth</p> <p>This example reads zipped data from Natural Earth, big thanks to them for putting this data out there for us to use!</p> <p>Made with Natural Earth. Free vector and raster map data @ naturalearthdata.com.</p> <p>To demonstrate how we can join data together from two dataframes spatially using spatial polars, we'll join some lake polygons with some administrative boundaries to see which lakes are in which countries.</p> Spatial Join<pre><code>import polars as pl\n\nfrom spatial_polars import scan_spatial\n\nlake_df = (\n    scan_spatial(\"https://naciscdn.org/naturalearth/110m/physical/ne_110m_lakes.zip\")\n    .select(\"name\", \"geometry\")\n    .collect(engine=\"streaming\")\n)  # (1)!\nprint(f\"There are {len(lake_df)} rows in lake_df\")\n\nboundary_df = (\n    scan_spatial(\n        \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n    )\n    .select(\"SOVEREIGNT\", \"geometry\")\n    .collect(engine=\"streaming\")\n)  # (2)!\n\nlake_boundary_df = (\n    lake_df.spatial.join(  # (3)!\n        other=boundary_df,  # (4)!\n        how=\"inner\",  # (5)!\n        predicate=\"intersects\",  # (6)!\n        on=\"geometry\",  # (7)!\n        suffix=\"_boundary\",  # (8)!\n    )\n    .select(\n        pl.col(\"name\"),  # (9)!\n        pl.col(\"SOVEREIGNT\"),\n        pl.col(\"geometry\"),\n        pl.col(\"geometry_boundary\"),\n    )\n    .sort(\"name\")  # (10)!\n)\nprint(lake_boundary_df)\n</code></pre> <ol> <li>Reading the lakes with only the lake's name and geometry</li> <li>Reading the boundaries with only the country's name (SOVEREIGNT) and geometry</li> <li>Starting with the lake_df we'll start our spatial join</li> <li>Specifying to join the lakes to this boundary_df</li> <li> <p>We'll use an inner join so as to only return rows for lakes that actually intersect a boundary.  If a lake does not intersect a boundary polygon we won't have a row for that lake in our output dataframe. Likewise, if a boundary doesn't intersect a lake, the resulting dataframe won't have a row for that boundary.</p> <p>Note</p> <p>This could have been left off, because <code>how='inner'</code> is the default</p> </li> <li> <p>Use the 'intersects' spatial predicate so if any part of the lake shares any space with the boundary we'll join the lake to the boundary.  Since we've specified an inner join, if a lake intersects more than one boundary, we'll get more than one row for the lake since it's joined to more than one boundary.</p> <p>Note</p> <p>This could have been left off, because <code>predicate='intersects'</code> is the default</p> </li> <li> <p>Since the name of the geometry struct is 'geometry' in both of our dataframes, we will use the <code>on</code> parameter, if we wanted to use a different column name for each of the dataframes we could use the <code>left_on</code> or <code>right_on</code> parameters. </p> <p>Note</p> <p>This could have been left off, because <code>on='geometry'</code> is the default</p> </li> <li> <p>Since we're joining the dataframes with a common column name (geometry), a suffix must be applied to the columns of the right dataframe that have names that exist in the left fram, because we can't have two columns with the same name.  we'll use \"_boundary\" as the suffix to clarify that the geometry of the right frame came from the boundaries dataframe.</p> </li> <li>Selecting the columns to make the lake name and SOVEREIGNT columns show up before the lake and boundary geometry columns.</li> <li>Sort by the lake name just to make the results look nice in our output dataframe.</li> </ol> <pre><code>There are 24 rows in lake_df\nshape: (36, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 name             \u2506 SOVEREIGNT               \u2506 geometry                       \u2506 geometry_boundary              \u2502\n\u2502 ---              \u2506 ---                      \u2506 ---                            \u2506 ---                            \u2502\n\u2502 str              \u2506 str                      \u2506 struct[2]                      \u2506 struct[2]                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Cedar Lake       \u2506 Canada                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x1e\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Great Bear Lake  \u2506 Canada                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x1e\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Great Salt Lake  \u2506 United States of America \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x0a\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Great Slave Lake \u2506 Canada                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x1e\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Lago Titicaca    \u2506 Bolivia                  \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 \u2026                \u2506 \u2026                        \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Lake Victoria    \u2506 Kenya                    \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Lake Victoria    \u2506 Uganda                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Lake Winnipeg    \u2506 Canada                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x1e\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 Reindeer Lake    \u2506 Canada                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x06\\x00\\x00\\x00\\x1e\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2502 V\u00e4nern           \u2506 Sweden                   \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2506 {b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x0 \u2502\n\u2502                  \u2506                          \u2506 \u2026                              \u2506 \u2026                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Of the original 24 lakes and 177 bounaries, we have 36 rows now, beacause there are a few that cross the borders of the boundaries and were joined to more than one.  Lake Victoria is one of these lakes, it intersects both Kenya and Uganda</p> <p>The resulting dataframe has a row for each lake name/geometry from the lakes dataframe and the SOVEREIGNT and geometry_boundary from the boundary df where the lake intersects an admin boundary.</p> <p>Many GIS don't allow for multiple geometries on a single row, but spatial polars has no issue with this, and is actually something that we can use to our advantage.</p>"},{"location":"examples/starting_from_a_polars_df/","title":"Starting From a Polars Dataframe","text":"<p>Spatial polars has a few ways to create a dataframe with a geometry column in the appropriate format for spatial polars functionality to operate that do not involve reading directly from a spatial source.  If you have an existing dataframe with coordinates of points, or WKB/WKT, you're in luck!</p> <p>setup<pre><code>import polars as pl\nimport shapely\nfrom spatial_polars import SpatialFrame\n</code></pre> </p>"},{"location":"examples/starting_from_a_polars_df/#from-point-coords","title":"From Point Coords","text":"<p>Spatial polars provides a way to take an existing polars dataframe with columns of X/Y (and optionally Z) coordinates, and convert them to work with the spatial polars functionality.  We can use SpatialFrame.from_point_coords to take the dataframe and convert the coordinates into a spatial polars geometry struct column.</p> <p>In the example below we'll create a polars DataFrame with a 'Place' column, for the name of the place, along with x/y/z coordinates.</p> from point coords<pre><code>df = pl.DataFrame(  # (1)!\n    {\n        \"Place\": [\"Gateway Arch\", \"Monks Mound\"],\n        \"x\": [-90.18497, -90.06211],\n        \"y\": [38.62456, 38.66072],\n        \"z\": [0, 0],\n    }\n)\nprint(\"Before SpatialFrame.from_point_coords:\")\nprint(df)\ns_df1 = SpatialFrame.from_point_coords(df, x_col=\"x\", y_col=\"y\", z_col=\"z\")  # (2)!\nprint(\"After SpatialFrame.from_point_coords:\")\nprint(s_df1)\n</code></pre> <ol> <li>Creating a polars dataframe with x/y/z coordinates </li> <li> <p>SpatialFrame.from_point_coords takes the x/y/z coordinates and converts them to a struct column with the geometry as WKB and a CRS</p> <p>Note</p> <p>Because we are not specifying a <code>crs</code> WGS84:4326 is defaulted.</p> </li> </ol> <pre><code>Before SpatialFrame.from_point_coords:\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 x         \u2506 y        \u2506 z   \u2502\n\u2502 ---          \u2506 ---       \u2506 ---      \u2506 --- \u2502\n\u2502 str          \u2506 f64       \u2506 f64      \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 -90.18497 \u2506 38.62456 \u2506 0   \u2502\n\u2502 Monks Mound  \u2506 -90.06211 \u2506 38.66072 \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\nAfter SpatialFrame.from_point_coords:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x80o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x80K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/starting_from_a_polars_df/#from-wkb","title":"From WKB","text":"<p>Spatial polars provides a way to take an existing polars dataframe with a column of WKB, and convert it to work with the spatial polars functionality.  We can use SpatialFrame.from_WKB to take the dataframe and convert the WKB into a spatial polars geometry struct column.</p> <p>In the cell below we'll create a polars DataFrame with a 'Place' column, for the name of the place, along with a column containting WKB.</p> from wkb<pre><code>arch_wkb = shapely.Point(-90.18497, 38.62456).wkb\nmonks_mound_wkb = shapely.Point(-90.06211, 38.66072).wkb\ndf = pl.DataFrame(  # (1)!\n    {\n        \"Place\": [\"Gateway Arch\", \"Monks Mound\"],\n        \"wkb\": [arch_wkb, monks_mound_wkb],\n    }\n)\nprint(\"Before SpatialFrame.from_WKB:\")\nprint(df)\ns_df2 = SpatialFrame.from_WKB(df, \"wkb\")  # (2)!\nprint(\"After SpatialFrame.from_WKB:\")\nprint(s_df2)\n</code></pre> <ol> <li>Creating a polars dataframe with column of WKB</li> <li> <p>SpatialFrame.from_WKB takes the wkb column and adds it to a struct column with the CRS</p> <p>Note</p> <p>Because we are not specifying a <code>crs</code> WGS84:4326 is defaulted.</p> </li> </ol> <pre><code>Before SpatialFrame.from_WKB:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 wkb                             \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 binary                          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 b\"\\x01\\x01\\x00\\x00\\x00o/i\\x8c\\\u2026 \u2502\n\u2502 Monks Mound  \u2506 b\"\\x01\\x01\\x00\\x00\\x00K\\xb08\\x\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nAfter SpatialFrame.from_WKB:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x00o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/starting_from_a_polars_df/#from-wkt","title":"From WKT","text":"<p>Spatial polars provides a way to take an existing polars dataframe with a column of WKT, and convert it to work with the spatial polars functionality. We can use SpatialFrame.from_WKT to take the dataframe and convert the WKT into a spatial polars geometry struct column.</p> <p>In the cell below we'll create a polars DataFrame with a 'Place' column, for the name of the place, along with a column containting WKT.</p> from wkt<pre><code>arch_wkt = shapely.Point(-90.18497, 38.62456).wkt\nmonks_mound_wkt = shapely.Point(-90.06211, 38.66072).wkt\ndf = pl.DataFrame(  # (1)!\n    {\n        \"Place\": [\"Gateway Arch\", \"Monks Mound\"],\n        \"wkt\": [arch_wkt, monks_mound_wkt],\n    }\n)\nprint(\"Before SpatialFrame.from_WKT:\")\nprint(df)\ns_df3 = SpatialFrame.from_WKT(df, \"wkt\")  # (2)!\nprint(\"After SpatialFrame.from_WKT:\")\nprint(s_df3)\n</code></pre> <ol> <li>Creating a polars dataframe with column of WKT</li> <li> <p>SpatialFrame.from_WKT takes the wkt column, converts it to WKB and adds it to a struct column with the CRS</p> <p>Note</p> <p>Because we are not specifying a <code>crs</code> WGS84:4326 is defaulted.</p> </li> </ol> <pre><code>Before SpatialFrame.from_WKT:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 wkt                        \u2502\n\u2502 ---          \u2506 ---                        \u2502\n\u2502 str          \u2506 str                        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 POINT (-90.18497 38.62456) \u2502\n\u2502 Monks Mound  \u2506 POINT (-90.06211 38.66072) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nAfter SpatialFrame.from_WKT:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Place        \u2506 geometry                        \u2502\n\u2502 ---          \u2506 ---                             \u2502\n\u2502 str          \u2506 struct[2]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Gateway Arch \u2506 {b\"\\x01\\x01\\x00\\x00\\x00o/i\\x8c\u2026 \u2502\n\u2502 Monks Mound  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00K\\xb08\\\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/writing_data/","title":"Writing Data","text":"<p>Spatial polars provides an few options to write dataframes to spatial formats.  Like reading data, spatial polars uses pyogrio under the hood when using the <code>write_spatial</code> method to write data, so anything it can write should be fine.</p> <p>Spatial polars can also write to geoparquet with help from GeoArrow Python using the <code>write_geoparquet</code> method.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>Before we can write something, we need something to write, so we'll read some data from the geodatasets package into a dataframe.</p> setup<pre><code>import os\nimport tempfile\n\nimport geodatasets\n\nfrom spatial_polars import read_spatial\n\ndf = read_spatial(geodatasets.get_path(\"geoda.chicago_commpop\"))\n</code></pre>"},{"location":"examples/writing_data/#writing-to-a-shapefile","title":"Writing to a shapefile","text":"<p>The following example will demonstrate how easy it is to write data to an ESRI Shapefile in your temporary directory.</p> Writing to a shapefile<pre><code>output_shp_path = os.path.join(tempfile.gettempdir(), \"spatial_polars.shp\")\n\ndf.spatial.write_spatial(output_shp_path)\nprint(f\"Wrote dataframe to {output_shp_path}\")\n</code></pre>"},{"location":"examples/writing_data/#writing-to-a-geopackage","title":"Writing to a geopackage","text":"<p>The example will demonstrate how to write data to a geopackage.</p> <p>You'll notice that this is slightly more complicated than writing to a shapefile because a geopackage can store more than one table, so we need to provide the name for the table to the <code>layer</code> parameter.</p> Writing to a geopackage<pre><code>output_gpkg_path = os.path.join(tempfile.gettempdir(), \"spatial_polars.gpkg\")\n\ndf.spatial.write_spatial(output_gpkg_path, layer=\"chicago_commpop\")\nprint(f\"Wrote dataframe to {output_gpkg_path}\")\n</code></pre>"},{"location":"examples/writing_data/#appending-to-an-existing-dataset","title":"Appending to an existing dataset","text":"<p>Additionaly, many formats also support appending new records to an existing dataset.  This is done simply by adding <code>append=True</code> to our <code>write_spatial</code> call.</p> appending to a geopackage<pre><code>df.spatial.write_spatial(output_gpkg_path, layer=\"chicago_commpop\", append=True)\n</code></pre>"},{"location":"examples/writing_data/#writing-to-geoparquet","title":"Writing to geoparquet","text":"<p>The following example will demonstrate how to write data to a geoparquet file.</p> writing to geoparquet<pre><code>output_gpq_path = os.path.join(tempfile.gettempdir(), \"spatial_polars.parquet\")\n\ndf.spatial.write_geoparquet(output_gpq_path)\nprint(f\"Wrote dataframe to {output_gpq_path}\")\n</code></pre>"},{"location":"examples/expressions/geometry_column_and_scalar_geometry_input_expressions/","title":"Geometry column and scalar geometry input expressions","text":""},{"location":"examples/expressions/geometry_column_and_scalar_geometry_input_expressions/#expressions-involving-a-geometry-column-and-a-scalar-geometry","title":"Expressions involving a geometry column and a scalar geometry","text":"<p>Spatial polars has many expressions which can be called from a geometry column but need another geometry to perform the operation.</p> <p>If the desired output is to compute the operation on all the geometries in the series along with another single geometry, we can call the expression from the geometry column in our dataframe and provide the scalar geometry to the expression</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>In the example below we'll use the distance expression to compute the distance of the counties in thelower 48 states of the USA to the gateway Arch in St. Louis Mo.  Then to give some context to the numbers, we'll display the data on a Lonboard map symbolized by the distance we calculated.</p> Compute Distance To Scalar Geometry<pre><code>import geodatasets\nimport polars as pl\nimport shapely\nfrom lonboard import Map\nfrom palettable.colorbrewer.diverging import RdYlGn_11\n\nfrom spatial_polars import scan_spatial\n\narch_pt = shapely.Point(-90.18497, 38.62456)  # (1)!\n\ndf = (\n    scan_spatial(geodatasets.get_path(\"geoda.health\"))  # (2)!\n    .select(\n        \"countyname\",  # (3)!\n        \"geometry\",  # (4)!\n        pl.col(\"geometry\").spatial.distance(arch_pt).alias(\"dist_to_arch\"),  # (5)!\n    )\n    .collect(engine=\"streaming\")  # (6)!\n)\n\npolygon_layer = df.spatial.to_polygonlayer(  # (7)!\n    fill_cmap_col=\"dist_to_arch\",\n    fill_cmap_type=\"continuous\",\n    fill_cmap=RdYlGn_11,\n    fill_normalize_cmap_col=True,\n    line_width_min_pixels=0.5,\n)\n\narch_map = Map(layers=[polygon_layer])  # (8)!\narch_map\n</code></pre> <ol> <li>The point we want to compute the distance to for each of the polygons in our dataframe</li> <li>Scan some polygon data</li> <li>Select the county name</li> <li>Select the geometry column (so we can show the data on a map)</li> <li>Compute the distance of each polygon in the dataframe to our point</li> <li>Collect the query to create a dataframe</li> <li>Create a lonboard polygon layer that's symbolized by the distance we computed, making the smaller numbers(closer to the arch) red, and larger ones (further from the arch) green</li> <li>Add the layer to a map and show the results</li> </ol>"},{"location":"examples/expressions/group_by_context_expressions/","title":"Group by Expressions","text":"<p>Spatial polars has expressions (.intersection_all and .union_all) that are designed to be used in a group_by context.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>To demonstrate the usage of these functions, in the cell below we'll use polars to group some polygon data based on the <code>COUNTYFP10</code> column (an int column which holds a different code for each of the 9 different counties in the data). Then we'll compute the sum one column, count the number of rows in each group and compute the intersection of all the geometries of the polygons in the group, and show the data on a map.</p> Computing the union of all geometries in a group_by context<pre><code>import geodatasets\nfrom lonboard import Map\nfrom palettable.colorbrewer.diverging import RdYlGn_11\nimport polars as pl\n\nfrom spatial_polars import scan_spatial\n\nnyc_earnings_grouped_layer = (\n    scan_spatial(geodatasets.get_path(\"geoda.nyc_earnings\"))  # (1)!\n    .group_by(pl.col(\"COUNTYFP10\"))  # (2)!\n    .agg(\n        pl.col(\"CE03_14\").sum(),  # (3)!\n        pl.len().alias(\"original_row_cnt\"),  # (4)!\n        pl.col(\"geometry\").spatial.union_all(),  # (5)!\n    )\n    .collect(engine=\"streaming\")  # (6)!\n    .spatial.to_polygonlayer(  # (7)!\n        auto_highlight=True,\n        fill_cmap_col=\"CE03_14\",\n        fill_cmap_type=\"continuous\",\n        fill_cmap=RdYlGn_11,\n    )\n)\n\nnyc_earnings_grouped_map = Map(layers=[nyc_earnings_grouped_layer])  # (8)!\nnyc_earnings_grouped_map\n</code></pre> <ol> <li>Scan the nyc_earnings dataset into a lazyframe.</li> <li>Group the data by the <code>COUNTYFP10</code> column.</li> <li>Sum the values in the CE03_14</li> <li>Count the number of rows of the input data are in each group</li> <li>Use the union_all expression to union all the geometries of the polygons that belong to each county.</li> <li>Collect the query to create a dataframe</li> <li>Make a polygon layer symbolized by the summed CE03_14 values </li> <li>Display the layer on a lonboard map.</li> </ol>"},{"location":"examples/expressions/single_geometry_column_input_expressions/","title":"Single geometry column input expressions","text":""},{"location":"examples/expressions/single_geometry_column_input_expressions/#expressions-involving-a-single-geometry-column","title":"Expressions involving a single geometry column","text":"<p>Spatial polars has many expressions which perform one of shapely's operations or return a property from each geometry in the series.  </p> <p>To use these expressions which are called from a single geometry column, simply call the expression from the geometry column of the dataframe.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <pre><code>import geodatasets\nimport polars as pl\n\nfrom spatial_polars import scan_spatial\n\ndf = (\n    scan_spatial(\n        geodatasets.get_path(\"geoda.guerry\")  # (1)!\n    )\n    .select(\n        pl.col(\"geometry\").spatial.area().alias(\"polyogn_area\"),  # (2)!\n        pl.col(\"geometry\").spatial.length().alias(\"polyogn_perimeter\"),  # (3)!\n        pl.col(\"geometry\").spatial.bounds().alias(\"bounds\"),  # (4)!\n        pl.col(\"geometry\").spatial.centroid().alias(\"centroid\"),  # (5)!\n        pl.col(\"geometry\"),  # (6)!\n    )\n    .collect(engine=\"streaming\")\n)  # (7)!\nprint(df)\n</code></pre> <ol> <li>Scan some polygon data </li> <li>Compute .area() for each polygon aliased as 'polygon_area'.</li> <li>Compute polygon perimeter .length() for each polygon aliased as 'polygon_perimeter'</li> <li>Compute polygon extent/bounds .bounds() for each polygon aliased as 'bounds'</li> <li>Compute polygon .centroid() for each polygon aliased as 'centroid' </li> <li>Select the geometry column for our results</li> <li>Collect the query to return a dataframe</li> </ol> <p>As you can see in the results below, all these expressions (and many others in the API) are executed on a geometry column but depending on the expression different datatypes are returned</p> <pre><code>shape: (85, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 polyogn_area \u2506 polyogn_perimeter \u2506 bounds                  \u2506 centroid                \u2506 geometry               \u2502\n\u2502 ---          \u2506 ---               \u2506 ---                     \u2506 ---                     \u2506 ---                    \u2502\n\u2502 f64          \u2506 f64               \u2506 array[f64, 4]           \u2506 struct[2]               \u2506 struct[2]              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5.7843e9     \u2506 478204.340576     \u2506 [785562.0, 2.073221e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.172\u2026                \u2506 lA\\xbc\\\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 7.4359e9     \u2506 597865.43152      \u2506 [645357.0, 2.42727e6, \u2026 \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 2.5645\u2026                 \u2506 i\\xa90A\u2026                \u2506 0\\x02\\x0\u2026              \u2502\n\u2502 7.3786e9     \u2506 539122.876967     \u2506 [595532.0, 2.10432e6, \u2026 \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 2.2006\u2026                 \u2506 \\x0eE\\x\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 7.0098e9     \u2506 573525.139332     \u2506 [853311.0, 1.858801e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 1.972\u2026                \u2506 $yG\\x80\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 5.6966e9     \u2506 572041.370424     \u2506 [845528.0, 1.915176e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.022\u2026                \u2506 \\xd3\\xd\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 \u2026            \u2506 \u2026                 \u2506 \u2026                       \u2506 \u2026                       \u2506 \u2026                      \u2502\n\u2502 6.7707e9     \u2506 570165.566743     \u2506 [238257.0, 2.147245e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x06\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.237\u2026                \u2506 N\\xe6S\\\u2026                \u2506 0\\x03\\x0\u2026              \u2502\n\u2502 7.0338e9     \u2506 558978.039694     \u2506 [414673.0, 2.118365e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.244\u2026                \u2506 \\xae\\xd\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 5.5602e9     \u2506 492101.970229     \u2506 [467110.0, 2.049172e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.156\u2026                \u2506 \\xa4@\\x\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 5.9006e9     \u2506 553742.211363     \u2506 [826426.0, 2.322215e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.401\u2026                \u2506 Gt1\\xaa\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2502 7.4605e9     \u2506 582958.399801     \u2506 [638420.0, 2.258284e6,  \u2506 {b\"\\x01\\x01\\x00\\x00\\x00 \u2506 {b\"\\x01\\x03\\x00\\x00\\x0 \u2502\n\u2502              \u2506                   \u2506 \u2026 2.378\u2026                \u2506 \\xfd\\xf\u2026                \u2506 0\\x01\\x0\u2026              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/expressions/spatial_filter/","title":"Spatial filter","text":""},{"location":"examples/expressions/spatial_filter/#spatial-filter","title":"Spatial Filter","text":"<p>Spatial polars expressions which produce a boolean series can be used in polars filter context.  If we want to limit the rows in our dataframe to just the rows in a certain geographic extent we can use the .spatial.intersects() expression with a shapely geometry object to filter our dataframe to just those rows.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>Use <code>mask</code> or <code>bbox</code> if possible</p> <p>This example reads data, filters it, then displays it on a map.  If you only need data from a specific area in your workflow, using the <code>mask</code> or <code>bbox</code> parameters in the creation of the lazy/dataframe will result in a better performance, as the filter would be applied by pyogrio when reading the data.</p> Using .spatial.intersects() to filter a dataframe<pre><code>import geodatasets\nimport polars as pl\nimport shapely\nfrom lonboard import viz\n\nfrom spatial_polars import read_spatial\n\nnyc_earnings_df = read_spatial(geodatasets.get_path(\"geoda.nyc_earnings\"))  # (1)!\nprint(f\"There are {len(nyc_earnings_df):,} rows in the dataframe before filter.\")\n\nnyc_earnings_df = nyc_earnings_df.with_columns(\n    pl.col(\"geometry\").spatial.reproject(4326)  # (2)!\n)\n\npolygon = shapely.Polygon(  # (3)!\n    (\n        (-73.89257606917118, 40.78508934389371),\n        (-73.87251149764286, 40.78511666797557),\n        (-73.86103571752412, 40.80049834119043),\n        (-73.89517435900939, 40.79976075792865),\n        (-73.89257606917118, 40.78508934389371),\n    )\n)\n\nfiltered_nyc_earnings_df = nyc_earnings_df.filter(\n    pl.col(\"geometry\").spatial.intersects(polygon)  # (4)!\n)\nprint(\n    f\"There are {len(filtered_nyc_earnings_df):,} rows in the dataframe after filter.\"\n)\n\nlonboard_map = viz(  # (5)!\n    polygon,  # (6)!\n    polygon_kwargs={\n        \"get_fill_color\": (0, 0, 0, 0),  # (7)!\n        \"get_line_color\": (255, 0, 0, 255),\n        \"get_line_width\": 35,\n    },\n)\n\nfiltered_polygonlayer = filtered_nyc_earnings_df.spatial.to_polygonlayer(  # (8)!\n    fill_color=(0, 0, 255)\n)\n\nlonboard_map.layers = list(lonboard_map.layers) + [filtered_polygonlayer]  # (9)!\nlonboard_map\n</code></pre> <ol> <li>Read the nyc_earnings geodataset into a dataframe</li> <li>Reproject the data to WGS84 so we can use longitude/latitude coordinates for our filter polygon</li> <li>Create a shapely polygon we can use to filter the rows in the dataframe, this polygon covers all of Rikers Island</li> <li>Use .spatial.intersects to filter the dataframe to return the rows that intersect our polygon</li> <li>Use lonboard's viz function to make a map</li> <li>Create the map's layer from our boundary polygon</li> <li>Symbolize the polygon with no fill color, make the outline red, and make the outline 35 meters wide</li> <li>Make a polygonlayer from our filtered dataframe</li> <li>Add our filtered polygonlayer to our map</li> </ol> <pre><code>There are 108,487 rows in the dataframe before filter.\nThere are 25 rows in the dataframe after filter.\n</code></pre>"},{"location":"examples/expressions/two_geometry_column_input_expressions/","title":"Two geometry column input expressions","text":""},{"location":"examples/expressions/two_geometry_column_input_expressions/#expressions-involving-two-geometry-columns","title":"Expressions involving two geometry columns","text":"<p>Spatial polars has many expressions that can involve two geometry columns from the frame where we want to compute the results of the expression row wise between the geometries in two columns. Because polars expressions only operate on one column, both geometry columns need to first be added to a struct before we call the spatial expression to perform the computation.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>To demonstrate, we'll start with our lake_boundary_df dataframe from the spatial join example</p> Creating a dataframe with two geometry struct columns<pre><code>import polars as pl\n\nfrom spatial_polars import scan_spatial\n\nlake_df = (\n    scan_spatial(\"https://naciscdn.org/naturalearth/110m/physical/ne_110m_lakes.zip\")\n    .select(\"name\", \"geometry\")\n    .collect(engine=\"streaming\")\n)\nprint(f\"There are {len(lake_df)} rows in lake_df\")\n\nboundary_df = (\n    scan_spatial(\n        \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n    )\n    .select(\"SOVEREIGNT\", \"geometry\")\n    .collect(engine=\"streaming\")\n)\n\nlake_boundary_df = (\n    lake_df.spatial.join(\n        other=boundary_df,\n        how=\"inner\",\n        predicate=\"intersects\",\n        on=\"geometry\",\n        suffix=\"_boundary\",\n    )\n    .select(\n        pl.col(\"name\"),\n        pl.col(\"SOVEREIGNT\"),\n        pl.col(\"geometry\"),\n        pl.col(\"geometry_boundary\"),\n    )\n    .sort(\"name\")\n)\nprint(lake_boundary_df)\n</code></pre> <p>Note</p> <ol> <li>For details about what's happening here see spatial join example</li> </ol> <p>Currently in the lake_boundary_df, the lakes which cross a boundary are represented by two rows.  Each row has a column \"geometry\" with the geometry of the lake, and a column \"geometry_boundary\" with the geometry of the boundary for the different boundaries. There is no differentiation of which portion of the lake is in which boundary.</p> <p>To determine which part of the lake is in which boundary, we can use the .intersection() expression to determine the portion of the lake that intersects the boundary.  If we wanted to find the intersection of ALL the lakes to a single other polygon we could use the <code>other</code> parameter of the <code>.intersection()</code> method similar to how we used .distance() in the geometry column and scalar geometry input expression, but since we want to know where the lakes from the geometry column intersect the boundary from the geometry_boundary column in a row-wise manner, we will add both the geometry and geometry_boundary columns to a struct and ignore the <code>other</code> parameter.  Spatial polars will then compute the intersection of the lake with the boundary and return the geometry of the lake which intersects the geometry of the boundary for each row, essentially cutting the lakes where they cross the bounary.</p> Computing the intersection of lakes and boundaries<pre><code>lake_boundary_map = (\n    lake_boundary_df.filter(\n        pl.col(\"SOVEREIGNT\").is_in([\"United States of America\", \"Canada\"])  # (1)!\n    )\n    .with_columns(\n        pl.struct(\n            pl.col(\"geometry\"),\n            pl.col(\"geometry_boundary\"),  # (2)!\n        ).spatial.intersection()  # (3)!\n    )\n    .drop(\"geometry_boundary\")  # (4)!\n    .spatial.viz(\"geometry\", polygon_kwargs={\"auto_highlight\": True})  # (5)!\n)\nlake_boundary_map\n</code></pre> <ol> <li>Filter the dataframe to the rows that are in USA and Canada (just to make the map we'll produce later show up in an area where we have a lot of lakes crossing a boundary)</li> <li>Add the 'geometry' and 'geometry_boundary' columns to a struct</li> <li> <p>Use the .spatial.intersection expression on the struct to compute a polygon that is the common area of the lake's geometry and the boundary's geometry for each set of lake/boundary row-wise</p> <p>Note</p> <p>Becasue we added the 'geometry' column to the struct first and, did not alias the result of the expression, the result of the expression will overwrite the data in the geometry column.  in this case that's what we want, but if you need to preserve the original geometry column, you will need to alias the result of the expression.</p> </li> <li> <p>Drop the geometry_boundary column (we dont need it anymore)</p> </li> <li>Pass the dataframe to the .viz() function with <code>auto_highlight=True</code> so when we move our mouse over a polygon on the map it will change color</li> </ol>"},{"location":"examples/visualization/pathlayer/","title":"PathLayer (lines)","text":"<p>In this notebook we will demonstrate using spatial polars to visualize spatial data on a Lonboard map using a path layer to visualize the polylines.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p>"},{"location":"examples/visualization/pathlayer/#creating-a-pathlayer","title":"Creating a PathLayer","text":"<p>The following cell will read the eea large rivers polyline dataset into a dataframe and create a Lonboard PathLayer</p> Creating a pathlayer<pre><code>import geodatasets\nfrom lonboard import Map\n\nfrom spatial_polars import read_spatial\n\nlarge_rivers_df = read_spatial(geodatasets.get_path(\"eea.large_rivers\"))  # (1)!\n\npathlayer = large_rivers_df.spatial.to_pathlayer(  # (2)!\n    auto_highlight=True,  # (3)!\n    color=(0, 0, 255),  # (4)!\n    width_min_pixels=5,  # (5)!\n)\n\npathlayer_map = Map(layers=[pathlayer])  # (6)!\npathlayer_map\n</code></pre> <ol> <li>Read the eea.large_rivers geodataset into a dataframe</li> <li>Create a pathlayer from the dataframe</li> <li>When we mouse over a point in the map, it will change color</li> <li>Color all the lines blue</li> <li>Make them always at least 5px wide on the </li> <li>Add layer to a map and display it</li> </ol>"},{"location":"examples/visualization/polygonlayer/","title":"PolygonLayer (polygons)","text":"<p>In this notebook we will demonstrate using spatial polars to visualize spatial data on a Lonboard map using a polygon layer to visualize the polygons.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p>"},{"location":"examples/visualization/polygonlayer/#creating-a-polygonlayer","title":"Creating a PolygonLayer","text":"<p>The following cell will read the nyc earnings dataset into a dataframe and create a Lonboard PolygonLayer</p> <p>I don't know much about the dataset but my understanding is that the CE03_* columns contain the number of jobs in within the polygon that earn more than $3333/month and all the polygons are in the New York City area, and it looks like \"COUNTYFP10\"==61 just gives us the polygons in Manhattan.  The content of the data isn't super critical, we're here just to show how we can use spatial polars to make a lonboard polygon layer that looks really nice.</p> Creating a polygonlayer<pre><code>import geodatasets\nfrom lonboard import Map\nfrom palettable.colorbrewer.diverging import RdYlGn_11\nimport polars as pl\n\n\nfrom spatial_polars import scan_spatial\n\nnyc_earnings_df = (\n    scan_spatial(geodatasets.get_path(\"geoda.nyc_earnings\"))  # (1)!\n    .filter(pl.col(\"COUNTYFP10\") == 61)  # (2)!\n    .collect(engine=\"streaming\")\n)\n\npolygon_layer = nyc_earnings_df.spatial.to_polygonlayer(  # (3)!\n    fill_cmap_col=\"CE03_14\",  # (4)!\n    fill_cmap_type=\"continuous\",  # (5)!\n    fill_cmap=RdYlGn_11,  # (6)!\n    fill_normalize_cmap_col=True,  # (7)!\n    elevation=\"CE03_14\",  # (8)!\n    wireframe=True,  # (9)!\n)\n\npolygonlayer_map = Map(layers=[polygon_layer])  # (10)!\npolygonlayer_map\n</code></pre> <ol> <li>Scan the geoda.nyc_earnings geodataset</li> <li>Filter to just the rows in manhattan </li> <li>Create a polygonlayer</li> <li>Use the values from the CE03_14 column to base our fill colors</li> <li>The values in the column are continuous, not discreete categories, so we will use <code>fill_cmap_type=\"continuous\"</code> </li> <li>Palettable's RdYlGn_11 color map will be used for the colors of the polygons</li> <li>The values in the column are not all between 0-1 so we will use <code>fill_normalize_cmap_col=True</code> (True is the default, so we don't really need to specify it, but it's important so I wanted to call attention to it) which will scale a copy of the numbers in the column to be between 0-1 before using Lonboard's apply_continuous_cmap function to set the color of each polygon.  If our column contained values that were all between 0-1 we could have used <code>fill_normalize_cmap_col=False</code>.</li> <li>Use the \"CE03_14\" column to base our elevations of our polygons, so the different polygons will stick out of the map corresponding to the values in that column of our dataframe, Specifying the column name for the elevation will set the <code>extruded</code> property on the layer to be True.  </li> <li>To make the edges of extruded polygons look really sharp, we'll set <code>wireframe=True</code>.</li> <li>display the polygonlayer on a map</li> </ol> <p>Because the data uses a coordinate reference system other than EPSG:4326, Lonboard will emit a warning that our input data is going to be re-projected to EPSG:4326.  To avoid that warning we could have reprojected the data in the dataframe with the spatial.reproject() expression on the geometry column before creating the PolygonLayer.</p> <p>Tip</p> <p>Right clicking, and moving your mouse on the lonboard map will allow you to tilt the view angle and really make those buildings look neat!</p> <p>Note</p> <p>If you're interested in using a categorical colormap instead of a continuous, head over to the scatterplotlayer example to check out how we can do it.</p>"},{"location":"examples/visualization/scatterplotlayer/","title":"ScatterPlotLayer (points)","text":"<p>In this notebook we will demonstrate using spatial polars to visualize spatial data on a Lonboard map usign a scatterplot layer to visualize the point data.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p>"},{"location":"examples/visualization/scatterplotlayer/#creating-a-scatterplotlayer","title":"Creating a ScatterplotLayer","text":"<p>The following cell will read the geoda home sales point dataset into a dataframe and create a Lonboard ScatterplotLayer</p> Creating a scatterplotlayer<pre><code>import geodatasets\nfrom lonboard import Map\nfrom spatial_polars import read_spatial\n\nhome_sales_df = read_spatial(geodatasets.get_path(\"geoda.home_sales\"))  # (1)!\n\nscatterplotlayer = home_sales_df.spatial.to_scatterplotlayer(  # (2)!\n    fill_cmap_col=\"floors\",  # (3)!\n    fill_cmap_type=\"categorical\",  # (4)!\n    fill_cmap={1: (255, 0, 0), 2: (0, 255, 0), 3: (0, 0, 255)},  # (5)!\n    radius=250,  # (6)!\n    stroked=False,  # (7)!\n)\n\nscatterplotlayer_map = Map(layers=[scatterplotlayer])  # (8)!\nscatterplotlayer_map\n</code></pre> <ol> <li>Read the geoda.home_sales geodataset</li> <li>Create the scatterplotlayer</li> <li>Use the values in the 'floors' column to set the color of the points in the layer</li> <li>Use a categorical color mapping dictionary to set the color of the points</li> <li>If the number of floors is 1 the point will be red, two floors will be green, and three will be blue</li> <li>The number of meters for the point symbols on the map</li> <li>The points will not have an outline drawn around them</li> <li>Show the scatterplotlayer on a map</li> </ol> <p>Note</p> <p>If you're interested in using a continuous colormap instead of a categorical, head over to the polygonlayer example to check out how we can do it.</p>"},{"location":"examples/visualization/viz/","title":"Vis","text":"<p>In this notebook we will demonstrate using spatial polars to visualize spatial data on a Lonboard map using Lonboard's .vis function.</p> <p>Note</p> <p>This example makes use the geodatasets python package to access some spatial data easily.</p> <p>Calling <code>geodatasets.get_path()</code> will download data the specified data to the machine and return the path to the downloaded file.  If the file has already been downloaded it will simply return the path to the file.  See downloading and caching for further details.</p> <p>Sometimes you just want to see stuff on a map to check out what the data looks like, you dont really care about the colors or any specifics, just show me something.  Lonboard's viz has you covered.  All we have to do is call  .spatial.viz() and it will take the data in our dataframe and add it to a map, no need to fiddle with making a map and a layer and adding the layer to the map, super easy!  If you have specific parameters to set for the layer or map, they can be provided as dictionaries to the *_kwargs parameters for the layer type or the map.</p> <p>In the example below we'll read the geoda.milwaukee1 dataset into a dataframe and the call <code>.spatial.viz()</code> from the dataframe, and it will give us a map showing some polygons around the Milwaukee area.  Big shout out to all my people over in Mukwonago (it's where ya wanna go!)</p> using .viz<pre><code>import geodatasets\n\nfrom spatial_polars import read_spatial\n\ngeoda_milwaukee1_df = read_spatial(geodatasets.get_path(\"geoda.milwaukee1\"))  # (1)!\nmilwaukee_map = geoda_milwaukee1_df.spatial.viz()  # (2)!\n\nmilwaukee_map\n</code></pre> <ol> <li>Read the geoda.milwaukee1 geodataset into a dataframe</li> <li>Create a map from the dataframe using viz with no kwargs</li> </ol>"}]}